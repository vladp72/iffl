<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: iffl::flat_forward_list&lt; T, TT, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceiffl.html">iffl</a></li><li class="navelem"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classiffl_1_1flat__forward__list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iffl::flat_forward_list&lt; T, TT, A &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Intrusive flat forward list container.  
 <a href="classiffl_1_1flat__forward__list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iffl__list_8h_source.html">iffl_list.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ac458d0d66ccdaaec707b1431fcdbbd"><td class="memItemLeft" align="right" valign="top"><a id="a8ac458d0d66ccdaaec707b1431fcdbbd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a8ac458d0d66ccdaaec707b1431fcdbbd">value_type</a> = T</td></tr>
<tr class="memdesc:a8ac458d0d66ccdaaec707b1431fcdbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element value type. <br /></td></tr>
<tr class="separator:a8ac458d0d66ccdaaec707b1431fcdbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128eb9f150c742d53560309cfe6eb3c5"><td class="memItemLeft" align="right" valign="top"><a id="a128eb9f150c742d53560309cfe6eb3c5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a128eb9f150c742d53560309cfe6eb3c5">pointer</a> = T *</td></tr>
<tr class="memdesc:a128eb9f150c742d53560309cfe6eb3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to element type. <br /></td></tr>
<tr class="separator:a128eb9f150c742d53560309cfe6eb3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af312a267e8c0a38c474dfa0004b40fa3"><td class="memItemLeft" align="right" valign="top"><a id="af312a267e8c0a38c474dfa0004b40fa3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#af312a267e8c0a38c474dfa0004b40fa3">const_pointer</a> = T const *</td></tr>
<tr class="memdesc:af312a267e8c0a38c474dfa0004b40fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const element type. <br /></td></tr>
<tr class="separator:af312a267e8c0a38c474dfa0004b40fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812aa137b7ed6e63b9543cdc41eae3d6"><td class="memItemLeft" align="right" valign="top"><a id="a812aa137b7ed6e63b9543cdc41eae3d6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a812aa137b7ed6e63b9543cdc41eae3d6">reference</a> = T &amp;</td></tr>
<tr class="memdesc:a812aa137b7ed6e63b9543cdc41eae3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the element type. <br /></td></tr>
<tr class="separator:a812aa137b7ed6e63b9543cdc41eae3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad4d8b9dc0bf776961bbbe73c0225c2"><td class="memItemLeft" align="right" valign="top"><a id="a9ad4d8b9dc0bf776961bbbe73c0225c2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a9ad4d8b9dc0bf776961bbbe73c0225c2">const_reference</a> = T const &amp;</td></tr>
<tr class="memdesc:a9ad4d8b9dc0bf776961bbbe73c0225c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the const element type. <br /></td></tr>
<tr class="separator:a9ad4d8b9dc0bf776961bbbe73c0225c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fdcd8ca95876ed148244983cd4929b"><td class="memItemLeft" align="right" valign="top"><a id="a08fdcd8ca95876ed148244983cd4929b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a08fdcd8ca95876ed148244983cd4929b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type. <br /></td></tr>
<tr class="separator:a08fdcd8ca95876ed148244983cd4929b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdf824d13a9684d98d37a761498978e"><td class="memItemLeft" align="right" valign="top"><a id="affdf824d13a9684d98d37a761498978e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#affdf824d13a9684d98d37a761498978e">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:affdf824d13a9684d98d37a761498978e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element pointers difference type. <br /></td></tr>
<tr class="separator:affdf824d13a9684d98d37a761498978e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b68b3a1e07c7c52315ff772c65f1bc8"><td class="memItemLeft" align="right" valign="top"><a id="a9b68b3a1e07c7c52315ff772c65f1bc8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a9b68b3a1e07c7c52315ff772c65f1bc8">traits</a> = TT</td></tr>
<tr class="memdesc:a9b68b3a1e07c7c52315ff772c65f1bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element traits type. <br /></td></tr>
<tr class="separator:a9b68b3a1e07c7c52315ff772c65f1bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8867a540f190241bd3994aee8f75c16"><td class="memItemLeft" align="right" valign="top"><a id="ae8867a540f190241bd3994aee8f75c16"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ae8867a540f190241bd3994aee8f75c16">traits_traits</a> = <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">flat_forward_list_traits_traits</a>&lt; TT &gt;</td></tr>
<tr class="memdesc:ae8867a540f190241bd3994aee8f75c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element traits traits type. <br /></td></tr>
<tr class="separator:ae8867a540f190241bd3994aee8f75c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47445e33823a03584f99b950839ecd9a"><td class="memItemLeft" align="right" valign="top"><a id="a47445e33823a03584f99b950839ecd9a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a47445e33823a03584f99b950839ecd9a">range_t</a> = typename <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#af88543910b2f89f5cb271c57aea132ab">traits_traits::range_t</a></td></tr>
<tr class="memdesc:a47445e33823a03584f99b950839ecd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type used to describe buffer used by the element and how much of this buffer is used by the data. Type also includes information about required alignment. <br /></td></tr>
<tr class="separator:a47445e33823a03584f99b950839ecd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831bd04814b1b7f25ca0c8462adcc997"><td class="memItemLeft" align="right" valign="top"><a id="a831bd04814b1b7f25ca0c8462adcc997"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a831bd04814b1b7f25ca0c8462adcc997">size_with_padding_t</a> = typename <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#ad77593ff4fd28ace80b243920a57bc51">traits_traits::size_with_padding_t</a></td></tr>
<tr class="memdesc:a831bd04814b1b7f25ca0c8462adcc997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type used to describe size with padding. <br /></td></tr>
<tr class="separator:a831bd04814b1b7f25ca0c8462adcc997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391e14005459b20e9596175e92943147"><td class="memItemLeft" align="right" valign="top"><a id="a391e14005459b20e9596175e92943147"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a391e14005459b20e9596175e92943147">offset_with_aligment_t</a> = typename <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#aaa01a29e472dfdd74fd15b2c63387a51">traits_traits::offset_with_aligment_t</a></td></tr>
<tr class="memdesc:a391e14005459b20e9596175e92943147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type used to describe size with alignment. <br /></td></tr>
<tr class="separator:a391e14005459b20e9596175e92943147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff96502bf2dc94c9849cfd820ec5166"><td class="memItemLeft" align="right" valign="top"><a id="a3ff96502bf2dc94c9849cfd820ec5166"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a3ff96502bf2dc94c9849cfd820ec5166">sizes_t</a> = <a class="el" href="structiffl_1_1flat__forward__list__sizes.html">flat_forward_list_sizes</a>&lt; <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#aa3fe68f843e48534915ef6303cd45deb">traits_traits::alignment</a> &gt;</td></tr>
<tr class="memdesc:a3ff96502bf2dc94c9849cfd820ec5166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that contains information about buffer size, and last element range. <br /></td></tr>
<tr class="separator:a3ff96502bf2dc94c9849cfd820ec5166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eff6c3870e8a47e546f9b3312b2d71"><td class="memItemLeft" align="right" valign="top"><a id="a48eff6c3870e8a47e546f9b3312b2d71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a48eff6c3870e8a47e546f9b3312b2d71">allocator_type</a> = typename std::allocator_traits&lt; A &gt;::template rebind_alloc&lt; char &gt;</td></tr>
<tr class="memdesc:a48eff6c3870e8a47e546f9b3312b2d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of allocator. <br /></td></tr>
<tr class="separator:a48eff6c3870e8a47e546f9b3312b2d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb8af508136a184801ff710cd6e2fcd"><td class="memItemLeft" align="right" valign="top"><a id="a6fb8af508136a184801ff710cd6e2fcd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a6fb8af508136a184801ff710cd6e2fcd">allocator_type_traits</a> = std::allocator_traits&lt; <a class="el" href="classiffl_1_1flat__forward__list.html#a48eff6c3870e8a47e546f9b3312b2d71">allocator_type</a> &gt;</td></tr>
<tr class="memdesc:a6fb8af508136a184801ff710cd6e2fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of allocator traits. <br /></td></tr>
<tr class="separator:a6fb8af508136a184801ff710cd6e2fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bcd72c49e150e53c92fbf8c52158db"><td class="memItemLeft" align="right" valign="top"><a id="ac4bcd72c49e150e53c92fbf8c52158db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ac4bcd72c49e150e53c92fbf8c52158db">buffer_value_type</a> = char</td></tr>
<tr class="memdesc:ac4bcd72c49e150e53c92fbf8c52158db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since we have variable size elementa, and we cannot express it in the C++ type system we treat buffer with elements as a bag of chars and cast to the element type when nessesary. <br /></td></tr>
<tr class="separator:ac4bcd72c49e150e53c92fbf8c52158db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807ca2364067cfa7fbd53da376d34c6b"><td class="memItemLeft" align="right" valign="top"><a id="a807ca2364067cfa7fbd53da376d34c6b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a807ca2364067cfa7fbd53da376d34c6b">const_buffer_value_type</a> = char const</td></tr>
<tr class="memdesc:a807ca2364067cfa7fbd53da376d34c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">When we do not intend to modify buffer we can treat it as a bag of const characters. <br /></td></tr>
<tr class="separator:a807ca2364067cfa7fbd53da376d34c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a300ed4e0567e4b23cf7ff74b6add76"><td class="memItemLeft" align="right" valign="top"><a id="a6a300ed4e0567e4b23cf7ff74b6add76"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a6a300ed4e0567e4b23cf7ff74b6add76">buffer_pointer</a> = char *</td></tr>
<tr class="memdesc:a6a300ed4e0567e4b23cf7ff74b6add76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used as a buffer pointer. <br /></td></tr>
<tr class="separator:a6a300ed4e0567e4b23cf7ff74b6add76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc6de39012aca12afaeaeb27e12507f"><td class="memItemLeft" align="right" valign="top"><a id="a8cc6de39012aca12afaeaeb27e12507f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a8cc6de39012aca12afaeaeb27e12507f">const_buffer_pointer</a> = char const *</td></tr>
<tr class="memdesc:a8cc6de39012aca12afaeaeb27e12507f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used as a pointer ot the const buffer. <br /></td></tr>
<tr class="separator:a8cc6de39012aca12afaeaeb27e12507f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bf6a6f46962a1fbaf0d2f7d91098f2"><td class="memItemLeft" align="right" valign="top"><a id="a59bf6a6f46962a1fbaf0d2f7d91098f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> = <a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; T, TT &gt;</td></tr>
<tr class="memdesc:a59bf6a6f46962a1fbaf0d2f7d91098f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iterator. <br /></td></tr>
<tr class="separator:a59bf6a6f46962a1fbaf0d2f7d91098f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade934330e2dce8176985d15f7ee927cf"><td class="memItemLeft" align="right" valign="top"><a id="ade934330e2dce8176985d15f7ee927cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> = <a class="el" href="namespaceiffl.html#ad67086ee8db08a7b96df7f9759d02a1b">flat_forward_list_const_iterator</a>&lt; T, TT &gt;</td></tr>
<tr class="memdesc:ade934330e2dce8176985d15f7ee927cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of const iterator. <br /></td></tr>
<tr class="separator:ade934330e2dce8176985d15f7ee927cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8f1baf4a08c0cd00c7108bc3442f22"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a3e8f1baf4a08c0cd00c7108bc3442f22">buffer_type</a> = <a class="el" href="structiffl_1_1buffer__t.html">buffer_t</a>&lt; <a class="el" href="classiffl_1_1flat__forward__list.html#ac4bcd72c49e150e53c92fbf8c52158db">buffer_value_type</a> &gt;</td></tr>
<tr class="memdesc:a3e8f1baf4a08c0cd00c7108bc3442f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers that describe buffer.  <a href="#a3e8f1baf4a08c0cd00c7108bc3442f22">More...</a><br /></td></tr>
<tr class="separator:a3e8f1baf4a08c0cd00c7108bc3442f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d6b97919909d4b2ac0da9120fc0394b"><td class="memItemLeft" align="right" valign="top"><a id="a6d6b97919909d4b2ac0da9120fc0394b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a6d6b97919909d4b2ac0da9120fc0394b">flat_forward_list</a> () noexcept</td></tr>
<tr class="memdesc:a6d6b97919909d4b2ac0da9120fc0394b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for container. <br /></td></tr>
<tr class="separator:a6d6b97919909d4b2ac0da9120fc0394b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cc0c79c368b98ba0827a5823165f4f"><td class="memItemLeft" align="right" valign="top"><a id="a62cc0c79c368b98ba0827a5823165f4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a62cc0c79c368b98ba0827a5823165f4f">flat_forward_list</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a48eff6c3870e8a47e546f9b3312b2d71">allocator_type</a> a) noexcept</td></tr>
<tr class="memdesc:a62cc0c79c368b98ba0827a5823165f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with an instance of provided allocator. <br /></td></tr>
<tr class="separator:a62cc0c79c368b98ba0827a5823165f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749f152e4fb3d8781277060f19609048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a749f152e4fb3d8781277060f19609048">flat_forward_list</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a749f152e4fb3d8781277060f19609048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Moves allocator and content of other container to this container.  <a href="#a749f152e4fb3d8781277060f19609048">More...</a><br /></td></tr>
<tr class="separator:a749f152e4fb3d8781277060f19609048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0add72d0b2150302c9c66a16ba70bc52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a0add72d0b2150302c9c66a16ba70bc52">flat_forward_list</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> const &amp;other)</td></tr>
<tr class="memdesc:a0add72d0b2150302c9c66a16ba70bc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Copies allocator if supprted and copies content of other container to this container.  <a href="#a0add72d0b2150302c9c66a16ba70bc52">More...</a><br /></td></tr>
<tr class="separator:a0add72d0b2150302c9c66a16ba70bc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c6c251f25b12c0287092d215f8574c"><td class="memTemplParams" colspan="2">template&lt;typename AA  = allocator_type&gt; </td></tr>
<tr class="memitem:ab0c6c251f25b12c0287092d215f8574c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ab0c6c251f25b12c0287092d215f8574c">flat_forward_list</a> (<a class="el" href="structiffl_1_1attach__buffer.html">attach_buffer</a>, <a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;other_buff, AA &amp;&amp;a=AA{}) noexcept</td></tr>
<tr class="memdesc:ab0c6c251f25b12c0287092d215f8574c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes ownership of a buffer.  <a href="#ab0c6c251f25b12c0287092d215f8574c">More...</a><br /></td></tr>
<tr class="separator:ab0c6c251f25b12c0287092d215f8574c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccbf673a48dc329bc645f1abc8a5823"><td class="memTemplParams" colspan="2">template&lt;typename AA  = allocator_type&gt; </td></tr>
<tr class="memitem:afccbf673a48dc329bc645f1abc8a5823"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#afccbf673a48dc329bc645f1abc8a5823">flat_forward_list</a> (<a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;other_buff, AA &amp;&amp;a=AA{})</td></tr>
<tr class="memdesc:afccbf673a48dc329bc645f1abc8a5823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that copies list from a buffer.  <a href="#afccbf673a48dc329bc645f1abc8a5823">More...</a><br /></td></tr>
<tr class="separator:afccbf673a48dc329bc645f1abc8a5823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8a3c637cb02c0d00bf0b4d991b3ab6"><td class="memTemplParams" colspan="2">template&lt;typename AA  = allocator_type&gt; </td></tr>
<tr class="memitem:a7e8a3c637cb02c0d00bf0b4d991b3ab6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a7e8a3c637cb02c0d00bf0b4d991b3ab6">flat_forward_list</a> (<a class="el" href="structiffl_1_1attach__buffer.html">attach_buffer</a>, char *buffer_begin, char *last_element, char *buffer_end, AA &amp;&amp;a=AA{}) noexcept</td></tr>
<tr class="memdesc:a7e8a3c637cb02c0d00bf0b4d991b3ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes ownership of a buffer.  <a href="#a7e8a3c637cb02c0d00bf0b4d991b3ab6">More...</a><br /></td></tr>
<tr class="separator:a7e8a3c637cb02c0d00bf0b4d991b3ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91f5a5db96c9ed92dff41ca79c0dc35"><td class="memTemplParams" colspan="2">template&lt;typename AA  = allocator_type&gt; </td></tr>
<tr class="memitem:ae91f5a5db96c9ed92dff41ca79c0dc35"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ae91f5a5db96c9ed92dff41ca79c0dc35">flat_forward_list</a> (char const *buffer_begin, char const *last_element, char const *buffer_end, AA &amp;&amp;a=AA{})</td></tr>
<tr class="memdesc:ae91f5a5db96c9ed92dff41ca79c0dc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that copies list from a buffer.  <a href="#ae91f5a5db96c9ed92dff41ca79c0dc35">More...</a><br /></td></tr>
<tr class="separator:ae91f5a5db96c9ed92dff41ca79c0dc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a50df8a0aeff99375371fa4679fa85a"><td class="memTemplParams" colspan="2">template&lt;typename AA  = allocator_type&gt; </td></tr>
<tr class="memitem:a2a50df8a0aeff99375371fa4679fa85a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a2a50df8a0aeff99375371fa4679fa85a">flat_forward_list</a> (<a class="el" href="structiffl_1_1attach__buffer.html">attach_buffer</a>, char *buffer, size_t buffer_size, AA &amp;&amp;a=AA{}) noexcept</td></tr>
<tr class="memdesc:a2a50df8a0aeff99375371fa4679fa85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes ownership of a buffer and attempts to find last element of the list.  <a href="#a2a50df8a0aeff99375371fa4679fa85a">More...</a><br /></td></tr>
<tr class="separator:a2a50df8a0aeff99375371fa4679fa85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf497e76a8d8462697d1897dfcf1b63b"><td class="memTemplParams" colspan="2">template&lt;typename AA  = allocator_type&gt; </td></tr>
<tr class="memitem:abf497e76a8d8462697d1897dfcf1b63b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#abf497e76a8d8462697d1897dfcf1b63b">flat_forward_list</a> (char const *buffer, size_t buffer_size, AA &amp;&amp;a=AA{})</td></tr>
<tr class="memdesc:abf497e76a8d8462697d1897dfcf1b63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that checks if buffer contains a valid list and if it does then copies that list.  <a href="#abf497e76a8d8462697d1897dfcf1b63b">More...</a><br /></td></tr>
<tr class="separator:abf497e76a8d8462697d1897dfcf1b63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59af9a85096de0323b690c08004fe015"><td class="memTemplParams" colspan="2">template&lt;typename AA  = allocator_type&gt; </td></tr>
<tr class="memitem:a59af9a85096de0323b690c08004fe015"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a59af9a85096de0323b690c08004fe015">flat_forward_list</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#a74ef3b5ffc610931999a6f7c53239507">begin</a>, <a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#a5e954cb6c473db357ea47abefb1fbf86">last</a>, AA &amp;&amp;a=AA{})</td></tr>
<tr class="memdesc:a59af9a85096de0323b690c08004fe015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies element pointed by the iterators.  <a href="#a59af9a85096de0323b690c08004fe015">More...</a><br /></td></tr>
<tr class="separator:a59af9a85096de0323b690c08004fe015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60ccc1f4b9767dbda08355a66484afe"><td class="memTemplParams" colspan="2">template&lt;typename AA  = allocator_type&gt; </td></tr>
<tr class="memitem:ac60ccc1f4b9767dbda08355a66484afe"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ac60ccc1f4b9767dbda08355a66484afe">flat_forward_list</a> (<a class="el" href="namespaceiffl.html#a06df220d9126052279a6c8c6cd3e482a">flat_forward_list_view</a>&lt; T, TT &gt; const &amp;view, AA &amp;&amp;a=AA{})</td></tr>
<tr class="memdesc:ac60ccc1f4b9767dbda08355a66484afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies element from the view.  <a href="#ac60ccc1f4b9767dbda08355a66484afe">More...</a><br /></td></tr>
<tr class="separator:ac60ccc1f4b9767dbda08355a66484afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaed0d20746c46aae94752b6308a0344"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#acaed0d20746c46aae94752b6308a0344">operator=</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> &amp;&amp;other) noexcept(allocator_type_traits::propagate_on_container_move_assignment::value)</td></tr>
<tr class="memdesc:acaed0d20746c46aae94752b6308a0344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#acaed0d20746c46aae94752b6308a0344">More...</a><br /></td></tr>
<tr class="separator:acaed0d20746c46aae94752b6308a0344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ba60911e7af2cf14a26acfed6e6771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#af4ba60911e7af2cf14a26acfed6e6771">operator=</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> const &amp;other)</td></tr>
<tr class="memdesc:af4ba60911e7af2cf14a26acfed6e6771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#af4ba60911e7af2cf14a26acfed6e6771">More...</a><br /></td></tr>
<tr class="separator:af4ba60911e7af2cf14a26acfed6e6771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ff402c3c60a1f615e80a0e01489a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a79ff402c3c60a1f615e80a0e01489a64">operator=</a> (<a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;other_buff)</td></tr>
<tr class="memdesc:a79ff402c3c60a1f615e80a0e01489a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a79ff402c3c60a1f615e80a0e01489a64">More...</a><br /></td></tr>
<tr class="separator:a79ff402c3c60a1f615e80a0e01489a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8076875ac67c0dd3e95c2915fee0c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a4e8076875ac67c0dd3e95c2915fee0c2">~flat_forward_list</a> () noexcept</td></tr>
<tr class="memdesc:a4e8076875ac67c0dd3e95c2915fee0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a4e8076875ac67c0dd3e95c2915fee0c2">More...</a><br /></td></tr>
<tr class="separator:a4e8076875ac67c0dd3e95c2915fee0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aa8899ef08ac7e2de76f8666d71774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiffl.html#a78536459b06204bafd2ddbfb7b778df9">buffer_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a98aa8899ef08ac7e2de76f8666d71774">detach</a> () noexcept</td></tr>
<tr class="memdesc:a98aa8899ef08ac7e2de76f8666d71774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container releases ownership of the buffer.  <a href="#a98aa8899ef08ac7e2de76f8666d71774">More...</a><br /></td></tr>
<tr class="separator:a98aa8899ef08ac7e2de76f8666d71774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e28a8e192f0ebd7fd2024bb76690fc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a7e28a8e192f0ebd7fd2024bb76690fc9">attach</a> (<a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;other_buff)</td></tr>
<tr class="memdesc:a7e28a8e192f0ebd7fd2024bb76690fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of a buffer.  <a href="#a7e28a8e192f0ebd7fd2024bb76690fc9">More...</a><br /></td></tr>
<tr class="separator:a7e28a8e192f0ebd7fd2024bb76690fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9902201e3d45a15b96b0e5582137e11e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a9902201e3d45a15b96b0e5582137e11e">attach</a> (char *buffer_begin, char *last_element, char *buffer_end) noexcept</td></tr>
<tr class="memdesc:a9902201e3d45a15b96b0e5582137e11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of a buffer.  <a href="#a9902201e3d45a15b96b0e5582137e11e">More...</a><br /></td></tr>
<tr class="separator:a9902201e3d45a15b96b0e5582137e11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7257d26d9b667a333b2ccb76e46e33b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a7257d26d9b667a333b2ccb76e46e33b8">attach</a> (char *buffer, size_t buffer_size) noexcept</td></tr>
<tr class="memdesc:a7257d26d9b667a333b2ccb76e46e33b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of a buffer and attempts to find last element of the list.  <a href="#a7257d26d9b667a333b2ccb76e46e33b8">More...</a><br /></td></tr>
<tr class="separator:a7257d26d9b667a333b2ccb76e46e33b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1b7f1ce1d9a6e473d32e7722df3546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a5e1b7f1ce1d9a6e473d32e7722df3546">assign</a> (<a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;other_buff)</td></tr>
<tr class="memdesc:a5e1b7f1ce1d9a6e473d32e7722df3546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies list from a buffer.  <a href="#a5e1b7f1ce1d9a6e473d32e7722df3546">More...</a><br /></td></tr>
<tr class="separator:a5e1b7f1ce1d9a6e473d32e7722df3546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe9875e1f49a8c397c9e54baeab1b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#acbe9875e1f49a8c397c9e54baeab1b19">assign</a> (char const *buffer_begin, char const *last_element, char const *buffer_end)</td></tr>
<tr class="memdesc:acbe9875e1f49a8c397c9e54baeab1b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies list from a buffer.  <a href="#acbe9875e1f49a8c397c9e54baeab1b19">More...</a><br /></td></tr>
<tr class="separator:acbe9875e1f49a8c397c9e54baeab1b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fd209537cfdc6e3815b7fe73339395"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a34fd209537cfdc6e3815b7fe73339395">assign</a> (char const *buffer_begin, char const *buffer_end)</td></tr>
<tr class="memdesc:a34fd209537cfdc6e3815b7fe73339395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if buffer contains a valid list and if it does then copies that list.  <a href="#a34fd209537cfdc6e3815b7fe73339395">More...</a><br /></td></tr>
<tr class="separator:a34fd209537cfdc6e3815b7fe73339395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0aca8620ca3d7046ae16ede95d3e7df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ac0aca8620ca3d7046ae16ede95d3e7df">assign</a> (char const *buffer, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> buffer_size)</td></tr>
<tr class="memdesc:ac0aca8620ca3d7046ae16ede95d3e7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if buffer contains a valid list and if it does then copies that list.  <a href="#ac0aca8620ca3d7046ae16ede95d3e7df">More...</a><br /></td></tr>
<tr class="separator:ac0aca8620ca3d7046ae16ede95d3e7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce06db8757a295d12548048b580e54b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#acce06db8757a295d12548048b580e54b">assign</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#a74ef3b5ffc610931999a6f7c53239507">begin</a>, <a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#a5e954cb6c473db357ea47abefb1fbf86">last</a>)</td></tr>
<tr class="memdesc:acce06db8757a295d12548048b580e54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies element pointed by the iterators.  <a href="#acce06db8757a295d12548048b580e54b">More...</a><br /></td></tr>
<tr class="separator:acce06db8757a295d12548048b580e54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24668a17bfbd71ea21e7cc26f0b1f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ad24668a17bfbd71ea21e7cc26f0b1f76">assign</a> (<a class="el" href="namespaceiffl.html#a06df220d9126052279a6c8c6cd3e482a">flat_forward_list_view</a>&lt; T, TT &gt; const &amp;view)</td></tr>
<tr class="memdesc:ad24668a17bfbd71ea21e7cc26f0b1f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the view.  <a href="#ad24668a17bfbd71ea21e7cc26f0b1f76">More...</a><br /></td></tr>
<tr class="separator:ad24668a17bfbd71ea21e7cc26f0b1f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149964301c14bb68cd97eec42a17f6c3"><td class="memTemplParams" colspan="2">template&lt;typename AA &gt; </td></tr>
<tr class="memitem:a149964301c14bb68cd97eec42a17f6c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a149964301c14bb68cd97eec42a17f6c3">is_compatible_allocator</a> (AA const &amp;other_allocator) const noexcept</td></tr>
<tr class="memdesc:a149964301c14bb68cd97eec42a17f6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares if allocator used by container is equivalent to the other alocator.  <a href="#a149964301c14bb68cd97eec42a17f6c3">More...</a><br /></td></tr>
<tr class="separator:a149964301c14bb68cd97eec42a17f6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75a05e0588ade0c5e7ff698a7784546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a48eff6c3870e8a47e546f9b3312b2d71">allocator_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#aa75a05e0588ade0c5e7ff698a7784546">get_allocator</a> () &amp;noexcept</td></tr>
<tr class="memdesc:aa75a05e0588ade0c5e7ff698a7784546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the allocator used by this container.  <a href="#aa75a05e0588ade0c5e7ff698a7784546">More...</a><br /></td></tr>
<tr class="separator:aa75a05e0588ade0c5e7ff698a7784546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2607b37e7acd106fa12bb9d48b25c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a48eff6c3870e8a47e546f9b3312b2d71">allocator_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#aea2607b37e7acd106fa12bb9d48b25c2">get_allocator</a> () const &amp;noexcept</td></tr>
<tr class="memdesc:aea2607b37e7acd106fa12bb9d48b25c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to the allocator used by this container.  <a href="#aea2607b37e7acd106fa12bb9d48b25c2">More...</a><br /></td></tr>
<tr class="separator:aea2607b37e7acd106fa12bb9d48b25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab52f33651aba885d4de1f6950038905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#aab52f33651aba885d4de1f6950038905">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:aab52f33651aba885d4de1f6950038905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum size.  <a href="#aab52f33651aba885d4de1f6950038905">More...</a><br /></td></tr>
<tr class="separator:aab52f33651aba885d4de1f6950038905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb49df1c50f2870da84f839e2cff008"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a9fb49df1c50f2870da84f839e2cff008">clear</a> () noexcept</td></tr>
<tr class="memdesc:a9fb49df1c50f2870da84f839e2cff008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocated buffer owned by this container.  <a href="#a9fb49df1c50f2870da84f839e2cff008">More...</a><br /></td></tr>
<tr class="separator:a9fb49df1c50f2870da84f839e2cff008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34284f1938026d3888c2fc5a1d3ac7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#af34284f1938026d3888c2fc5a1d3ac7a">tail_shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:af34284f1938026d3888c2fc5a1d3ac7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes buffer to the used capacity.  <a href="#af34284f1938026d3888c2fc5a1d3ac7a">More...</a><br /></td></tr>
<tr class="separator:af34284f1938026d3888c2fc5a1d3ac7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae342f90c0c6a7f6cf215f913691fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a6ae342f90c0c6a7f6cf215f913691fa4">resize_buffer</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list.html#ae7f71ba91588b44793b1e1726810d51b">size</a>)</td></tr>
<tr class="memdesc:a6ae342f90c0c6a7f6cf215f913691fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes buffer.  <a href="#a6ae342f90c0c6a7f6cf215f913691fa4">More...</a><br /></td></tr>
<tr class="separator:a6ae342f90c0c6a7f6cf215f913691fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21379e1564a876956ba65b185e5da02a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a21379e1564a876956ba65b185e5da02a">push_back</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> init_buffer_size, char const *init_buffer=nullptr)</td></tr>
<tr class="memdesc:a21379e1564a876956ba65b185e5da02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new elemnt to the end of the list. Element is initialized by coppying provided buffer.  <a href="#a21379e1564a876956ba65b185e5da02a">More...</a><br /></td></tr>
<tr class="separator:a21379e1564a876956ba65b185e5da02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010c5ed15b0267ab98f6bc796aa5192f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a010c5ed15b0267ab98f6bc796aa5192f">try_push_back</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> init_buffer_size, char const *init_buffer=nullptr)</td></tr>
<tr class="memdesc:a010c5ed15b0267ab98f6bc796aa5192f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new elemnt to the end of the list. Element is initialized by coppying provided buffer.  <a href="#a010c5ed15b0267ab98f6bc796aa5192f">More...</a><br /></td></tr>
<tr class="separator:a010c5ed15b0267ab98f6bc796aa5192f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01241f4c96c511e178cc5cb61b3aef5c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a01241f4c96c511e178cc5cb61b3aef5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a01241f4c96c511e178cc5cb61b3aef5c">emplace_back</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> element_size, F const &amp;fn)</td></tr>
<tr class="memdesc:a01241f4c96c511e178cc5cb61b3aef5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new element at the end of the list.  <a href="#a01241f4c96c511e178cc5cb61b3aef5c">More...</a><br /></td></tr>
<tr class="separator:a01241f4c96c511e178cc5cb61b3aef5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707541c446ced7b8078e2db52f472b57"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a707541c446ced7b8078e2db52f472b57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a707541c446ced7b8078e2db52f472b57">try_emplace_back</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> element_size, F const &amp;fn)</td></tr>
<tr class="memdesc:a707541c446ced7b8078e2db52f472b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new element at the end of the list if it fits in the existing free capacity.  <a href="#a707541c446ced7b8078e2db52f472b57">More...</a><br /></td></tr>
<tr class="separator:a707541c446ced7b8078e2db52f472b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafdb0311999b32801715649a1e436f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#aeafdb0311999b32801715649a1e436f0">pop_back</a> () noexcept</td></tr>
<tr class="memdesc:aeafdb0311999b32801715649a1e436f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes last element from the list.  <a href="#aeafdb0311999b32801715649a1e436f0">More...</a><br /></td></tr>
<tr class="separator:aeafdb0311999b32801715649a1e436f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6737b1fba55db96c0babc6bf81b09980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a6737b1fba55db96c0babc6bf81b09980">insert</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> init_buffer_size, char const *init_buffer=nullptr)</td></tr>
<tr class="memdesc:a6737b1fba55db96c0babc6bf81b09980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new element at the position described by iterator. Element is initialized by coppying provided buffer.  <a href="#a6737b1fba55db96c0babc6bf81b09980">More...</a><br /></td></tr>
<tr class="separator:a6737b1fba55db96c0babc6bf81b09980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188a147c095b190f2af5fa98cb13ab50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a188a147c095b190f2af5fa98cb13ab50">try_insert</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> init_buffer_size, char const *init_buffer=nullptr)</td></tr>
<tr class="memdesc:a188a147c095b190f2af5fa98cb13ab50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new element at the position described by iterator. Element is initialized by coppying provided buffer.  <a href="#a188a147c095b190f2af5fa98cb13ab50">More...</a><br /></td></tr>
<tr class="separator:a188a147c095b190f2af5fa98cb13ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e4fb5874008f3c4492331eb8f03e0f"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ac1e4fb5874008f3c4492331eb8f03e0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ac1e4fb5874008f3c4492331eb8f03e0f">emplace</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> new_element_size, F const &amp;fn)</td></tr>
<tr class="memdesc:ac1e4fb5874008f3c4492331eb8f03e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new element at the position described by iterator. Element is initialized with a help of the functor passed as a parameter.  <a href="#ac1e4fb5874008f3c4492331eb8f03e0f">More...</a><br /></td></tr>
<tr class="separator:ac1e4fb5874008f3c4492331eb8f03e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda23f49f747a1b83864d17717fe31cf"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aeda23f49f747a1b83864d17717fe31cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#aeda23f49f747a1b83864d17717fe31cf">try_emplace</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> new_element_size, F const &amp;fn)</td></tr>
<tr class="memdesc:aeda23f49f747a1b83864d17717fe31cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new element at the position described by iterator. Element is initialized with a help of the functor passed as a parameter.  <a href="#aeda23f49f747a1b83864d17717fe31cf">More...</a><br /></td></tr>
<tr class="separator:aeda23f49f747a1b83864d17717fe31cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d78c2f471a13687e13e4cf327793e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a8d78c2f471a13687e13e4cf327793e42">push_front</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> init_buffer_size, char const *init_buffer=nullptr)</td></tr>
<tr class="memdesc:a8d78c2f471a13687e13e4cf327793e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new element at the beginnig of the container. Element is initialized by coppying provided buffer.  <a href="#a8d78c2f471a13687e13e4cf327793e42">More...</a><br /></td></tr>
<tr class="separator:a8d78c2f471a13687e13e4cf327793e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cbc46ab002b4267d2e2b6f2d60e5f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a95cbc46ab002b4267d2e2b6f2d60e5f5">try_push_front</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> init_buffer_size, char const *init_buffer=nullptr)</td></tr>
<tr class="memdesc:a95cbc46ab002b4267d2e2b6f2d60e5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new element at the beginnig of the container. Element is initialized by coppying provided buffer.  <a href="#a95cbc46ab002b4267d2e2b6f2d60e5f5">More...</a><br /></td></tr>
<tr class="separator:a95cbc46ab002b4267d2e2b6f2d60e5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd692819b4beba06fe8f5ee81d0cd2e"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aafd692819b4beba06fe8f5ee81d0cd2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#aafd692819b4beba06fe8f5ee81d0cd2e">emplace_front</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> element_size, F const &amp;fn)</td></tr>
<tr class="memdesc:aafd692819b4beba06fe8f5ee81d0cd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new element at the beginnig of the container. Element is initialized with a help of the functor passed as a parameter.  <a href="#aafd692819b4beba06fe8f5ee81d0cd2e">More...</a><br /></td></tr>
<tr class="separator:aafd692819b4beba06fe8f5ee81d0cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225ec9bc851ca9a7fa07e2151c709dc4"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a225ec9bc851ca9a7fa07e2151c709dc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a225ec9bc851ca9a7fa07e2151c709dc4">try_emplace_front</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> element_size, F const &amp;fn)</td></tr>
<tr class="memdesc:a225ec9bc851ca9a7fa07e2151c709dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new element at the beginnig of the container. Element is initialized with a help of the functor passed as a parameter.  <a href="#a225ec9bc851ca9a7fa07e2151c709dc4">More...</a><br /></td></tr>
<tr class="separator:a225ec9bc851ca9a7fa07e2151c709dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4b04a0b2c64bd346ec9ceaaaa6faac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#acf4b04a0b2c64bd346ec9ceaaaa6faac">pop_front</a> () noexcept</td></tr>
<tr class="memdesc:acf4b04a0b2c64bd346ec9ceaaaa6faac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes first element from the container.  <a href="#acf4b04a0b2c64bd346ec9ceaaaa6faac">More...</a><br /></td></tr>
<tr class="separator:acf4b04a0b2c64bd346ec9ceaaaa6faac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3905a536980ca8882f751b497f3e958b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a3905a536980ca8882f751b497f3e958b">erase_after</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it) noexcept</td></tr>
<tr class="memdesc:a3905a536980ca8882f751b497f3e958b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases element after the element pointed by the iterator.  <a href="#a3905a536980ca8882f751b497f3e958b">More...</a><br /></td></tr>
<tr class="separator:a3905a536980ca8882f751b497f3e958b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e6528393403b075ff0ee0a554a3fab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ab7e6528393403b075ff0ee0a554a3fab">erase_after_half_closed</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;before_start, <a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#a5e954cb6c473db357ea47abefb1fbf86">last</a>) noexcept</td></tr>
<tr class="memdesc:ab7e6528393403b075ff0ee0a554a3fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases element in the range (before_start, last].  <a href="#ab7e6528393403b075ff0ee0a554a3fab">More...</a><br /></td></tr>
<tr class="separator:ab7e6528393403b075ff0ee0a554a3fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a8ed96f2f375cccf8ad0538a9682ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a39a8ed96f2f375cccf8ad0538a9682ee">erase_all_after</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it) noexcept</td></tr>
<tr class="memdesc:a39a8ed96f2f375cccf8ad0538a9682ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases element in the range (before_start, end)  <a href="#a39a8ed96f2f375cccf8ad0538a9682ee">More...</a><br /></td></tr>
<tr class="separator:a39a8ed96f2f375cccf8ad0538a9682ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40b789c93606a6bf1f00babf6c23686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ad40b789c93606a6bf1f00babf6c23686">erase_all_from</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it) noexcept</td></tr>
<tr class="memdesc:ad40b789c93606a6bf1f00babf6c23686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases element in the range [it, end)  <a href="#ad40b789c93606a6bf1f00babf6c23686">More...</a><br /></td></tr>
<tr class="separator:ad40b789c93606a6bf1f00babf6c23686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fd8a6a34a1dbc37c36ec687c35b7c9"><td class="memItemLeft" align="right" valign="top"><a id="ad0fd8a6a34a1dbc37c36ec687c35b7c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ad0fd8a6a34a1dbc37c36ec687c35b7c9">erase_all</a> () noexcept</td></tr>
<tr class="memdesc:ad0fd8a6a34a1dbc37c36ec687c35b7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements in the buffer without deallocating buffer. <br /></td></tr>
<tr class="separator:ad0fd8a6a34a1dbc37c36ec687c35b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31bc30ee9096da0058954b95417ab8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#af31bc30ee9096da0058954b95417ab8f">erase</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it) noexcept</td></tr>
<tr class="memdesc:af31bc30ee9096da0058954b95417ab8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases element pointed by iterator.  <a href="#af31bc30ee9096da0058954b95417ab8f">More...</a><br /></td></tr>
<tr class="separator:af31bc30ee9096da0058954b95417ab8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9be92004a017c12fb7ea80ae87618b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#aaa9be92004a017c12fb7ea80ae87618b">erase</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;start, <a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#ad271eef884526f0b76592d3d7dccaf93">end</a>) noexcept</td></tr>
<tr class="memdesc:aaa9be92004a017c12fb7ea80ae87618b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases element in the range [start, end).  <a href="#aaa9be92004a017c12fb7ea80ae87618b">More...</a><br /></td></tr>
<tr class="separator:aaa9be92004a017c12fb7ea80ae87618b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac348412275edd1cff2d1b1feddd824a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ac348412275edd1cff2d1b1feddd824a7">swap</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> &amp;other) noexcept(allocator_type_traits::propagate_on_container_swap::value||allocator_type_traits::propagate_on_container_move_assignment::value)</td></tr>
<tr class="memdesc:ac348412275edd1cff2d1b1feddd824a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps content of this container and the other container.  <a href="#ac348412275edd1cff2d1b1feddd824a7">More...</a><br /></td></tr>
<tr class="separator:ac348412275edd1cff2d1b1feddd824a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d5234f8daf81076417cbb6a15278ad"><td class="memTemplParams" colspan="2">template&lt;typename LESS_F &gt; </td></tr>
<tr class="memitem:ac5d5234f8daf81076417cbb6a15278ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ac5d5234f8daf81076417cbb6a15278ad">sort</a> (LESS_F const &amp;fn)</td></tr>
<tr class="memdesc:ac5d5234f8daf81076417cbb6a15278ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts elements of container using comparator passed as a parameter.  <a href="#ac5d5234f8daf81076417cbb6a15278ad">More...</a><br /></td></tr>
<tr class="separator:ac5d5234f8daf81076417cbb6a15278ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e6fcf8f539248daeba7dce78f7d039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a76e6fcf8f539248daeba7dce78f7d039">reverse</a> ()</td></tr>
<tr class="memdesc:a76e6fcf8f539248daeba7dce78f7d039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses elements of the list.  <a href="#a76e6fcf8f539248daeba7dce78f7d039">More...</a><br /></td></tr>
<tr class="separator:a76e6fcf8f539248daeba7dce78f7d039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0230f3b404fcc3d8379d88e3a145ec9d"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a0230f3b404fcc3d8379d88e3a145ec9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a0230f3b404fcc3d8379d88e3a145ec9d">merge</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> &amp;other, F const &amp;fn)</td></tr>
<tr class="memdesc:a0230f3b404fcc3d8379d88e3a145ec9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two linked list ordering lists using comparison functor.  <a href="#a0230f3b404fcc3d8379d88e3a145ec9d">More...</a><br /></td></tr>
<tr class="separator:a0230f3b404fcc3d8379d88e3a145ec9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af537a98c54789b2d8efef41a0ab315b1"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:af537a98c54789b2d8efef41a0ab315b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#af537a98c54789b2d8efef41a0ab315b1">unique</a> (F const &amp;fn) noexcept</td></tr>
<tr class="memdesc:af537a98c54789b2d8efef41a0ab315b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there are multiple equivalent elements next to each other then first one is kept, and all other are deleted.  <a href="#af537a98c54789b2d8efef41a0ab315b1">More...</a><br /></td></tr>
<tr class="separator:af537a98c54789b2d8efef41a0ab315b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8330232495a549bc7c9dd9b6971d7a"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a9f8330232495a549bc7c9dd9b6971d7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a9f8330232495a549bc7c9dd9b6971d7a">remove_if</a> (F const &amp;fn) noexcept</td></tr>
<tr class="memdesc:a9f8330232495a549bc7c9dd9b6971d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements that satisfy predicate.  <a href="#a9f8330232495a549bc7c9dd9b6971d7a">More...</a><br /></td></tr>
<tr class="separator:a9f8330232495a549bc7c9dd9b6971d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353f86d2ec2dfc9e57c7f22763ca1e2d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a353f86d2ec2dfc9e57c7f22763ca1e2d">front</a> () noexcept</td></tr>
<tr class="separator:a353f86d2ec2dfc9e57c7f22763ca1e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72832120381fa785d2b15f7547bb071"><td class="memItemLeft" align="right" valign="top">T const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#af72832120381fa785d2b15f7547bb071">front</a> () const noexcept</td></tr>
<tr class="separator:af72832120381fa785d2b15f7547bb071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd0fa125da47c89fbbb0edb9afaf44c"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a5fd0fa125da47c89fbbb0edb9afaf44c">back</a> () noexcept</td></tr>
<tr class="separator:a5fd0fa125da47c89fbbb0edb9afaf44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21942325ec811aa9ba55ad9408ee42d"><td class="memItemLeft" align="right" valign="top">T const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ac21942325ec811aa9ba55ad9408ee42d">back</a> () const noexcept</td></tr>
<tr class="separator:ac21942325ec811aa9ba55ad9408ee42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ef3b5ffc610931999a6f7c53239507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a74ef3b5ffc610931999a6f7c53239507">begin</a> () noexcept</td></tr>
<tr class="separator:a74ef3b5ffc610931999a6f7c53239507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53145c393f192996705e52c93019cf6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a53145c393f192996705e52c93019cf6c">begin</a> () const noexcept</td></tr>
<tr class="separator:a53145c393f192996705e52c93019cf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e954cb6c473db357ea47abefb1fbf86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a5e954cb6c473db357ea47abefb1fbf86">last</a> () noexcept</td></tr>
<tr class="separator:a5e954cb6c473db357ea47abefb1fbf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9532a6ff5f31fcdf2fb96e0bf8477532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a9532a6ff5f31fcdf2fb96e0bf8477532">last</a> () const noexcept</td></tr>
<tr class="separator:a9532a6ff5f31fcdf2fb96e0bf8477532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad271eef884526f0b76592d3d7dccaf93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ad271eef884526f0b76592d3d7dccaf93">end</a> () noexcept</td></tr>
<tr class="separator:ad271eef884526f0b76592d3d7dccaf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8984c98f4e9510e413d184d5fcce7b27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a8984c98f4e9510e413d184d5fcce7b27">end</a> () const noexcept</td></tr>
<tr class="separator:a8984c98f4e9510e413d184d5fcce7b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d24ad7dd2c2df8e0ffc03db4ade87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#af5d24ad7dd2c2df8e0ffc03db4ade87f">cbegin</a> () const noexcept</td></tr>
<tr class="separator:af5d24ad7dd2c2df8e0ffc03db4ade87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a7819ab8607448626d5ef4f69c93c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a88a7819ab8607448626d5ef4f69c93c9">clast</a> () const noexcept</td></tr>
<tr class="separator:a88a7819ab8607448626d5ef4f69c93c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31003f76b5fc1a1a1f88096c4aeb24cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a31003f76b5fc1a1a1f88096c4aeb24cb">cend</a> () const noexcept</td></tr>
<tr class="separator:a31003f76b5fc1a1a1f88096c4aeb24cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af159146257d0e16b713704907e552b7b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#af159146257d0e16b713704907e552b7b">data</a> () noexcept</td></tr>
<tr class="separator:af159146257d0e16b713704907e552b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1092cb07ad493b9012e1095d67cee56c"><td class="memItemLeft" align="right" valign="top">char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a1092cb07ad493b9012e1095d67cee56c">data</a> () const noexcept</td></tr>
<tr class="separator:a1092cb07ad493b9012e1095d67cee56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab813a8b15fcf7b3d70888d9bc9d91e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a8ab813a8b15fcf7b3d70888d9bc9d91e">revalidate_data</a> () noexcept</td></tr>
<tr class="memdesc:a8ab813a8b15fcf7b3d70888d9bc9d91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates that buffer contains a valid list.  <a href="#a8ab813a8b15fcf7b3d70888d9bc9d91e">More...</a><br /></td></tr>
<tr class="separator:a8ab813a8b15fcf7b3d70888d9bc9d91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d1e1176e0e05fcbfd27bccf958392c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#aa7d1e1176e0e05fcbfd27bccf958392c">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:aa7d1e1176e0e05fcbfd27bccf958392c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes unused padding of each element and at the tail.  <a href="#aa7d1e1176e0e05fcbfd27bccf958392c">More...</a><br /></td></tr>
<tr class="separator:aa7d1e1176e0e05fcbfd27bccf958392c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff7a544b9466e72523dbee770150ead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#adff7a544b9466e72523dbee770150ead">shrink_to_fit</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;first, <a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#ad271eef884526f0b76592d3d7dccaf93">end</a>)</td></tr>
<tr class="memdesc:adff7a544b9466e72523dbee770150ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes unused padding of each element in the range [first, end).  <a href="#adff7a544b9466e72523dbee770150ead">More...</a><br /></td></tr>
<tr class="separator:adff7a544b9466e72523dbee770150ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe0f15d22d91fcb9ae78e00a8f4af89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a0fe0f15d22d91fcb9ae78e00a8f4af89">shrink_to_fit</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it)</td></tr>
<tr class="memdesc:a0fe0f15d22d91fcb9ae78e00a8f4af89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes unused padding of an element.  <a href="#a0fe0f15d22d91fcb9ae78e00a8f4af89">More...</a><br /></td></tr>
<tr class="separator:a0fe0f15d22d91fcb9ae78e00a8f4af89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f78cb6440ac9cafd81482b213df930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ac5f78cb6440ac9cafd81482b213df930">element_add_size</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> size_to_add)</td></tr>
<tr class="memdesc:ac5f78cb6440ac9cafd81482b213df930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds unused capacity to the element.  <a href="#ac5f78cb6440ac9cafd81482b213df930">More...</a><br /></td></tr>
<tr class="separator:ac5f78cb6440ac9cafd81482b213df930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0647a468dde5ed38ae7ba4d90f7af7d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a0647a468dde5ed38ae7ba4d90f7af7d3">try_element_add_size</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> size_to_add)</td></tr>
<tr class="memdesc:a0647a468dde5ed38ae7ba4d90f7af7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds unused capacity to the element.  <a href="#a0647a468dde5ed38ae7ba4d90f7af7d3">More...</a><br /></td></tr>
<tr class="separator:a0647a468dde5ed38ae7ba4d90f7af7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d10bb547c4bdac9b9d32c83b6b7a343"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a7d10bb547c4bdac9b9d32c83b6b7a343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a7d10bb547c4bdac9b9d32c83b6b7a343">element_resize</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> new_size, F const &amp;fn)</td></tr>
<tr class="memdesc:a7d10bb547c4bdac9b9d32c83b6b7a343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes element.  <a href="#a7d10bb547c4bdac9b9d32c83b6b7a343">More...</a><br /></td></tr>
<tr class="separator:a7d10bb547c4bdac9b9d32c83b6b7a343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4416213cbf593143f177a6c6aec1e33"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ad4416213cbf593143f177a6c6aec1e33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ad4416213cbf593143f177a6c6aec1e33">try_element_resize</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> new_size, F const &amp;fn)</td></tr>
<tr class="memdesc:ad4416213cbf593143f177a6c6aec1e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes element.  <a href="#ad4416213cbf593143f177a6c6aec1e33">More...</a><br /></td></tr>
<tr class="separator:ad4416213cbf593143f177a6c6aec1e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784af2858013e63f73f5c4f624663f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a784af2858013e63f73f5c4f624663f39">required_size</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;it) const noexcept</td></tr>
<tr class="memdesc:a784af2858013e63f73f5c4f624663f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns capacity used by the element's data.  <a href="#a784af2858013e63f73f5c4f624663f39">More...</a><br /></td></tr>
<tr class="separator:a784af2858013e63f73f5c4f624663f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73423cf1724da4c572a6b1220cc04e84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a73423cf1724da4c572a6b1220cc04e84">used_size</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;it) const noexcept</td></tr>
<tr class="separator:a73423cf1724da4c572a6b1220cc04e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c8b5f67a43a504332a0e8702df5b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a47445e33823a03584f99b950839ecd9a">range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a60c8b5f67a43a504332a0e8702df5b5c">range</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;it) const noexcept</td></tr>
<tr class="memdesc:a60c8b5f67a43a504332a0e8702df5b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the buffer occupied by an element.  <a href="#a60c8b5f67a43a504332a0e8702df5b5c">More...</a><br /></td></tr>
<tr class="separator:a60c8b5f67a43a504332a0e8702df5b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1ca30c6939c748a190e32dce485347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a47445e33823a03584f99b950839ecd9a">range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a6c1ca30c6939c748a190e32dce485347">closed_range</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#a74ef3b5ffc610931999a6f7c53239507">begin</a>, <a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#a5e954cb6c473db357ea47abefb1fbf86">last</a>) const noexcept</td></tr>
<tr class="memdesc:a6c1ca30c6939c748a190e32dce485347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the buffer occupied by elements in the range [begin, last].  <a href="#a6c1ca30c6939c748a190e32dce485347">More...</a><br /></td></tr>
<tr class="separator:a6c1ca30c6939c748a190e32dce485347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2df245169b6a9b2264ede5783a4397c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a47445e33823a03584f99b950839ecd9a">range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ab2df245169b6a9b2264ede5783a4397c">half_open_range</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#a74ef3b5ffc610931999a6f7c53239507">begin</a>, <a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list.html#ad271eef884526f0b76592d3d7dccaf93">end</a>) const noexcept</td></tr>
<tr class="memdesc:ab2df245169b6a9b2264ede5783a4397c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the buffer occupied by elements in the range [begin, end).  <a href="#ab2df245169b6a9b2264ede5783a4397c">More...</a><br /></td></tr>
<tr class="separator:ab2df245169b6a9b2264ede5783a4397c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0612817dca397e3a3bc2dc518c00d694"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a0612817dca397e3a3bc2dc518c00d694">contains</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> position) const noexcept</td></tr>
<tr class="memdesc:a0612817dca397e3a3bc2dc518c00d694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given offset in the buffer falls into a buffer used by the element.  <a href="#a0612817dca397e3a3bc2dc518c00d694">More...</a><br /></td></tr>
<tr class="separator:a0612817dca397e3a3bc2dc518c00d694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a682c6cd8038564218d3989e50c667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ac9a682c6cd8038564218d3989e50c667">find_element_before</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> position) noexcept</td></tr>
<tr class="memdesc:ac9a682c6cd8038564218d3989e50c667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element before the element that containes given position.  <a href="#ac9a682c6cd8038564218d3989e50c667">More...</a><br /></td></tr>
<tr class="separator:ac9a682c6cd8038564218d3989e50c667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55152d5b9f54160debe43bff97040733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a55152d5b9f54160debe43bff97040733">find_element_before</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> position) const noexcept</td></tr>
<tr class="memdesc:a55152d5b9f54160debe43bff97040733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element before the element that containes given position.  <a href="#a55152d5b9f54160debe43bff97040733">More...</a><br /></td></tr>
<tr class="separator:a55152d5b9f54160debe43bff97040733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ce10a9b75e74549c0cf940d691a1da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a27ce10a9b75e74549c0cf940d691a1da">find_element_at</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> position) noexcept</td></tr>
<tr class="memdesc:a27ce10a9b75e74549c0cf940d691a1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element that containes given position.  <a href="#a27ce10a9b75e74549c0cf940d691a1da">More...</a><br /></td></tr>
<tr class="separator:a27ce10a9b75e74549c0cf940d691a1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e44339610a22f4bf4fe3f920b767d45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a6e44339610a22f4bf4fe3f920b767d45">find_element_at</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> position) const noexcept</td></tr>
<tr class="memdesc:a6e44339610a22f4bf4fe3f920b767d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element that containes given position.  <a href="#a6e44339610a22f4bf4fe3f920b767d45">More...</a><br /></td></tr>
<tr class="separator:a6e44339610a22f4bf4fe3f920b767d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40fd8623c12fc3b9330e90ab482a9d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ad40fd8623c12fc3b9330e90ab482a9d2">find_element_after</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> position) noexcept</td></tr>
<tr class="memdesc:ad40fd8623c12fc3b9330e90ab482a9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element after the element that containes given position.  <a href="#ad40fd8623c12fc3b9330e90ab482a9d2">More...</a><br /></td></tr>
<tr class="separator:ad40fd8623c12fc3b9330e90ab482a9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499e064fc406db09b51c3070b5b496b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a499e064fc406db09b51c3070b5b496b2">find_element_after</a> (<a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> position) const noexcept</td></tr>
<tr class="memdesc:a499e064fc406db09b51c3070b5b496b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element after the element that containes given position.  <a href="#a499e064fc406db09b51c3070b5b496b2">More...</a><br /></td></tr>
<tr class="separator:a499e064fc406db09b51c3070b5b496b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f71ba91588b44793b1e1726810d51b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ae7f71ba91588b44793b1e1726810d51b">size</a> () const noexcept</td></tr>
<tr class="memdesc:ae7f71ba91588b44793b1e1726810d51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in the container.  <a href="#ae7f71ba91588b44793b1e1726810d51b">More...</a><br /></td></tr>
<tr class="separator:ae7f71ba91588b44793b1e1726810d51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54740bb53e624dffcab82da64b81f104"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a54740bb53e624dffcab82da64b81f104">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a54740bb53e624dffcab82da64b81f104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if container contains no elements.  <a href="#a54740bb53e624dffcab82da64b81f104">More...</a><br /></td></tr>
<tr class="separator:a54740bb53e624dffcab82da64b81f104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae324c4d88d822fbacf6d7ead3c07242d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#ae324c4d88d822fbacf6d7ead3c07242d">used_capacity</a> () const noexcept</td></tr>
<tr class="separator:ae324c4d88d822fbacf6d7ead3c07242d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a18b5f5c7bf54cb87faccb97a8b4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a09a18b5f5c7bf54cb87faccb97a8b4c7">total_capacity</a> () const noexcept</td></tr>
<tr class="separator:a09a18b5f5c7bf54cb87faccb97a8b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e02c4df75b8e8b9fb9a57f1943c207b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a1e02c4df75b8e8b9fb9a57f1943c207b">remaining_capacity</a> () const noexcept</td></tr>
<tr class="separator:a1e02c4df75b8e8b9fb9a57f1943c207b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8d7e83cb1edc97e4a1d4afc2e7ea7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a9a8d7e83cb1edc97e4a1d4afc2e7ea7b">fill_padding</a> (int fill_byte=0, bool zero_unused_capacity=true) noexcept</td></tr>
<tr class="memdesc:a9a8d7e83cb1edc97e4a1d4afc2e7ea7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills parts of the buffer not used by element data with fill_byte.  <a href="#a9a8d7e83cb1edc97e4a1d4afc2e7ea7b">More...</a><br /></td></tr>
<tr class="separator:a9a8d7e83cb1edc97e4a1d4afc2e7ea7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a73cabcecae9e7a99ad701fb4188e8e73"><td class="memItemLeft" align="right" valign="top"><a id="a73cabcecae9e7a99ad701fb4188e8e73"></a>
static <a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a73cabcecae9e7a99ad701fb4188e8e73">npos</a> = iffl::npos</td></tr>
<tr class="memdesc:a73cabcecae9e7a99ad701fb4188e8e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that represents and invalid or non-existent position. <br /></td></tr>
<tr class="separator:a73cabcecae9e7a99ad701fb4188e8e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a994773d1cdb85755ff5ff9937abc1a48"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a994773d1cdb85755ff5ff9937abc1a48"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html#a994773d1cdb85755ff5ff9937abc1a48">flat_forward_list_ref</a></td></tr>
<tr class="separator:a994773d1cdb85755ff5ff9937abc1a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt;<br />
class iffl::flat_forward_list&lt; T, TT, A &gt;</h3>

<p>Intrusive flat forward list container. </p>
<p>Forward declaration of intrusive flat forward list container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T Container is inherited from allocator to utilize Empty Base Class Optimization (EBCO).</p>
<p>Iterator invalidation notes: Begin iterator might get invalidated on any operation that causes buffer reallocation or erases last element of container Any other iterator, including an end iterator can get invalidated on any operation that causes buffer reallocation or adds, removes or resizes elements of container. Methods that take iterator as an input, and can invalidate it return new valid iterator as an output. Caller must refresh end iterator by explicitely calling [c]<a class="el" href="classiffl_1_1flat__forward__list.html#ad271eef884526f0b76592d3d7dccaf93">end()</a>.</p>
<p>Debugging notes: Defining FFL_DBG_CHECK_ITERATOR_VALID will enable validation of that iterators passed in input parameters are valid and are pointing to an existing element. Cost of this validation is O(element count). Defining FFL_DBG_CHECK_DATA_VALID will enable validation of container after every method that modifies container data.</p>
<p>Iterator names notes: begin or first - first element in a half-open [first, end) or closed [first, last] range. last - referes to the last element in half-closed (before_begin, last] or closed [first, last] range. end - referes to an element pass the last element. It is used with half open [begin, end) or open (before_begin, end) range. before_beging or before_first - referes to an element preceeding begin or first element. Is used in halfope (before_begin, last] or open (before_begin, end) range.</p>
<p>Security notes: One of the common directions for attack is to leak to the attacher some uninitialized data that might contain addresses that might guide attacker how to bypass technics like Address Space Layout Randomization (ASLR). To prevent that consider using fill_padding that will fill any unused space with given pattern making sure we are not leaking any unintended information in the element padding and in the buffer's unused tail.</p>
<p>Interop with C API notes: When passing pointer to container's buffer to an API that can modify it it will invalidate container invariants. For instance pointer to the last element will no longer be valid. User must call revalidate_data after this call to make sure invariants are fixed. The cal revalidate_data will rescan buffer for valid list as if it is a non-trusted buffer.</p>
<p>Allocator notes: COntainer supports adopting (attaching to) buffer that was allocated by someone else. This helps to minimize number of copies when interoping with C API. It is responsibility of user to make sure that container uses allocator that is compatible with how adopted buffer was allocated. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3e8f1baf4a08c0cd00c7108bc3442f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8f1baf4a08c0cd00c7108bc3442f22">&#9670;&nbsp;</a></span>buffer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html#a3e8f1baf4a08c0cd00c7108bc3442f22">buffer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointers that describe buffer. </p>
<p>Depending if T is const buffer uses char * or char const * </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a749f152e4fb3d8781277060f19609048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749f152e4fb3d8781277060f19609048">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Moves allocator and content of other container to this container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- container we are moving from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0add72d0b2150302c9c66a16ba70bc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0add72d0b2150302c9c66a16ba70bc52">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. Copies allocator if supprted and copies content of other container to this container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- container we are copying from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0c6c251f25b12c0287092d215f8574c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c6c251f25b12c0287092d215f8574c">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename AA  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiffl_1_1attach__buffer.html">attach_buffer</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>other_buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AA &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>AA{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that takes ownership of a buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>- type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_buff</td><td>- pointer to the start of the buffer that contains list. </td></tr>
    <tr><td class="paramname">a</td><td>- allocator that should be used by this container.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. The first parameter is an empty vocabulary type to help with overload resolution and code redability. </p><div class="fragment"><div class="line"><a class="code" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list&lt;my_type&gt;</a> new_owner{<a class="code" href="structiffl_1_1attach__buffer.html">iffl::attach_buffer</a>{}, <a class="code" href="classiffl_1_1flat__forward__list.html#a74ef3b5ffc610931999a6f7c53239507">begin</a>, <a class="code" href="classiffl_1_1flat__forward__list.html#a5e954cb6c473db357ea47abefb1fbf86">last</a>, <a class="code" href="classiffl_1_1flat__forward__list.html#ad271eef884526f0b76592d3d7dccaf93">end</a>};</div></div><!-- fragment --><p> After this call container is responsible for deallocating the buffer. It is responsibility of the caller to make sure that buffer was allocated using method compatible with allocator used by this container. </p>

</div>
</div>
<a id="afccbf673a48dc329bc645f1abc8a5823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccbf673a48dc329bc645f1abc8a5823">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename AA  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>other_buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AA &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>AA{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that copies list from a buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AA</td><td>- type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_buff</td><td>- pointer to the start of the buffer that contains list. </td></tr>
    <tr><td class="paramname">a</td><td>- allocator that should be used by this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. </p>

</div>
</div>
<a id="a7e8a3c637cb02c0d00bf0b4d991b3ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8a3c637cb02c0d00bf0b4d991b3ab6">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename AA  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiffl_1_1attach__buffer.html">attach_buffer</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AA &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>AA{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that takes ownership of a buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AA</td><td>- type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_begin</td><td>- pointer to the start of the buffer that contains list. </td></tr>
    <tr><td class="paramname">buffer_end</td><td>- pointer to the address right after last byte in the buffer. </td></tr>
    <tr><td class="paramname">last_element</td><td>- pointers to the last element of the list in the buffer. If buffer does not contain any elements then this parameter must be nullptr. </td></tr>
    <tr><td class="paramname">a</td><td>- allocator that should be used by this container.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. The first parameter is an empty vocabulary type to help with overload resolution and code redability. </p><div class="fragment"><div class="line"><a class="code" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list&lt;my_type&gt;</a> new_owner{<a class="code" href="structiffl_1_1attach__buffer.html">iffl::attach_buffer</a>{}, <a class="code" href="classiffl_1_1flat__forward__list.html#a74ef3b5ffc610931999a6f7c53239507">begin</a>, <a class="code" href="classiffl_1_1flat__forward__list.html#a5e954cb6c473db357ea47abefb1fbf86">last</a>, <a class="code" href="classiffl_1_1flat__forward__list.html#ad271eef884526f0b76592d3d7dccaf93">end</a>};</div></div><!-- fragment --><p> After this call container is responsible for deallocating the buffer. It is responsibility of the caller to make sure that buffer was allocated using method compatible with allocator used by this container. </p>

</div>
</div>
<a id="ae91f5a5db96c9ed92dff41ca79c0dc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91f5a5db96c9ed92dff41ca79c0dc35">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename AA  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>last_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AA &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>AA{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that copies list from a buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AA</td><td>- type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_begin</td><td>- pointer to the start of the buffer that contains list. </td></tr>
    <tr><td class="paramname">buffer_end</td><td>- pointer to the address right after last byte in the buffer. </td></tr>
    <tr><td class="paramname">last_element</td><td>- pointers to the last element of the list in the buffer. If buffer does not contain any elements then this parameter must be nullptr. </td></tr>
    <tr><td class="paramname">a</td><td>- allocator that should be used by this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. </p>

</div>
</div>
<a id="a2a50df8a0aeff99375371fa4679fa85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a50df8a0aeff99375371fa4679fa85a">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename AA  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiffl_1_1attach__buffer.html">attach_buffer</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AA &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>AA{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that takes ownership of a buffer and attempts to find last element of the list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AA</td><td>- type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to the start of the buffer that might contains list. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>- buffer size. </td></tr>
    <tr><td class="paramname">a</td><td>- allocator that should be used by this container.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor adopts buffer, and searches for the last valid element in the buffer. If buffer validation fails then container will treat it as if it has no elements. The first parameter is an empty vocabulary type to help with overload resolution and code redability. </p><div class="fragment"><div class="line"><a class="code" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list&lt;my_type&gt;</a> new_owner{<a class="code" href="structiffl_1_1attach__buffer.html">iffl::attach_buffer</a>{}, <a class="code" href="classiffl_1_1flat__forward__list.html#a74ef3b5ffc610931999a6f7c53239507">begin</a>, <a class="code" href="classiffl_1_1flat__forward__list.html#ae7f71ba91588b44793b1e1726810d51b">size</a>};</div></div><!-- fragment --><p> After this call container is responsible for deallocating the buffer. It is responsibility of the caller to make sure that buffer was allocated using method compatible with allocator used by this container. </p>

</div>
</div>
<a id="abf497e76a8d8462697d1897dfcf1b63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf497e76a8d8462697d1897dfcf1b63b">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename AA  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AA &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>AA{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that checks if buffer contains a valid list and if it does then copies that list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AA</td><td>- type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to the start of the buffer that might contains list. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>- bufer size. </td></tr>
    <tr><td class="paramname">a</td><td>- allocator that should be used by this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor searches for the last valid element in the buffer, and is buffer is valid then it copies elements to the new buffer. </p>

</div>
</div>
<a id="a59af9a85096de0323b690c08004fe015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59af9a85096de0323b690c08004fe015">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename AA  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AA &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>AA{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies element pointed by the iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- iterator for the buffer begin. </td></tr>
    <tr><td class="paramname">last</td><td>- last element that should be included in the view. </td></tr>
    <tr><td class="paramname">a</td><td>- allocator that should be used by this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac60ccc1f4b9767dbda08355a66484afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60ccc1f4b9767dbda08355a66484afe">&#9670;&nbsp;</a></span>flat_forward_list() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename AA  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a06df220d9126052279a6c8c6cd3e482a">flat_forward_list_view</a>&lt; T, TT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AA &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>AA{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies element from the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>- view over a flat forward list buffer. </td></tr>
    <tr><td class="paramname">a</td><td>- allocator that should be used by this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e8076875ac67c0dd3e95c2915fee0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8076875ac67c0dd3e95c2915fee0c2">&#9670;&nbsp;</a></span>~flat_forward_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::~<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Deallocates buffer owned by container. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5e1b7f1ce1d9a6e473d32e7722df3546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1b7f1ce1d9a6e473d32e7722df3546">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>other_buff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies list from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_buff</td><td>- describes the other buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails</td></tr>
  </table>
  </dd>
</dl>
<p>This method does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. </p>

</div>
</div>
<a id="acbe9875e1f49a8c397c9e54baeab1b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe9875e1f49a8c397c9e54baeab1b19">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>last_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies list from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_begin</td><td>- pointer to the start of the buffer that contains list. </td></tr>
    <tr><td class="paramname">buffer_end</td><td>- pointer to the address right after last byte in the buffer. </td></tr>
    <tr><td class="paramname">last_element</td><td>- pointers to the last element of the list in the buffer. If buffer does not contain any elements then this parameter must be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails</td></tr>
  </table>
  </dd>
</dl>
<p>This method does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. </p>

</div>
</div>
<a id="a34fd209537cfdc6e3815b7fe73339395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fd209537cfdc6e3815b7fe73339395">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if buffer contains a valid list and if it does then copies that list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_begin</td><td>- pointer to the start of the buffer that might contains list. </td></tr>
    <tr><td class="paramname">buffer_end</td><td>- pointer to the buffer end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails</td></tr>
  </table>
  </dd>
</dl>
<p>This method searches for the last valid element in the buffer, and is buffer is valid then it copies elements to the new buffer. </p>

</div>
</div>
<a id="ac0aca8620ca3d7046ae16ede95d3e7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0aca8620ca3d7046ae16ede95d3e7df">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if buffer contains a valid list and if it does then copies that list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to the start of the buffer that might contains list. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>- bufer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if buffer allocation fails</td></tr>
  </table>
  </dd>
</dl>
<p>This method searches for the last valid element in the buffer, and is buffer is valid then it copies elements to the new buffer. </p>

</div>
</div>
<a id="acce06db8757a295d12548048b580e54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce06db8757a295d12548048b580e54b">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies element pointed by the iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- iterator for the buffer begin. </td></tr>
    <tr><td class="paramname">last</td><td>- last element that should be included in the view. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad24668a17bfbd71ea21e7cc26f0b1f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24668a17bfbd71ea21e7cc26f0b1f76">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a06df220d9126052279a6c8c6cd3e482a">flat_forward_list_view</a>&lt; T, TT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements from the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>- view over the flat forward list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e28a8e192f0ebd7fd2024bb76690fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e28a8e192f0ebd7fd2024bb76690fc9">&#9670;&nbsp;</a></span>attach() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>other_buff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_buff</td><td>- describes the buffer we are attaching.</td></tr>
  </table>
  </dd>
</dl>
<p>This method first clears existing content of the container. It does not validate if buffer contains a valid flat forward list. It assumes that caller validated buffer before using this constructor. After this call container is responsible for deallocating the buffer. It is responsibility of the caller to make sure that buffer was allocated using method compatible with allocator used by this container. </p>

</div>
</div>
<a id="a9902201e3d45a15b96b0e5582137e11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9902201e3d45a15b96b0e5582137e11e">&#9670;&nbsp;</a></span>attach() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::attach </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>last_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_begin</td><td>- pointer to the start of the buffer that contains list. </td></tr>
    <tr><td class="paramname">buffer_end</td><td>- pointer to the address right after last byte in the buffer. </td></tr>
    <tr><td class="paramname">last_element</td><td>- pointers to the last element of the list in the buffer. If buffer does not contain any elements then this parameter must be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<p>This method first clears existing content of the container. It does not validate if buffer contains a valid flat forward list. It assumes that caller validated buffer before using this constructor. After this call container is responsible for deallocating the buffer. It is responsibility of the caller to make sure that buffer was allocated using method compatible with allocator used by this container. </p>

</div>
</div>
<a id="a7257d26d9b667a333b2ccb76e46e33b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7257d26d9b667a333b2ccb76e46e33b8">&#9670;&nbsp;</a></span>attach() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::attach </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of a buffer and attempts to find last element of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to the start of the buffer that might contains list. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>- buffer size.</td></tr>
  </table>
  </dd>
</dl>
<p>This method adopts buffer, and searches for the last valid element in the buffer. If buffer validation fails then container will treat it as if it has no elements. After this call container is responsible for deallocating the buffer. It is responsibility of the caller to make sure that buffer was allocated using method compatible with allocator used by this container. </p>

</div>
</div>
<a id="a5fd0fa125da47c89fbbb0edb9afaf44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd0fa125da47c89fbbb0edb9afaf44c">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the last element in the container.</dd></dl>
<p>Calling this method on a empty container will trigger fail-fast </p>

</div>
</div>
<a id="ac21942325ec811aa9ba55ad9408ee42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21942325ec811aa9ba55ad9408ee42d">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference to the last element in the container.</dd></dl>
<p>Calling this method on a empty container will trigger fail-fast </p>

</div>
</div>
<a id="a74ef3b5ffc610931999a6f7c53239507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ef3b5ffc610931999a6f7c53239507">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator pointing to the first element of container.</dd></dl>
<p>Calling on an empty container returns end iterator </p>

</div>
</div>
<a id="a53145c393f192996705e52c93019cf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53145c393f192996705e52c93019cf6c">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const iterator pointing to the first element of container.</dd></dl>
<p>Calling on an empty container returns const end iterator </p>

</div>
</div>
<a id="af5d24ad7dd2c2df8e0ffc03db4ade87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d24ad7dd2c2df8e0ffc03db4ade87f">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const iterator pointing to the first element of container.</dd></dl>
<p>Calling on an empty container returns const end iterator </p>

</div>
</div>
<a id="a31003f76b5fc1a1a1f88096c4aeb24cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31003f76b5fc1a1a1f88096c4aeb24cb">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an end const_iterator.</dd></dl>
<p>For types that support get_next_offset offset or when container is empty, the end iterator is const_iterator{}. For types that do not support get_next_offset an end iterator is pointing pass the last element of container </p>

</div>
</div>
<a id="a88a7819ab8607448626d5ef4f69c93c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a7819ab8607448626d5ef4f69c93c9">&#9670;&nbsp;</a></span>clast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::clast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const iterator pointing to the last element of container.</dd></dl>
<p>Calling on an empty container returns end iterator </p>

</div>
</div>
<a id="a9fb49df1c50f2870da84f839e2cff008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb49df1c50f2870da84f839e2cff008">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocated buffer owned by this container. </p>
<p>After this call container is empty </p>

</div>
</div>
<a id="a6c1ca30c6939c748a190e32dce485347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1ca30c6939c748a190e32dce485347">&#9670;&nbsp;</a></span>closed_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a47445e33823a03584f99b950839ecd9a">range_t</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::closed_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Information about the buffer occupied by elements in the range [begin, last]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- iterator pointing to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>- iterator pointing to the last element in the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For any case, except when last element of range is last element of the collection, it returns:<ul>
<li>start of the first element.</li>
<li>offset of the last element data end.</li>
<li>offset of the last element buffer end. If range last is last element of collection then data end and buffer end point to the same position.</li>
</ul>
</dd></dl>
<p>All offsets values are relative to the buffer owned by the container. </p>

</div>
</div>
<a id="a0612817dca397e3a3bc2dc518c00d694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0612817dca397e3a3bc2dc518c00d694">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if given offset in the buffer falls into a buffer used by the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to an element </td></tr>
    <tr><td class="paramname">position</td><td>- offset in the container's buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if position is in the element's buffer. and false otherwise. Element's buffer is retrieved using range(it). When iterator referes to container end or when position is npos the result will be false. </dd></dl>

</div>
</div>
<a id="af159146257d0e16b713704907e552b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af159146257d0e16b713704907e552b7b">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to the begging of the buffer or nullptr container has if no allocated buffer. </dd></dl>

</div>
</div>
<a id="a1092cb07ad493b9012e1095d67cee56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1092cb07ad493b9012e1095d67cee56c">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const* <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Const pointer to the begging of the buffer or nullptr container has if no allocated buffer. </dd></dl>

</div>
</div>
<a id="a98aa8899ef08ac7e2de76f8666d71774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98aa8899ef08ac7e2de76f8666d71774">&#9670;&nbsp;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiffl.html#a78536459b06204bafd2ddbfb7b778df9">buffer_ref</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container releases ownership of the buffer. </p>
<p>After the call completes, container is empty. </p><dl class="section return"><dt>Returns</dt><dd>Returns buffer information to the caller. Caller is responsible for deallocating returned buffer. </dd></dl>

</div>
</div>
<a id="ac5f78cb6440ac9cafd81482b213df930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f78cb6440ac9cafd81482b213df930">&#9670;&nbsp;</a></span>element_add_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::element_add_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>size_to_add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds unused capacity to the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator that points to the element to grow. </td></tr>
    <tr><td class="paramname">size_to_add</td><td>- bytes to add to the current element size </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating new buffer fails.</td></tr>
  </table>
  </dd>
</dl>
<p>This method also fixes alignment of element and adds missing padding. added capacity becomes unused capacity that is reserved for future use. Unused capacity is zero initialized. </p>

</div>
</div>
<a id="a7d10bb547c4bdac9b9d32c83b6b7a343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d10bb547c4bdac9b9d32c83b6b7a343">&#9670;&nbsp;</a></span>element_resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::element_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of functor user to update element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator that points to the element that is being resized. </td></tr>
    <tr><td class="paramname">new_size</td><td>- new element size. </td></tr>
    <tr><td class="paramname">fn</td><td>- functor used to update element after it was resized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating new buffer fails.</td></tr>
  </table>
  </dd>
</dl>
<p>Resizing to 0 will delete element. Resizing to size smaller than minimum_size will trigger fail-fast. Resizing to any other size also fixes alignment of element and adds missing padding. </p>

</div>
</div>
<a id="ac1e4fb5874008f3c4492331eb8f03e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e4fb5874008f3c4492331eb8f03e0f">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>new_element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs new element at the position described by iterator. Element is initialized with a help of the functor passed as a parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of a functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to the position new element should be inserte to. Iterator value must be a valid iterator pointing to one of the elements or an end iterator. If iterator is pointing to an element that is not propertly alligned then new element will not be propertly alligned. When iterator in not then end then size is padded to make sure that if this element is propertly alligned then next element is also property aligned. </td></tr>
    <tr><td class="paramname">new_element_size</td><td>- number of bytes required for the new element. </td></tr>
    <tr><td class="paramname">fn</td><td>- a functor used to construct new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pair of boolean that tells caller if element was inserted, and iterator to the position where it should be inserted in case of failure or was inserted in case of success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloca</td><td>if allocating new buffer fails. Any exceptions that might be raised by the functor. If functor raises then container remains in the state as if call did not happen</td></tr>
  </table>
  </dd>
</dl>
<p>Constructed element does not have to use up the entire buffer unused space will become unused buffer capacity. </p>

</div>
</div>
<a id="a01241f4c96c511e178cc5cb61b3aef5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01241f4c96c511e178cc5cb61b3aef5c">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs new element at the end of the list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of a functor Element is initialized with a help of the functor passed as a parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_size</td><td>- number of bytes required for the new element. </td></tr>
    <tr><td class="paramname">fn</td><td>- a functor used to construct new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloca</td><td>if allocating new buffer fails. Any exceptions that might be raised by the functor. If functor raises then container remains in the state as if call did not happen</td></tr>
  </table>
  </dd>
</dl>
<p>Constructed element does not have to use up the entire buffer unused space will become unused buffer capacity. </p>

</div>
</div>
<a id="aafd692819b4beba06fe8f5ee81d0cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd692819b4beba06fe8f5ee81d0cd2e">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new element at the beginnig of the container. Element is initialized with a help of the functor passed as a parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of a functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_size</td><td>- size of the buffer that will be used for initialization size smaller than minimum element size will trigger a fail-fast. When container is not empty then size is padded to make sure that next element is also property aligned. </td></tr>
    <tr><td class="paramname">fn</td><td>- a functor used to construct new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloca</td><td>if allocating new buffer fails. Any exceptions that might be raised by the functor. If functor raises then container remains in the state as if call did not happen </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54740bb53e624dffcab82da64b81f104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54740bb53e624dffcab82da64b81f104">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if container contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>False when containe contains at least one element and true otherwise.</dd></dl>
<p>Both container with no buffer as well as container that has buffer that does not contain any valid elements will return true. </p>

</div>
</div>
<a id="ad271eef884526f0b76592d3d7dccaf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad271eef884526f0b76592d3d7dccaf93">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an end iterator.</dd></dl>
<p>An end iterator is pointing pass the last element of container </p>

</div>
</div>
<a id="a8984c98f4e9510e413d184d5fcce7b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8984c98f4e9510e413d184d5fcce7b27">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an end const_iterator.</dd></dl>
<p>An end iterator is pointing pass the last element of container </p>

</div>
</div>
<a id="af31bc30ee9096da0058954b95417ab8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31bc30ee9096da0058954b95417ab8f">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases element pointed by iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to the element being erased.</td></tr>
  </table>
  </dd>
</dl>
<p>This gives us erase semantics everyone is used to, but algorithm complexity is O(element count) if we are erasing last element because we need to find element before the element being erased, and make it last. </p>

</div>
</div>
<a id="aaa9be92004a017c12fb7ea80ae87618b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9be92004a017c12fb7ea80ae87618b">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases element in the range [start, end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>- first element to be erased. </td></tr>
    <tr><td class="paramname">end</td><td>- one pass the last element that is being erased.</td></tr>
  </table>
  </dd>
</dl>
<p>This gives us erase semantics everyone is used to, but algorithm complexity is O(element count) if we are erasing all element till the end of container, because we need to find element before the element being erased, and make it last. </p>

</div>
</div>
<a id="a3905a536980ca8882f751b497f3e958b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3905a536980ca8882f751b497f3e958b">&#9670;&nbsp;</a></span>erase_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::erase_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases element after the element pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to an element before the element that will be erased. If iterator is pointing to the last element of container then it will trigger fail-fast. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7e6528393403b075ff0ee0a554a3fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e6528393403b075ff0ee0a554a3fab">&#9670;&nbsp;</a></span>erase_after_half_closed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::erase_after_half_closed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>before_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases element in the range (before_start, last]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">before_start</td><td>- iterator pointing to an element before the first element that will be erased. If iterator is pointing to the last element of container then it will trigger fail-fast. </td></tr>
    <tr><td class="paramname">last</td><td>- iterator pointing to the last element to be erased. if this iterator is end then it will irase all elements after before_start.</td></tr>
  </table>
  </dd>
</dl>
<p>Usualy pair of iterators define aa half opened range [start, end) Note that in this case our range is (start, last]. In other words we will erase all elements after start, including last. </p>

</div>
</div>
<a id="a39a8ed96f2f375cccf8ad0538a9682ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a8ed96f2f375cccf8ad0538a9682ee">&#9670;&nbsp;</a></span>erase_all_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::erase_all_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases element in the range (before_start, end) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to an element before the first element that will be erased. If iterator is pointing to the last element of container then it will trigger fail-fast. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad40b789c93606a6bf1f00babf6c23686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40b789c93606a6bf1f00babf6c23686">&#9670;&nbsp;</a></span>erase_all_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::erase_all_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases element in the range [it, end) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator to the first element to be erased</td></tr>
  </table>
  </dd>
</dl>
<p>This algorithm has complexity O(element count) because to erase element pointed by it we need to locate element before and make it new last element. </p>

</div>
</div>
<a id="a9a8d7e83cb1edc97e4a1d4afc2e7ea7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8d7e83cb1edc97e4a1d4afc2e7ea7b">&#9670;&nbsp;</a></span>fill_padding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::fill_padding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_byte</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zero_unused_capacity</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills parts of the buffer not used by element data with fill_byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fill_byte</td><td>- pattern to use </td></tr>
    <tr><td class="paramname">zero_unused_capacity</td><td>- also fill container unused capacity true by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad40fd8623c12fc3b9330e90ab482a9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40fd8623c12fc3b9330e90ab482a9d2">&#9670;&nbsp;</a></span>find_element_after() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::find_element_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element after the element that containes given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- offset in the conteiner's buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the found element, if it was found, and container's end iterator otherwise.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container) because we have to performa linear search for an element from the start of container's buffer. </p>

</div>
</div>
<a id="a499e064fc406db09b51c3070b5b496b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499e064fc406db09b51c3070b5b496b2">&#9670;&nbsp;</a></span>find_element_after() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::find_element_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element after the element that containes given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- offset in the conteiner's buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the found element, if it was found, and container's end const iterator otherwise.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container) because we have to performa linear search for an element from the start of container's buffer. </p>

</div>
</div>
<a id="a27ce10a9b75e74549c0cf940d691a1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ce10a9b75e74549c0cf940d691a1da">&#9670;&nbsp;</a></span>find_element_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::find_element_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element that containes given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- offset in the conteiner's buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the found element, if it was found, and container's end iterator otherwise.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container) because we have to performa linear search for an element from the start of container's buffer. </p>

</div>
</div>
<a id="a6e44339610a22f4bf4fe3f920b767d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e44339610a22f4bf4fe3f920b767d45">&#9670;&nbsp;</a></span>find_element_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::find_element_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element that containes given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- offset in the conteiner's buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the found element, if it was found, and container's end const iterator otherwise.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container) because we have to performa linear search for an element from the start of container's buffer. </p>

</div>
</div>
<a id="ac9a682c6cd8038564218d3989e50c667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a682c6cd8038564218d3989e50c667">&#9670;&nbsp;</a></span>find_element_before() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::find_element_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element before the element that containes given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- offset in the conteiner's buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the found element, if it was found, and container's end iterator otherwise.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container) because we have to performa linear search for an element from the start of container's buffer. </p>

</div>
</div>
<a id="a55152d5b9f54160debe43bff97040733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55152d5b9f54160debe43bff97040733">&#9670;&nbsp;</a></span>find_element_before() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::find_element_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element before the element that containes given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- offset in the conteiner's buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the found element, if it was found, and container's end const iterator otherwise.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container) because we have to performa linear search for an element from the start of container's buffer. </p>

</div>
</div>
<a id="a353f86d2ec2dfc9e57c7f22763ca1e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353f86d2ec2dfc9e57c7f22763ca1e2d">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the first element in the container.</dd></dl>
<p>Calling this method on a empty container will trigger fail-fast </p>

</div>
</div>
<a id="af72832120381fa785d2b15f7547bb071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72832120381fa785d2b15f7547bb071">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference to the first element in the container.</dd></dl>
<p>Calling this method on a empty container will trigger fail-fast </p>

</div>
</div>
<a id="aa75a05e0588ade0c5e7ff698a7784546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75a05e0588ade0c5e7ff698a7784546">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a48eff6c3870e8a47e546f9b3312b2d71">allocator_type</a>&amp; <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to the allocator used by this container. </p>
<dl class="section return"><dt>Returns</dt><dd>Allocator reference. </dd></dl>

</div>
</div>
<a id="aea2607b37e7acd106fa12bb9d48b25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2607b37e7acd106fa12bb9d48b25c2">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a48eff6c3870e8a47e546f9b3312b2d71">allocator_type</a> const&amp; <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const reference to the allocator used by this container. </p>
<dl class="section return"><dt>Returns</dt><dd>Allocator const reference. </dd></dl>

</div>
</div>
<a id="ab2df245169b6a9b2264ede5783a4397c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2df245169b6a9b2264ede5783a4397c">&#9670;&nbsp;</a></span>half_open_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a47445e33823a03584f99b950839ecd9a">range_t</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::half_open_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Information about the buffer occupied by elements in the range [begin, end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- iterator pointing to the first element. </td></tr>
    <tr><td class="paramname">end</td><td>- iterator pointing to the past last element in the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For any case, except when end element of range is the end element of the collection,<ul>
<li>start of the first element.</li>
<li>offset of the element before end data end.</li>
<li>offset of the element before end buffer end. If range end is colelction end then data end and buffer end point to the same position.</li>
</ul>
</dd></dl>
<p>All offsets values are relative to the buffer owned by the container. Algorithm has complexity O(number of elements in collection) because to find element before end we have to scan buffer from beginning. </p>

</div>
</div>
<a id="a6737b1fba55db96c0babc6bf81b09980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6737b1fba55db96c0babc6bf81b09980">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>init_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_buffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new element at the position described by iterator. Element is initialized by coppying provided buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to the position new element should be inserte to. Iterator value must be a valid iterator pointing to one of the elements or an end iterator. If iterator is pointing to an element that is not propertly alligned then new element will not be propertly alligned. </td></tr>
    <tr><td class="paramname">init_buffer_size</td><td>- size of the buffer that will be used for initialization size smaller than minimum element size will trigger a fail-fast. When iterator in not then end then size is padded to make sure that if this element is propertly alligned then next element is also property aligned. </td></tr>
    <tr><td class="paramname">init_buffer</td><td>- a poiner to the buffer. If pointer to the buffer is nullptr then element data are zero initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloca</td><td>if allocating new buffer fails.</td></tr>
  </table>
  </dd>
</dl>
<p>New element becomes a new last element and, if set_next offset is supported, then it is called on the previous last element such that it points to the new one. </p>

</div>
</div>
<a id="a149964301c14bb68cd97eec42a17f6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149964301c14bb68cd97eec42a17f6c3">&#9670;&nbsp;</a></span>is_compatible_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename AA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::is_compatible_allocator </td>
          <td>(</td>
          <td class="paramtype">AA const &amp;&#160;</td>
          <td class="paramname"><em>other_allocator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares if allocator used by container is equivalent to the other alocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_allocator</td><td>- allocator we are comparing to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if allocators are equivalent, and false otherwise. </dd></dl>

</div>
</div>
<a id="a5e954cb6c473db357ea47abefb1fbf86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e954cb6c473db357ea47abefb1fbf86">&#9670;&nbsp;</a></span>last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator pointing to the last element of container.</dd></dl>
<p>Calling on an empty container returns end iterator </p>

</div>
</div>
<a id="a9532a6ff5f31fcdf2fb96e0bf8477532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9532a6ff5f31fcdf2fb96e0bf8477532">&#9670;&nbsp;</a></span>last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const iterator pointing to the last element of container.</dd></dl>
<p>Calling on an empty container returns end iterator </p>

</div>
</div>
<a id="aab52f33651aba885d4de1f6950038905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab52f33651aba885d4de1f6950038905">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns maximum size. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum size.</dd></dl>
<p>For this container it is maximum number of bytes that can be allocated through allocator used by this container </p>

</div>
</div>
<a id="a0230f3b404fcc3d8379d88e3a145ec9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0230f3b404fcc3d8379d88e3a145ec9d">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two linked list ordering lists using comparison functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of comparison functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>- comparison functor </td></tr>
    <tr><td class="paramname">other</td><td>- the other list we are merging with </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc when allocation fails.</td></tr>
  </table>
  </dd>
</dl>
<p>if both lists are sorted, and we are merging using the same compare functor, then merged list will be sorted. </p>

</div>
</div>
<a id="acaed0d20746c46aae94752b6308a0344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaed0d20746c46aae94752b6308a0344">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&amp; <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- linked list we are moving from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">noexcept</td><td>if allocator is propagate_on_container_move_assignment</td></tr>
  </table>
  </dd>
</dl>
<p>If allocator is propagate_on_container_move_assignment then it moves allocator, and moves buffer ownership. Otherwise if allocator are equivalent then data are moves. If allocators are not equivalent then new buffer is allocated and list is copied. In the last case this function might throw std::bad_alloc </p>

</div>
</div>
<a id="af4ba60911e7af2cf14a26acfed6e6771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ba60911e7af2cf14a26acfed6e6771">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&amp; <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- linked list we are copying from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>when allocating buffer fails</td></tr>
  </table>
  </dd>
</dl>
<p>This function first attempts to copy allocator, if it is supported, and after that allocates new buffer and copies all elements to the new buffer. </p>

</div>
</div>
<a id="a79ff402c3c60a1f615e80a0e01489a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ff402c3c60a1f615e80a0e01489a64">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&amp; <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>other_buff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_buff</td><td>- linked list we are copying from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>when allocating buffer fails</td></tr>
  </table>
  </dd>
</dl>
<p>This function first attempts to copy allocator, if it is supported, and after that allocates new buffer and copies all elements to the new buffer. </p>

</div>
</div>
<a id="aeafdb0311999b32801715649a1e436f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafdb0311999b32801715649a1e436f0">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes last element from the list. </p>
<p>Tnis method has cost O(number of elements). Cost comes from scanning buffer from beginning to find element before the current last element. Since this is a single linked list we have no faster way to locate it. Element before current last element will become new last element. </p>

</div>
</div>
<a id="acf4b04a0b2c64bd346ec9ceaaaa6faac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4b04a0b2c64bd346ec9ceaaaa6faac">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes first element from the container. </p>
<p>Calling on empty container will trigger fail-fast </p>

</div>
</div>
<a id="a21379e1564a876956ba65b185e5da02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21379e1564a876956ba65b185e5da02a">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>init_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_buffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds new elemnt to the end of the list. Element is initialized by coppying provided buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_buffer_size</td><td>- size of the buffer that will be used for initialization size smaller than minimum element size will trigger a fail-fast. </td></tr>
    <tr><td class="paramname">init_buffer</td><td>- a poiner to the buffer. If pointer to the buffer is nullptr then element data are zero initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloca</td><td>if allocating new buffer fails</td></tr>
  </table>
  </dd>
</dl>
<p>New element becomes a new last element and, if set_next offset is supported, then it is called on the previous last element such that it points to the new one. </p>

</div>
</div>
<a id="a8d78c2f471a13687e13e4cf327793e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d78c2f471a13687e13e4cf327793e42">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>init_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_buffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs new element at the beginnig of the container. Element is initialized by coppying provided buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_buffer_size</td><td>- size of the buffer that will be used for initialization size smaller than minimum element size will trigger a fail-fast. When container is not empty then size is padded to make sure that next element is also property aligned. </td></tr>
    <tr><td class="paramname">init_buffer</td><td>- a poiner to the buffer. If pointer to the buffer is nullptr then element data are zero initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloca</td><td>if allocating new buffer fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60c8b5f67a43a504332a0e8702df5b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c8b5f67a43a504332a0e8702df5b5c">&#9670;&nbsp;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a47445e33823a03584f99b950839ecd9a">range_t</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::<a class="el" href="structiffl_1_1range.html">range</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Information about the buffer occupied by an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For any element except the last, it returns:<ul>
<li>start element offset.</li>
<li>offset of element data end.</li>
<li>offset of element buffer end. For the last element data end and buffer end point to the same position.</li>
</ul>
</dd></dl>
<p>All offsets values are relative to the buffer owned by the container. </p>

</div>
</div>
<a id="a1e02c4df75b8e8b9fb9a57f1943c207b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e02c4df75b8e8b9fb9a57f1943c207b">&#9670;&nbsp;</a></span>remaining_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::remaining_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in the buffer not used by the existing elements. </dd></dl>

</div>
</div>
<a id="a9f8330232495a549bc7c9dd9b6971d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8330232495a549bc7c9dd9b6971d7a">&#9670;&nbsp;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements that satisfy predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>- predicate functor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a784af2858013e63f73f5c4f624663f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784af2858013e63f73f5c4f624663f39">&#9670;&nbsp;</a></span>required_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::required_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns capacity used by the element's data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to the element we are returning size for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns size of the element without paddint </dd></dl>

</div>
</div>
<a id="a6ae342f90c0c6a7f6cf215f913691fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae342f90c0c6a7f6cf215f913691fa4">&#9670;&nbsp;</a></span>resize_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::resize_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- new buffer size Passing 0 has same effect as clearing container Setting buffer size to the value smaller than first element size will produce empty list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloca</td><td>if allocating new buffer fails</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates new buffer of specified size, and copies all elements that can fit to the new buffer size. all other elements will be erased. Resizing buffer to the larger capacity will add unused capacity. This can help reduce buffer reallocations when adding new elements to the buffer. Resizing to capacity smaller than used capacity will end up erasing elements that do not fit to the new buffer size. </p>

</div>
</div>
<a id="a8ab813a8b15fcf7b3d70888d9bc9d91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab813a8b15fcf7b3d70888d9bc9d91e">&#9670;&nbsp;</a></span>revalidate_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::revalidate_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates that buffer contains a valid list. </p>
<dl class="section return"><dt>Returns</dt><dd>true if valid list was found and false otherwise.</dd></dl>
<p>You must call this method after passing pointer to container's buffer to a function that might change buffer content. If valid list of found then buff().last will be pointing to the element element that was found. If no valid list was found then buff().last will be nullptr. </p>

</div>
</div>
<a id="a76e6fcf8f539248daeba7dce78f7d039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e6fcf8f539248daeba7dce78f7d039">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses elements of the list. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc when allocation fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7d1e1176e0e05fcbfd27bccf958392c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d1e1176e0e05fcbfd27bccf958392c">&#9670;&nbsp;</a></span>shrink_to_fit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes unused padding of each element and at the tail. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating new buffer fails.</td></tr>
  </table>
  </dd>
</dl>
<p>This method also fixes alignment of each element and adds missing padding, so at the end used capacity might grow. Once unused capacity of each element is removed, and missing padding added, this method method reallocates buffer to remove any unused capacity at the tail. </p>

</div>
</div>
<a id="adff7a544b9466e72523dbee770150ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff7a544b9466e72523dbee770150ead">&#9670;&nbsp;</a></span>shrink_to_fit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes unused padding of each element in the range [first, end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- iterator that points to the first element to shrink. </td></tr>
    <tr><td class="paramname">end</td><td>- iterator that points passt the last element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating new buffer fails.</td></tr>
  </table>
  </dd>
</dl>
<p>This method also fixes alignment of each element and adds missing padding, so at the end used capacity might grow. </p>

</div>
</div>
<a id="a0fe0f15d22d91fcb9ae78e00a8f4af89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe0f15d22d91fcb9ae78e00a8f4af89">&#9670;&nbsp;</a></span>shrink_to_fit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes unused padding of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator that points to the element to shrink. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating new buffer fails.</td></tr>
  </table>
  </dd>
</dl>
<p>This method also fixes alignment of element and adds missing padding, so at the end used capacity might grow. </p>

</div>
</div>
<a id="ae7f71ba91588b44793b1e1726810d51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f71ba91588b44793b1e1726810d51b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in the container.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container). Container does not actively cache/updates element count so we need to scan list to find number of elements. </p>

</div>
</div>
<a id="ac5d5234f8daf81076417cbb6a15278ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d5234f8daf81076417cbb6a15278ad">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename LESS_F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">LESS_F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts elements of container using comparator passed as a parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LESS_F</td><td>- type of comparator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>- instance of comparator</td></tr>
  </table>
  </dd>
</dl>
<p>Algorithm complexity is O(n*log(n)+2*n) </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc when allocation fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac348412275edd1cff2d1b1feddd824a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac348412275edd1cff2d1b1feddd824a7">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps content of this container and the other container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- reference to the other container </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">might</td><td>throw std::bad_alloc if allocator swap throws or if allocators do not suport swap, and we need to make a copy of elements, which involves allocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af34284f1938026d3888c2fc5a1d3ac7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34284f1938026d3888c2fc5a1d3ac7a">&#9670;&nbsp;</a></span>tail_shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::tail_shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes buffer to the used capacity. </p>
<p>Allocates new buffer of exact size that is required to keep all elements, moves all elements there and deallocates old buffer. If buffer already has no unused capacity then this call is noop. </p>

</div>
</div>
<a id="a09a18b5f5c7bf54cb87faccb97a8b4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a18b5f5c7bf54cb87faccb97a8b4c7">&#9670;&nbsp;</a></span>total_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::total_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Buffer size. </dd></dl>

</div>
</div>
<a id="a0647a468dde5ed38ae7ba4d90f7af7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0647a468dde5ed38ae7ba4d90f7af7d3">&#9670;&nbsp;</a></span>try_element_add_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::try_element_add_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>size_to_add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds unused capacity to the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator that points to the element to grow. </td></tr>
    <tr><td class="paramname">size_to_add</td><td>- bytes to add to the current element size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if element was placed in the existing buffer and false if buffer does not have enough capacity for the new element.</dd></dl>
<p>This method also fixes alignment of element and adds missing padding. added capacity becomes unused capacity that is reserved for future use. Unused capacity is zero initialized. </p>

</div>
</div>
<a id="ad4416213cbf593143f177a6c6aec1e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4416213cbf593143f177a6c6aec1e33">&#9670;&nbsp;</a></span>try_element_resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::try_element_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of functor user to update element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator that points to the element that is being resized. </td></tr>
    <tr><td class="paramname">new_size</td><td>- new element size. </td></tr>
    <tr><td class="paramname">fn</td><td>- functor used to update element after it was resized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if element was placed in the existing buffer and false if buffer does not have enough capacity for the new element.</dd></dl>
<p>Resizing to 0 will delete element. Resizing to size smaller than minimum_size will trigger fail-fast. Resizing to any other size also fixes alignment of element and adds missing padding. </p>

</div>
</div>
<a id="aeda23f49f747a1b83864d17717fe31cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda23f49f747a1b83864d17717fe31cf">&#9670;&nbsp;</a></span>try_emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>new_element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs new element at the position described by iterator. Element is initialized with a help of the functor passed as a parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of a functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to the position new element should be inserte to. Iterator value must be a valid iterator pointing to one of the elements or an end iterator. If iterator is pointing to an element that is not propertly alligned then new element will not be propertly alligned. When iterator in not then end then size is padded to make sure that if this element is propertly alligned then next element is also property aligned. </td></tr>
    <tr><td class="paramname">new_element_size</td><td>- number of bytes required for the new element. </td></tr>
    <tr><td class="paramname">fn</td><td>- a functor used to construct new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pair of boolean that tells caller if element was inserted, and iterator to the position where it should be inserted in case of failure or was inserted in case of success. </dd>
<dd>
true if element was placed in the existing buffer and false if buffer does not have enough capacity for the new element.</dd></dl>
<p>Constructed element does not have to use up the entire buffer unused space will become unused buffer capacity. </p>

</div>
</div>
<a id="a707541c446ced7b8078e2db52f472b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707541c446ced7b8078e2db52f472b57">&#9670;&nbsp;</a></span>try_emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::try_emplace_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs new element at the end of the list if it fits in the existing free capacity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of a functor Element is initialized with a help of the functor passed as a parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_size</td><td>- number of bytes required for the new element. </td></tr>
    <tr><td class="paramname">fn</td><td>- a functor used to construct new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if element was placed in the existing buffer and false if buffer does not have enough capacity for the new element.</dd></dl>
<p>Constructed element does not have to use up the entire buffer unused space will become unused buffer capacity. </p>

</div>
</div>
<a id="a225ec9bc851ca9a7fa07e2151c709dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225ec9bc851ca9a7fa07e2151c709dc4">&#9670;&nbsp;</a></span>try_emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::try_emplace_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new element at the beginnig of the container. Element is initialized with a help of the functor passed as a parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of a functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_size</td><td>- size of the buffer that will be used for initialization size smaller than minimum element size will trigger a fail-fast. When container is not empty then size is padded to make sure that next element is also property aligned. </td></tr>
    <tr><td class="paramname">fn</td><td>- a functor used to construct new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if element was placed in the existing buffer and false if buffer does not have enough capacity for the new element. </dd></dl>

</div>
</div>
<a id="a188a147c095b190f2af5fa98cb13ab50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188a147c095b190f2af5fa98cb13ab50">&#9670;&nbsp;</a></span>try_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::try_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a59bf6a6f46962a1fbaf0d2f7d91098f2">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>init_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_buffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new element at the position described by iterator. Element is initialized by coppying provided buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to the position new element should be inserte to. Iterator value must be a valid iterator pointing to one of the elements or an end iterator. If iterator is pointing to an element that is not propertly alligned then new element will not be propertly alligned. </td></tr>
    <tr><td class="paramname">init_buffer_size</td><td>- size of the buffer that will be used for initialization size smaller than minimum element size will trigger a fail-fast. When iterator in not then end then size is padded to make sure that if this element is propertly alligned then next element is also property aligned. </td></tr>
    <tr><td class="paramname">init_buffer</td><td>- a poiner to the buffer. If pointer to the buffer is nullptr then element data are zero initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if element was placed in the existing buffer and false if buffer does not have enough capacity for the new element.</dd></dl>
<p>New element becomes a new last element and, if set_next offset is supported, then it is called on the previous last element such that it points to the new one. </p>

</div>
</div>
<a id="a010c5ed15b0267ab98f6bc796aa5192f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010c5ed15b0267ab98f6bc796aa5192f">&#9670;&nbsp;</a></span>try_push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::try_push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>init_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_buffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds new elemnt to the end of the list. Element is initialized by coppying provided buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_buffer_size</td><td>- size of the buffer that will be used for initialization size smaller than minimum element size will trigger a fail-fast. </td></tr>
    <tr><td class="paramname">init_buffer</td><td>- a poiner to the buffer. If pointer to the buffer is nullptr then element data are zero initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloca</td><td>if allocating new buffer fails</td></tr>
  </table>
  </dd>
</dl>
<p>New element becomes a new last element and, if set_next offset is supported, then it is called on the previous last element such that it points to the new one. </p><dl class="section return"><dt>Returns</dt><dd>true if element was placed in the existing buffer and false if buffer does not have enough capacity for the new element. </dd></dl>

</div>
</div>
<a id="a95cbc46ab002b4267d2e2b6f2d60e5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cbc46ab002b4267d2e2b6f2d60e5f5">&#9670;&nbsp;</a></span>try_push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::try_push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a>&#160;</td>
          <td class="paramname"><em>init_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_buffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs new element at the beginnig of the container. Element is initialized by coppying provided buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_buffer_size</td><td>- size of the buffer that will be used for initialization size smaller than minimum element size will trigger a fail-fast. When container is not empty then size is padded to make sure that next element is also property aligned. </td></tr>
    <tr><td class="paramname">init_buffer</td><td>- a poiner to the buffer. If pointer to the buffer is nullptr then element data are zero initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if element was placed in the existing buffer and false if buffer does not have enough capacity for the new element. </dd></dl>

</div>
</div>
<a id="af537a98c54789b2d8efef41a0ab315b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af537a98c54789b2d8efef41a0ab315b1">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If there are multiple equivalent elements next to each other then first one is kept, and all other are deleted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>- type of comparison functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>- comparison functor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae324c4d88d822fbacf6d7ead3c07242d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae324c4d88d822fbacf6d7ead3c07242d">&#9670;&nbsp;</a></span>used_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::used_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in the bufer used by existing elements. </dd></dl>

</div>
</div>
<a id="a73423cf1724da4c572a6b1220cc04e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73423cf1724da4c572a6b1220cc04e84">&#9670;&nbsp;</a></span>used_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html#a08fdcd8ca95876ed148244983cd4929b">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list</a>&lt; T, TT, A &gt;::used_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html#ade934330e2dce8176985d15f7ee927cf">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to the element we are returning size for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For any element except last returns distance from element start to the start of the next element. For the last element it returns used_capacity </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a994773d1cdb85755ff5ff9937abc1a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994773d1cdb85755ff5ff9937abc1a48">&#9670;&nbsp;</a></span>flat_forward_list_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Give <a class="el" href="classiffl_1_1flat__forward__list__ref.html" title="Non owning container for flat forward list.">flat_forward_list_ref</a> friend permissins so it can initialize itself from the buffer </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="iffl__list_8h_source.html">iffl_list.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

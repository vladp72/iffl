<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: iffl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">iffl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>intrusive flat forward list  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceiffl_1_1mpl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl_1_1mpl.html">mpl</a></td></tr>
<tr class="memdesc:namespaceiffl_1_1mpl"><td class="mdescLeft">&#160;</td><td class="mdescRight">intrusive flat forward list <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1attach__buffer.html">attach_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used as a parameter in <a class="el" href="classiffl_1_1flat__forward__list.html" title="Intrusive flat forward list container.">flat_forward_list</a> constructor to designate that it should take ownership of the buffer rather than make a copy.  <a href="structiffl_1_1attach__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1buffer__t.html">buffer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of pointers describing state of the buffer containing flat forward list.  <a href="structiffl_1_1buffer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1compressed__pair.html">compressed_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty Base Class Optimization EBCO helper.  <a href="classiffl_1_1compressed__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1compressed__pair_3_01_t1_00_01_t2_00_01false_01_4.html">compressed_pair&lt; T1, T2, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the case when Empty Base Class Optimization EBCO would not work.  <a href="classiffl_1_1compressed__pair_3_01_t1_00_01_t2_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1debug__memory__resource.html">debug_memory_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements std::pmr::memory_resource interface.  <a href="classiffl_1_1debug__memory__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive flat forward list container.  <a href="classiffl_1_1flat__forward__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">flat_forward_list_iterator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">THis class implements forward iterator for intrusive flat forward list.  <a href="classiffl_1_1flat__forward__list__iterator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non owning container for flat forward list.  <a href="classiffl_1_1flat__forward__list__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__sizes.html">flat_forward_list_sizes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes buffer used by container.  <a href="structiffl_1_1flat__forward__list__sizes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits.html">flat_forward_list_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits for an elements that are in the flat forward list  <a href="structiffl_1_1flat__forward__list__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">flat_forward_list_traits_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits for <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a>  <a href="structiffl_1_1flat__forward__list__traits__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1input__buffer__memory__resource.html">input_buffer_memory_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements std::pmr::memory_resource interface.  <a href="classiffl_1_1input__buffer__memory__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1noop__validate__element__fn.html">noop_validate_element_fn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1offset__with__aligment.html">offset_with_aligment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that describes an offset in a larger buffer and template parameter that specifies element's type alignment requirements.  <a href="structiffl_1_1offset__with__aligment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1one__then__variadic__args__t.html">one_then_variadic_args_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type for constructing first from one arg, constructing second from remaining args.  <a href="structiffl_1_1one__then__variadic__args__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that describes a subbuffer in a larger buffer, and portion of that subbuffer actuallu used by the data.  <a href="structiffl_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1range__with__alighment.html">range_with_alighment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that describes a subbuffer in a larger buffer and portion of that subbuffer actuallu used by the data.  <a href="structiffl_1_1range__with__alighment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1scope__guard.html">scope_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template class that can be parametrised with a functor or a lambda that it will call in distructor.  <a href="classiffl_1_1scope__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1size__with__padding.html">size_with_padding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that describes an size and template parameter that specifies element's type alignment requirements.  <a href="structiffl_1_1size__with__padding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1zero__then__variadic__args__t.html">zero_then_variadic_args_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type for value - initializing first, constructing second from remaining args.  <a href="structiffl_1_1zero__then__variadic__args__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a78536459b06204bafd2ddbfb7b778df9"><td class="memItemLeft" align="right" valign="top"><a id="a78536459b06204bafd2ddbfb7b778df9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a78536459b06204bafd2ddbfb7b778df9">buffer_ref</a> = <a class="el" href="structiffl_1_1buffer__t.html">buffer_t</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a78536459b06204bafd2ddbfb7b778df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non const flat forward list buffer. <br /></td></tr>
<tr class="separator:a78536459b06204bafd2ddbfb7b778df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285870e8a61063c542965ad589fee6df"><td class="memItemLeft" align="right" valign="top"><a id="a285870e8a61063c542965ad589fee6df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> = <a class="el" href="structiffl_1_1buffer__t.html">buffer_t</a>&lt; char const  &gt;</td></tr>
<tr class="memdesc:a285870e8a61063c542965ad589fee6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const flat forward list buffer. <br /></td></tr>
<tr class="separator:a285870e8a61063c542965ad589fee6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc99c7f27e6b377339364aef8b45b0c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a0cc99c7f27e6b377339364aef8b45b0c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a> = <a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">flat_forward_list_iterator_t</a>&lt; T, TT &gt;</td></tr>
<tr class="memdesc:a0cc99c7f27e6b377339364aef8b45b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const iterator  <a href="#a0cc99c7f27e6b377339364aef8b45b0c">More...</a><br /></td></tr>
<tr class="separator:a0cc99c7f27e6b377339364aef8b45b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67086ee8db08a7b96df7f9759d02a1b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ad67086ee8db08a7b96df7f9759d02a1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ad67086ee8db08a7b96df7f9759d02a1b">flat_forward_list_const_iterator</a> = <a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">flat_forward_list_iterator_t</a>&lt; std::add_const_t&lt; T &gt;, TT &gt;</td></tr>
<tr class="memdesc:ad67086ee8db08a7b96df7f9759d02a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator  <a href="#ad67086ee8db08a7b96df7f9759d02a1b">More...</a><br /></td></tr>
<tr class="separator:ad67086ee8db08a7b96df7f9759d02a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df220d9126052279a6c8c6cd3e482a"><td class="memTemplParams" colspan="2"><a id="a06df220d9126052279a6c8c6cd3e482a"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a06df220d9126052279a6c8c6cd3e482a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a06df220d9126052279a6c8c6cd3e482a">flat_forward_list_view</a> = <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T const, TT &gt;</td></tr>
<tr class="memdesc:a06df220d9126052279a6c8c6cd3e482a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant view to flat forward list. <br /></td></tr>
<tr class="separator:a06df220d9126052279a6c8c6cd3e482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3cdfbfc81a514a8e68df0854789a00"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aed3cdfbfc81a514a8e68df0854789a00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aed3cdfbfc81a514a8e68df0854789a00">pmr_flat_forward_list</a> = <a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, FFL_PMR::polymorphic_allocator&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:aed3cdfbfc81a514a8e68df0854789a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this typedef if you want to use container with polimorfic allocator.  <a href="#aed3cdfbfc81a514a8e68df0854789a00">More...</a><br /></td></tr>
<tr class="separator:aed3cdfbfc81a514a8e68df0854789a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2a9d91b46344e59160e070b770d40e9f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a9d91b46344e59160e070b770d40e9f"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a2a9d91b46344e59160e070b770d40e9f">unused_variable</a> ([[maybe_unused]] T const &amp;)</td></tr>
<tr class="memdesc:a2a9d91b46344e59160e070b770d40e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore saved min and max definition.  <a href="#a2a9d91b46344e59160e070b770d40e9f">More...</a><br /></td></tr>
<tr class="separator:a2a9d91b46344e59160e070b770d40e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ca50887c9840f023931e8b27ccbe17"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93ca50887c9840f023931e8b27ccbe17"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a93ca50887c9840f023931e8b27ccbe17">unused_expression_result</a> ([[maybe_unused]] T const &amp;)</td></tr>
<tr class="memdesc:a93ca50887c9840f023931e8b27ccbe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Silence sinetizer warning about unused result of expression.  <a href="#a93ca50887c9840f023931e8b27ccbe17">More...</a><br /></td></tr>
<tr class="separator:a93ca50887c9840f023931e8b27ccbe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e326f8ca98ad06d942924c5ffbc63a3"><td class="memItemLeft" align="right" valign="top">size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a7e326f8ca98ad06d942924c5ffbc63a3">ptr_to_size</a> (void const *const ptr)</td></tr>
<tr class="memdesc:a7e326f8ca98ad06d942924c5ffbc63a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterprets pointer to void value as size_t value.  <a href="#a7e326f8ca98ad06d942924c5ffbc63a3">More...</a><br /></td></tr>
<tr class="separator:a7e326f8ca98ad06d942924c5ffbc63a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6467e8b19ddcb0a0a80dce324f2eb9c3"><td class="memItemLeft" align="right" valign="top">void *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a6467e8b19ddcb0a0a80dce324f2eb9c3">size_to_ptr</a> (size_t size)</td></tr>
<tr class="memdesc:a6467e8b19ddcb0a0a80dce324f2eb9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterprets size_t value as pointer to void.  <a href="#a6467e8b19ddcb0a0a80dce324f2eb9c3">More...</a><br /></td></tr>
<tr class="separator:a6467e8b19ddcb0a0a80dce324f2eb9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e6c55d3f8fcdb53f64debbbf4a5c7d"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a32e6c55d3f8fcdb53f64debbbf4a5c7d">roundup_size_to_alignment</a> (size_t size, size_t alignment) noexcept</td></tr>
<tr class="memdesc:a32e6c55d3f8fcdb53f64debbbf4a5c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up size to specified alignment.  <a href="#a32e6c55d3f8fcdb53f64debbbf4a5c7d">More...</a><br /></td></tr>
<tr class="separator:a32e6c55d3f8fcdb53f64debbbf4a5c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12acd05702a4128b55949434f988286"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa12acd05702a4128b55949434f988286"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aa12acd05702a4128b55949434f988286">roundup_size_to_alignment</a> (size_t size) noexcept</td></tr>
<tr class="memdesc:aa12acd05702a4128b55949434f988286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up size to specified alignment.  <a href="#aa12acd05702a4128b55949434f988286">More...</a><br /></td></tr>
<tr class="separator:aa12acd05702a4128b55949434f988286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7163004d24a40a5c4880bacb8985e33"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ab7163004d24a40a5c4880bacb8985e33">roundup_ptr_to_alignment</a> (void *ptr, size_t alignment) noexcept</td></tr>
<tr class="memdesc:ab7163004d24a40a5c4880bacb8985e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up pointer to specified alignment.  <a href="#ab7163004d24a40a5c4880bacb8985e33">More...</a><br /></td></tr>
<tr class="separator:ab7163004d24a40a5c4880bacb8985e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e57aa95c52aab88cddd3f6902790ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a36e57aa95c52aab88cddd3f6902790ee"><td class="memTemplItemLeft" align="right" valign="top">void *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a36e57aa95c52aab88cddd3f6902790ee">roundup_ptr_to_alignment</a> (void *ptr) noexcept</td></tr>
<tr class="memdesc:a36e57aa95c52aab88cddd3f6902790ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up pointer to specified alignment.  <a href="#a36e57aa95c52aab88cddd3f6902790ee">More...</a><br /></td></tr>
<tr class="separator:a36e57aa95c52aab88cddd3f6902790ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c092d294aa9443c6d2ed0fe826c060"><td class="memItemLeft" align="right" valign="top">void const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a35c092d294aa9443c6d2ed0fe826c060">roundup_ptr_to_alignment</a> (void const *ptr, size_t alignment) noexcept</td></tr>
<tr class="memdesc:a35c092d294aa9443c6d2ed0fe826c060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up pointer to specified alignment.  <a href="#a35c092d294aa9443c6d2ed0fe826c060">More...</a><br /></td></tr>
<tr class="separator:a35c092d294aa9443c6d2ed0fe826c060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efcb4790de0482696257578b53490c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5efcb4790de0482696257578b53490c1"><td class="memTemplItemLeft" align="right" valign="top">void const  *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a5efcb4790de0482696257578b53490c1">roundup_ptr_to_alignment</a> (void const *ptr) noexcept</td></tr>
<tr class="memdesc:a5efcb4790de0482696257578b53490c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up pointer to specified alignment.  <a href="#a5efcb4790de0482696257578b53490c1">More...</a><br /></td></tr>
<tr class="separator:a5efcb4790de0482696257578b53490c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad07072ae8b15c3cb89c45049f070b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aad07072ae8b15c3cb89c45049f070b7c">copy_data</a> (char *to_buffer, char const *from_buffer, size_t length) noexcept</td></tr>
<tr class="memdesc:aad07072ae8b15c3cb89c45049f070b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies length bytes from from_buffer to to_buffer. source and destination buffers cannot overlap  <a href="#aad07072ae8b15c3cb89c45049f070b7c">More...</a><br /></td></tr>
<tr class="separator:aad07072ae8b15c3cb89c45049f070b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18f9699312805dc2f72a5d4a00ef790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ab18f9699312805dc2f72a5d4a00ef790">move_data</a> (char *to_buffer, char const *from_buffer, size_t length) noexcept</td></tr>
<tr class="memdesc:ab18f9699312805dc2f72a5d4a00ef790"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies length bytes from from_buffer to to_buffer. source and destination buffers can overlap  <a href="#ab18f9699312805dc2f72a5d4a00ef790">More...</a><br /></td></tr>
<tr class="separator:ab18f9699312805dc2f72a5d4a00ef790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bf093b969e4bf780b6d0347a942a2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ac8bf093b969e4bf780b6d0347a942a2e">fill_buffer</a> (char *buffer, int value, size_t length) noexcept</td></tr>
<tr class="memdesc:ac8bf093b969e4bf780b6d0347a942a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets "length" consequative bytes of "to_buffer" to "value".  <a href="#ac8bf093b969e4bf780b6d0347a942a2e">More...</a><br /></td></tr>
<tr class="separator:ac8bf093b969e4bf780b6d0347a942a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395800a3bee8537b31af93bbba3927ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a395800a3bee8537b31af93bbba3927ac">zero_buffer</a> (char *buffer, size_t length) noexcept</td></tr>
<tr class="memdesc:a395800a3bee8537b31af93bbba3927ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets "length" consequative bytes of "to_buffer" to 0.  <a href="#a395800a3bee8537b31af93bbba3927ac">More...</a><br /></td></tr>
<tr class="separator:a395800a3bee8537b31af93bbba3927ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75de19b348b30c2c9cec77c6ab5d0e12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a75de19b348b30c2c9cec77c6ab5d0e12">distance</a> (void const *<a class="el" href="namespaceiffl.html#a47edc2d9ad6c13bd5daf398339c503a7">begin</a>, void const *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>) noexcept</td></tr>
<tr class="memdesc:a75de19b348b30c2c9cec77c6ab5d0e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets "length" consequative bytes of "to_buffer" to 0.  <a href="#a75de19b348b30c2c9cec77c6ab5d0e12">More...</a><br /></td></tr>
<tr class="separator:a75de19b348b30c2c9cec77c6ab5d0e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641650e46f9c6138e9358b9b4b4552ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a641650e46f9c6138e9358b9b4b4552ff"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a641650e46f9c6138e9358b9b4b4552ff">cast_to_char_ptr</a> (T *p) noexcept</td></tr>
<tr class="memdesc:a641650e46f9c6138e9358b9b4b4552ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to cast a pointer to a char *.  <a href="#a641650e46f9c6138e9358b9b4b4552ff">More...</a><br /></td></tr>
<tr class="separator:a641650e46f9c6138e9358b9b4b4552ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486d006deb665810fd35a6c029472375"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a486d006deb665810fd35a6c029472375"><td class="memTemplItemLeft" align="right" valign="top">void *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a486d006deb665810fd35a6c029472375">cast_to_void_ptr</a> (T *p) noexcept</td></tr>
<tr class="memdesc:a486d006deb665810fd35a6c029472375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to cast a pointer to a void *.  <a href="#a486d006deb665810fd35a6c029472375">More...</a><br /></td></tr>
<tr class="separator:a486d006deb665810fd35a6c029472375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b398fb9f25e87b28239b8cd37adc324"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a9b398fb9f25e87b28239b8cd37adc324"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a9b398fb9f25e87b28239b8cd37adc324">make_scope_guard</a> (G &amp;&amp;g)</td></tr>
<tr class="memdesc:a9b398fb9f25e87b28239b8cd37adc324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for scoped_guard.  <a href="#a9b398fb9f25e87b28239b8cd37adc324">More...</a><br /></td></tr>
<tr class="separator:a9b398fb9f25e87b28239b8cd37adc324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4283508b0594464b208680293c8fa1f5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a4283508b0594464b208680293c8fa1f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a4283508b0594464b208680293c8fa1f5">flat_forward_list_validate_has_next_offset</a> (char const *first, char const *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a4283508b0594464b208680293c8fa1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="#a4283508b0594464b208680293c8fa1f5">More...</a><br /></td></tr>
<tr class="separator:a4283508b0594464b208680293c8fa1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f6375903d5162437963a66888259a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ac7f6375903d5162437963a66888259a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ac7f6375903d5162437963a66888259a9">flat_forward_list_validate_no_next_offset</a> (char const *first, char const *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:ac7f6375903d5162437963a66888259a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="#ac7f6375903d5162437963a66888259a9">More...</a><br /></td></tr>
<tr class="separator:ac7f6375903d5162437963a66888259a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bb0b65178106f5fb0634982ec75668"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a06bb0b65178106f5fb0634982ec75668"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a06bb0b65178106f5fb0634982ec75668">flat_forward_list_validate</a> (char const *first, char const *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a06bb0b65178106f5fb0634982ec75668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="#a06bb0b65178106f5fb0634982ec75668">More...</a><br /></td></tr>
<tr class="separator:a06bb0b65178106f5fb0634982ec75668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae26253c6bd5e08b98229024e59dd2"><td class="memTemplParams" colspan="2"><a id="a2fae26253c6bd5e08b98229024e59dd2"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a2fae26253c6bd5e08b98229024e59dd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a2fae26253c6bd5e08b98229024e59dd2">flat_forward_list_validate</a> (char *first, char *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a2fae26253c6bd5e08b98229024e59dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration. <br /></td></tr>
<tr class="separator:a2fae26253c6bd5e08b98229024e59dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fc601092b4f211fa1369f540d43269"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:af3fc601092b4f211fa1369f540d43269"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#af3fc601092b4f211fa1369f540d43269">flat_forward_list_validate</a> (T *first, T *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:af3fc601092b4f211fa1369f540d43269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="#af3fc601092b4f211fa1369f540d43269">More...</a><br /></td></tr>
<tr class="separator:af3fc601092b4f211fa1369f540d43269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dae54f1aef65189d4b3cf86ababc16"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a23dae54f1aef65189d4b3cf86ababc16"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a23dae54f1aef65189d4b3cf86ababc16">flat_forward_list_validate</a> (T const *first, T const *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a23dae54f1aef65189d4b3cf86ababc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="#a23dae54f1aef65189d4b3cf86ababc16">More...</a><br /></td></tr>
<tr class="separator:a23dae54f1aef65189d4b3cf86ababc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae577c0f1290fec5e15d08e818cb7526c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ae577c0f1290fec5e15d08e818cb7526c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ae577c0f1290fec5e15d08e818cb7526c">flat_forward_list_validate</a> (unsigned char const *first, unsigned char const *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:ae577c0f1290fec5e15d08e818cb7526c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="#ae577c0f1290fec5e15d08e818cb7526c">More...</a><br /></td></tr>
<tr class="separator:ae577c0f1290fec5e15d08e818cb7526c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d6f5e151074d2e05b3b3a79e9442b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ae9d6f5e151074d2e05b3b3a79e9442b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ae9d6f5e151074d2e05b3b3a79e9442b5">flat_forward_list_validate</a> (unsigned char *first, unsigned char *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:ae9d6f5e151074d2e05b3b3a79e9442b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="#ae9d6f5e151074d2e05b3b3a79e9442b5">More...</a><br /></td></tr>
<tr class="separator:ae9d6f5e151074d2e05b3b3a79e9442b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b033d750706d5f1127b2559fe7560ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a8b033d750706d5f1127b2559fe7560ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a8b033d750706d5f1127b2559fe7560ec">flat_forward_list_validate</a> (void const *first, void const *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a8b033d750706d5f1127b2559fe7560ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="#a8b033d750706d5f1127b2559fe7560ec">More...</a><br /></td></tr>
<tr class="separator:a8b033d750706d5f1127b2559fe7560ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea923b5cc9b6104200156f3df7931c49"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:aea923b5cc9b6104200156f3df7931c49"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aea923b5cc9b6104200156f3df7931c49">flat_forward_list_validate</a> (void *first, void *<a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a>, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:aea923b5cc9b6104200156f3df7931c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="#aea923b5cc9b6104200156f3df7931c49">More...</a><br /></td></tr>
<tr class="separator:aea923b5cc9b6104200156f3df7931c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd3eeb508b416cd1b2babd413ee3094"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a7dd3eeb508b416cd1b2babd413ee3094"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a7dd3eeb508b416cd1b2babd413ee3094">swap</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;lhs, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7dd3eeb508b416cd1b2babd413ee3094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47edc2d9ad6c13bd5daf398339c503a7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a47edc2d9ad6c13bd5daf398339c503a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a47edc2d9ad6c13bd5daf398339c503a7">begin</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a47edc2d9ad6c13bd5daf398339c503a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bf660549a5277a9fe6c3b748691a70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:ab1bf660549a5277a9fe6c3b748691a70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ab1bf660549a5277a9fe6c3b748691a70">begin</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:ab1bf660549a5277a9fe6c3b748691a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3483d80adcb51f15ad68424b94854b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a5e3483d80adcb51f15ad68424b94854b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a5e3483d80adcb51f15ad68424b94854b">cbegin</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a5e3483d80adcb51f15ad68424b94854b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca996347cdbe2a4522fca54db163341e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:aca996347cdbe2a4522fca54db163341e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">end</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;c) noexcept</td></tr>
<tr class="separator:aca996347cdbe2a4522fca54db163341e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca615bfaaa4c2b7d2248da38e8acdf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a21ca615bfaaa4c2b7d2248da38e8acdf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a21ca615bfaaa4c2b7d2248da38e8acdf">end</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a21ca615bfaaa4c2b7d2248da38e8acdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a4c70fd8e0545da85cfd9d126dd49d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a88a4c70fd8e0545da85cfd9d126dd49d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a88a4c70fd8e0545da85cfd9d126dd49d">cend</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a88a4c70fd8e0545da85cfd9d126dd49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a2f8925bbbeb9f7271df2fb18985eb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a69a2f8925bbbeb9f7271df2fb18985eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a69a2f8925bbbeb9f7271df2fb18985eb">last</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a69a2f8925bbbeb9f7271df2fb18985eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc232774c0c58e5bcead2de64ab4320d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:adc232774c0c58e5bcead2de64ab4320d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#adc232774c0c58e5bcead2de64ab4320d">last</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:adc232774c0c58e5bcead2de64ab4320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868d2563e5cdef40f42d86a40f93a4f5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a868d2563e5cdef40f42d86a40f93a4f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a868d2563e5cdef40f42d86a40f93a4f5">clast</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a868d2563e5cdef40f42d86a40f93a4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a2d40ccf303e60a784cfff4f8ea9a0f0f">swap</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;lhs, <a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;rhs) noexcept(std::allocator_traits&lt; A &gt;::propagate_on_container_swap::value||std::allocator_traits&lt; A &gt;::propagate_on_container_move_assignment::value)</td></tr>
<tr class="separator:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f907eb811c77f049dca024209eed762"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a5f907eb811c77f049dca024209eed762"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a5f907eb811c77f049dca024209eed762">begin</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a5f907eb811c77f049dca024209eed762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14ae5aba5710a855ee30f71497d424b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:ac14ae5aba5710a855ee30f71497d424b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ac14ae5aba5710a855ee30f71497d424b">begin</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:ac14ae5aba5710a855ee30f71497d424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad079ba0fbe009855bd9ded66042ffecb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:ad079ba0fbe009855bd9ded66042ffecb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ad079ba0fbe009855bd9ded66042ffecb">cbegin</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:ad079ba0fbe009855bd9ded66042ffecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92577b98f2f75826d23fe812b7528aee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a92577b98f2f75826d23fe812b7528aee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a92577b98f2f75826d23fe812b7528aee">end</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a92577b98f2f75826d23fe812b7528aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ba70defcf0734c06b5739b5602e8ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a99ba70defcf0734c06b5739b5602e8ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a99ba70defcf0734c06b5739b5602e8ea">end</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a99ba70defcf0734c06b5739b5602e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65241d0538dfc01491dd32e91479526a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a65241d0538dfc01491dd32e91479526a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a65241d0538dfc01491dd32e91479526a">cend</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a65241d0538dfc01491dd32e91479526a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124055658113add932f06206bbd1d0aa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a124055658113add932f06206bbd1d0aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a124055658113add932f06206bbd1d0aa">last</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a124055658113add932f06206bbd1d0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b11ae3383487d038594a8eab32a7d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:ad2b11ae3383487d038594a8eab32a7d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ad2b11ae3383487d038594a8eab32a7d2">last</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:ad2b11ae3383487d038594a8eab32a7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa7fd7260e1286c3bce683e092b86fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a0fa7fd7260e1286c3bce683e092b86fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a0fa7fd7260e1286c3bce683e092b86fa">clast</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a0fa7fd7260e1286c3bce683e092b86fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>intrusive flat forward list </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad67086ee8db08a7b96df7f9759d02a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67086ee8db08a7b96df7f9759d02a1b">&#9670;&nbsp;</a></span>flat_forward_list_const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiffl.html#ad67086ee8db08a7b96df7f9759d02a1b">iffl::flat_forward_list_const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const iterator </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits</td></tr>
  </table>
  </dd>
</dl>
<p>Default initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T </p>

</div>
</div>
<a id="a0cc99c7f27e6b377339364aef8b45b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc99c7f27e6b377339364aef8b45b0c">&#9670;&nbsp;</a></span>flat_forward_list_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">iffl::flat_forward_list_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>non-const iterator </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits</td></tr>
  </table>
  </dd>
</dl>
<p>Default initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T </p>

</div>
</div>
<a id="aed3cdfbfc81a514a8e68df0854789a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3cdfbfc81a514a8e68df0854789a00">&#9670;&nbsp;</a></span>pmr_flat_forward_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiffl.html#aed3cdfbfc81a514a8e68df0854789a00">iffl::pmr_flat_forward_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this typedef if you want to use container with polimorfic allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a47edc2d9ad6c13bd5daf398339c503a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47edc2d9ad6c13bd5daf398339c503a7">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;::iterator iffl::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="ab1bf660549a5277a9fe6c3b748691a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bf660549a5277a9fe6c3b748691a70">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;::const_iterator iffl::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a5f907eb811c77f049dca024209eed762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f907eb811c77f049dca024209eed762">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, A&gt;::iterator iffl::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="ac14ae5aba5710a855ee30f71497d424b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14ae5aba5710a855ee30f71497d424b">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, A&gt;::const_iterator iffl::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a641650e46f9c6138e9358b9b4b4552ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641650e46f9c6138e9358b9b4b4552ff">&#9670;&nbsp;</a></span>cast_to_char_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* iffl::cast_to_char_ptr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to cast a pointer to a char *. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer casted to char * </dd></dl>

</div>
</div>
<a id="a486d006deb665810fd35a6c029472375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486d006deb665810fd35a6c029472375">&#9670;&nbsp;</a></span>cast_to_void_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* iffl::cast_to_void_ptr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to cast a pointer to a void *. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- Buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer casted to void * </dd></dl>

</div>
</div>
<a id="a5e3483d80adcb51f15ad68424b94854b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3483d80adcb51f15ad68424b94854b">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;::const_iterator iffl::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="ad079ba0fbe009855bd9ded66042ffecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad079ba0fbe009855bd9ded66042ffecb">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, A&gt;::const_iterator iffl::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a88a4c70fd8e0545da85cfd9d126dd49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a4c70fd8e0545da85cfd9d126dd49d">&#9670;&nbsp;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;::const_iterator iffl::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a65241d0538dfc01491dd32e91479526a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65241d0538dfc01491dd32e91479526a">&#9670;&nbsp;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, A&gt;::const_iterator iffl::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a868d2563e5cdef40f42d86a40f93a4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868d2563e5cdef40f42d86a40f93a4f5">&#9670;&nbsp;</a></span>clast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;::const_iterator iffl::clast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a0fa7fd7260e1286c3bce683e092b86fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa7fd7260e1286c3bce683e092b86fa">&#9670;&nbsp;</a></span>clast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, A&gt;::const_iterator iffl::clast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="aad07072ae8b15c3cb89c45049f070b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad07072ae8b15c3cb89c45049f070b7c">&#9670;&nbsp;</a></span>copy_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::copy_data </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies length bytes from from_buffer to to_buffer. source and destination buffers cannot overlap </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_buffer</td><td>- Destination buffer. Must be at least length bytes long </td></tr>
    <tr><td class="paramname">from_buffer</td><td>- Source buffer. Must be at least length bytes long </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75de19b348b30c2c9cec77c6ab5d0e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75de19b348b30c2c9cec77c6ab5d0e12">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t iffl::distance </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets "length" consequative bytes of "to_buffer" to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- Destination buffer. </td></tr>
    <tr><td class="paramname">end</td><td>- number of bytes to assign 0 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca996347cdbe2a4522fca54db163341e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca996347cdbe2a4522fca54db163341e">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;::iterator iffl::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a21ca615bfaaa4c2b7d2248da38e8acdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ca615bfaaa4c2b7d2248da38e8acdf">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;::const_iterator iffl::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a92577b98f2f75826d23fe812b7528aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92577b98f2f75826d23fe812b7528aee">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, A&gt;::iterator iffl::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a99ba70defcf0734c06b5739b5602e8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ba70defcf0734c06b5739b5602e8ea">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, A&gt;::const_iterator iffl::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="ac8bf093b969e4bf780b6d0347a942a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bf093b969e4bf780b6d0347a942a2e">&#9670;&nbsp;</a></span>fill_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::fill_buffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets "length" consequative bytes of "to_buffer" to "value". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- Destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>- value we are assigning </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes to assign value to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06bb0b65178106f5fb0634982ec75668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bb0b65178106f5fb0634982ec75668">&#9670;&nbsp;</a></span>flat_forward_list_validate() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt; iffl::flat_forward_list_validate </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>Validates that buffer contains valid flat forward list and returns a pointer to the last element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits. Detaulted to algorithms expects following methods<ul>
<li>get_next_offset</li>
<li>minimum_size</li>
<li>validate specialization flat_forward_list_traits&lt;T&gt; </li>
</ul>
</td></tr>
    <tr><td class="paramname">F</td><td>- functor used to validate element by default uses default_validate_element_fn&lt;T, TT&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- start of buffer we are validating </td></tr>
    <tr><td class="paramname">end</td><td>- first byte pass the buffer we are validation buffer size == end - first </td></tr>
    <tr><td class="paramname">validate_element_fn</td><td>- a functor that is used to validate element. For instance if element contains offset to variable lengths data, it can check that these data are in bound of the buffer. Default dunctor calls TT::validate. You can use <a class="el" href="structiffl_1_1noop__validate__element__fn.html">noop_validate_element_fn</a> if you do not want validate element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;id_valid, last_element_offset&gt; first - result of validation<ul>
<li>true if buffer is null</li>
<li>true if buffer is empty</li>
<li>true if we found a valid element with offset to the next element equals 0</li>
<li>false is all other cases second - pointer to the last valid element<ul>
<li>null if no valid elements were found &lt;true, nullptr&gt; - buffer is NULL or empty It is safe to use iterators. &lt;false, nullptr&gt; - buffer is too small to query next element offset, or offset to next element is pointing beyond end, or element fields validation did not pass. We did not find any entries that pass validation so far. Buffer contains no flat list. &lt;false, ptr&gt; - same as above, but we did found at least one valid element. Buffer contains valid head, but tail is corrupt and have to be either truncated by setting next offset on the last valid element to 0 or if possible by fixing first elements pass the last valid element. &lt;true, ptr&gt; - buffer contains a valid flat forward list, it is safe to use iterators</li>
</ul>
</li>
</ul>
</dd></dl>
<p>When TT has get_next_offset we will use flat_forward_list_validate_has_next_offset, otherwise we call flat_forward_list_validate_no_next_offset</p><ul>
<li>flat_forward_list_validate_has_next_offset stops when next element offset is 0</li>
<li>flat_forward_list_validate_no_next_offset stops when buffer cannot fit next element </li>
</ul>

</div>
</div>
<a id="af3fc601092b4f211fa1369f540d43269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fc601092b4f211fa1369f540d43269">&#9670;&nbsp;</a></span>flat_forward_list_validate() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt; iffl::flat_forward_list_validate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em> = <code><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt;T,&#160;TT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>Overload that takes pointers to element types. </p>

</div>
</div>
<a id="a23dae54f1aef65189d4b3cf86ababc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dae54f1aef65189d4b3cf86ababc16">&#9670;&nbsp;</a></span>flat_forward_list_validate() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt; iffl::flat_forward_list_validate </td>
          <td>(</td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em> = <code><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt;T,&#160;TT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>Overload that takes pointers to element types. </p>

</div>
</div>
<a id="ae577c0f1290fec5e15d08e818cb7526c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae577c0f1290fec5e15d08e818cb7526c">&#9670;&nbsp;</a></span>flat_forward_list_validate() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt; iffl::flat_forward_list_validate </td>
          <td>(</td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em> = <code><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt;T,&#160;TT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>Overload that takes unsigned char const pointers. </p>

</div>
</div>
<a id="ae9d6f5e151074d2e05b3b3a79e9442b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d6f5e151074d2e05b3b3a79e9442b5">&#9670;&nbsp;</a></span>flat_forward_list_validate() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt; iffl::flat_forward_list_validate </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em> = <code><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt;T,&#160;TT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>Overload that takes unsigned char pointers. </p>

</div>
</div>
<a id="a8b033d750706d5f1127b2559fe7560ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b033d750706d5f1127b2559fe7560ec">&#9670;&nbsp;</a></span>flat_forward_list_validate() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt; iffl::flat_forward_list_validate </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em> = <code><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt;T,&#160;TT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>Overload that takes void const pointers. </p>

</div>
</div>
<a id="aea923b5cc9b6104200156f3df7931c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea923b5cc9b6104200156f3df7931c49">&#9670;&nbsp;</a></span>flat_forward_list_validate() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt; iffl::flat_forward_list_validate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em> = <code><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt;T,&#160;TT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>Overload that takes void pointers. </p>

</div>
</div>
<a id="a4283508b0594464b208680293c8fa1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4283508b0594464b208680293c8fa1f5">&#9670;&nbsp;</a></span>flat_forward_list_validate_has_next_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt; iffl::flat_forward_list_validate_has_next_offset </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>flat_forward_list_validate_has_next_offset</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits. Detaulted to specialization flat_forward_list_traits&lt;T&gt; </td></tr>
    <tr><td class="paramname">F</td><td>- functor used to validate element by default uses default_validate_element_fn&lt;T, TT&gt;</td></tr>
  </table>
  </dd>
</dl>
<p>Validates if buffer contains a valid intrusive flat forward list See commment for flat_forward_list_validate. Users are not expected to use this function directly, instead use flat_forward_list_validate, which will call flat_forward_list_validate_has_next_offset if TT::get_next_offset is defined. </p>

</div>
</div>
<a id="ac7f6375903d5162437963a66888259a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f6375903d5162437963a66888259a9">&#9670;&nbsp;</a></span>flat_forward_list_validate_no_next_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; bool, <a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &gt; iffl::flat_forward_list_validate_no_next_offset </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>flat_forward_list_validate_no_next_offset</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits. Detaulted to specialization flat_forward_list_traits&lt;T&gt; </td></tr>
    <tr><td class="paramname">F</td><td>- functor used to validate element by default uses default_validate_element_fn&lt;T, TT&gt;</td></tr>
  </table>
  </dd>
</dl>
<p>Validates if buffer contains a valid intrusive flat forward list See commment for flat_forward_list_validate. Users are not expected to use this function directly, instead prefer to use flat_forward_list_validate, which will call flat_forward_list_validate_no_next_offset if TT::get_next_offset is NOT defined. You can call this function directly IFF TT::get_next_offset is defined, but you want to run validation as if it is not defined. </p>

</div>
</div>
<a id="a69a2f8925bbbeb9f7271df2fb18985eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a2f8925bbbeb9f7271df2fb18985eb">&#9670;&nbsp;</a></span>last() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;::iterator iffl::last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="adc232774c0c58e5bcead2de64ab4320d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc232774c0c58e5bcead2de64ab4320d">&#9670;&nbsp;</a></span>last() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;::const_iterator iffl::last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a124055658113add932f06206bbd1d0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124055658113add932f06206bbd1d0aa">&#9670;&nbsp;</a></span>last() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, A&gt;::iterator iffl::last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="ad2b11ae3383487d038594a8eab32a7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b11ae3383487d038594a8eab32a7d2">&#9670;&nbsp;</a></span>last() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, A&gt;::const_iterator iffl::last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a9b398fb9f25e87b28239b8cd37adc324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b398fb9f25e87b28239b8cd37adc324">&#9670;&nbsp;</a></span>make_scope_guard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto iffl::make_scope_guard </td>
          <td>(</td>
          <td class="paramtype">G &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method for scoped_guard. </p>
<p>Creates an instance of guard given input functor. Helper for lambdas where we do not know name of lambda type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>- type of functor. It is deduced by compiler from parameter type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>- forwarding reference for the functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab18f9699312805dc2f72a5d4a00ef790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18f9699312805dc2f72a5d4a00ef790">&#9670;&nbsp;</a></span>move_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::move_data </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies length bytes from from_buffer to to_buffer. source and destination buffers can overlap </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_buffer</td><td>- Destination buffer. Must be at least length bytes long </td></tr>
    <tr><td class="paramname">from_buffer</td><td>- Source buffer. Must be at least length bytes long </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e326f8ca98ad06d942924c5ffbc63a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e326f8ca98ad06d942924c5ffbc63a3">&#9670;&nbsp;</a></span>ptr_to_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t const iffl::ptr_to_size </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterprets pointer to void value as size_t value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer that value we want to put in size_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of pointer places in size_t </dd></dl>

</div>
</div>
<a id="ab7163004d24a40a5c4880bacb8985e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7163004d24a40a5c4880bacb8985e33">&#9670;&nbsp;</a></span>roundup_ptr_to_alignment() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* iffl::roundup_ptr_to_alignment </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up pointer to specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to round up </td></tr>
    <tr><td class="paramname">alignment</td><td>- alignment we are rounding up to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of pointer rounded up to alignment </dd></dl>

</div>
</div>
<a id="a36e57aa95c52aab88cddd3f6902790ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e57aa95c52aab88cddd3f6902790ee">&#9670;&nbsp;</a></span>roundup_ptr_to_alignment() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* iffl::roundup_ptr_to_alignment </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up pointer to specified alignment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type that alignment we are aligning to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to round up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- pointer rounded up to the type alignment </dd></dl>

</div>
</div>
<a id="a35c092d294aa9443c6d2ed0fe826c060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c092d294aa9443c6d2ed0fe826c060">&#9670;&nbsp;</a></span>roundup_ptr_to_alignment() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void const* iffl::roundup_ptr_to_alignment </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up pointer to specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to round up </td></tr>
    <tr><td class="paramname">alignment</td><td>- alignment we are rounding up to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of pointer rounded up to alignment </dd></dl>

</div>
</div>
<a id="a5efcb4790de0482696257578b53490c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efcb4790de0482696257578b53490c1">&#9670;&nbsp;</a></span>roundup_ptr_to_alignment() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void const* iffl::roundup_ptr_to_alignment </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up pointer to specified alignment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type that alignment we are aligning to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to round up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- pointer rounded up to the type alignment </dd></dl>

</div>
</div>
<a id="a32e6c55d3f8fcdb53f64debbbf4a5c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e6c55d3f8fcdb53f64debbbf4a5c7d">&#9670;&nbsp;</a></span>roundup_size_to_alignment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t iffl::roundup_size_to_alignment </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up size to specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- value to round up </td></tr>
    <tr><td class="paramname">alignment</td><td>- alignment we are rounding up to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of size rounded up to alignment </dd></dl>

</div>
</div>
<a id="aa12acd05702a4128b55949434f988286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12acd05702a4128b55949434f988286">&#9670;&nbsp;</a></span>roundup_size_to_alignment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t iffl::roundup_size_to_alignment </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up size to specified alignment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type that alignment we are aligning to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- value to round up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of size rounded up to the type alignment </dd></dl>

</div>
</div>
<a id="a6467e8b19ddcb0a0a80dce324f2eb9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6467e8b19ddcb0a0a80dce324f2eb9c3">&#9670;&nbsp;</a></span>size_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* const iffl::size_to_ptr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterprets size_t value as pointer to void. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- value that we want to reinterpret as a pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- pointer that contains same value as passed in size parameter </dd></dl>

</div>
</div>
<a id="a7dd3eeb508b416cd1b2babd413ee3094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd3eeb508b416cd1b2babd413ee3094">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>- one of the containers we are swapping between </td></tr>
    <tr><td class="paramname">rhs</td><td>- other container we are swapping between</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a2d40ccf303e60a784cfff4f8ea9a0f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d40ccf303e60a784cfff4f8ea9a0f0f">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type that should be used for this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>- one of the containers we are swapping between </td></tr>
    <tr><td class="paramname">rhs</td><td>- other container we are swapping between</td></tr>
  </table>
  </dd>
</dl>
<p>TT is aefault initialized to specialization of <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a> for T A is default initialized to std::allocator for T </p>

</div>
</div>
<a id="a93ca50887c9840f023931e8b27ccbe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ca50887c9840f023931e8b27ccbe17">&#9670;&nbsp;</a></span>unused_expression_result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void iffl::unused_expression_result </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] T const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Silence sinetizer warning about unused result of expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of unused variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a9d91b46344e59160e070b770d40e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9d91b46344e59160e070b770d40e9f">&#9670;&nbsp;</a></span>unused_variable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void iffl::unused_variable </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] T const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore saved min and max definition. </p>
<p>Silence unused variable warning when both</p><ul>
<li>MSVC: var;</li>
<li>and [[maybe_unused]] do not work <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of unused variable </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a395800a3bee8537b31af93bbba3927ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395800a3bee8537b31af93bbba3927ac">&#9670;&nbsp;</a></span>zero_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::zero_buffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets "length" consequative bytes of "to_buffer" to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- Destination buffer. </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes to assign 0 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

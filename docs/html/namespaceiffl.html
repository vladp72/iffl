<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: iffl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">iffl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>intrusive flat forward list  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceiffl_1_1mpl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl_1_1mpl.html">mpl</a></td></tr>
<tr class="memdesc:namespaceiffl_1_1mpl"><td class="mdescLeft">&#160;</td><td class="mdescRight">intrusive flat forward list <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1as__pointers.html">as_pointers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1attach__buffer.html">attach_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used as a parameter in <a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> constructor to designate that it should take ownership of the buffer rather than make a copy.  <a href="structiffl_1_1attach__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1debug__memory__resource.html">debug_memory_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements std::pmr::memory_resource interface.  <a href="classiffl_1_1debug__memory__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">flat_forward_list_iterator_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits.html">flat_forward_list_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits for an elements that are in the  <a href="structiffl_1_1flat__forward__list__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">flat_forward_list_traits_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits for <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the">flat_forward_list_traits</a>  <a href="structiffl_1_1flat__forward__list__traits__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1noop__validate__element__fn.html">noop_validate_element_fn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1offset__with__aligment.html">offset_with_aligment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that describes an offset in a larger buffer and template parameter that specifies element's type alignment requirements.  <a href="structiffl_1_1offset__with__aligment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that describes a subbuffer in a larger buffer, and portion of that subbuffer actuallu used by the data.  <a href="structiffl_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1range__with__alighment.html">range_with_alighment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that describes a subbuffer in a larger buffer and portion of that subbuffer actuallu used by the data.  <a href="structiffl_1_1range__with__alighment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1scope__guard.html">scope_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template class that can be parametrised with a functor or a lambda that it will call in distructor.  <a href="classiffl_1_1scope__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1size__with__padding.html">size_with_padding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that describes an size and template parameter that specifies element's type alignment requirements.  <a href="structiffl_1_1size__with__padding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1f50ff6d7c734841c0c7d8e009be7be1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1f50ff6d7c734841c0c7d8e009be7be1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a1f50ff6d7c734841c0c7d8e009be7be1">flat_forward_list_iterator</a> = <a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">flat_forward_list_iterator_t</a>&lt; T, TT &gt;</td></tr>
<tr class="separator:a1f50ff6d7c734841c0c7d8e009be7be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace96c3c6ed1ce29a0f02840ce536f390"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ace96c3c6ed1ce29a0f02840ce536f390"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ace96c3c6ed1ce29a0f02840ce536f390">flat_forward_list_const_iterator</a> = <a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">flat_forward_list_iterator_t</a>&lt; std::add_const_t&lt; T &gt;, TT &gt;</td></tr>
<tr class="separator:ace96c3c6ed1ce29a0f02840ce536f390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9817958ce267c5966e43736d9d7aab2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aa9817958ce267c5966e43736d9d7aab2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aa9817958ce267c5966e43736d9d7aab2">pmr_flat_forward_list</a> = <a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, std::pmr::polymorphic_allocator&lt; char &gt; &gt;</td></tr>
<tr class="separator:aa9817958ce267c5966e43736d9d7aab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a74b25575152028e6785daff889608baa"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a74b25575152028e6785daff889608baa">ptr_to_size</a> (void const *const ptr)</td></tr>
<tr class="memdesc:a74b25575152028e6785daff889608baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore saved min and max definition.  <a href="#a74b25575152028e6785daff889608baa">More...</a><br /></td></tr>
<tr class="separator:a74b25575152028e6785daff889608baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42809efec1dceee6007ebca220fe0ba3"><td class="memItemLeft" align="right" valign="top">constexpr void *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a42809efec1dceee6007ebca220fe0ba3">size_to_ptr</a> (size_t size)</td></tr>
<tr class="memdesc:a42809efec1dceee6007ebca220fe0ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterprets size_t value as pointer to void.  <a href="#a42809efec1dceee6007ebca220fe0ba3">More...</a><br /></td></tr>
<tr class="separator:a42809efec1dceee6007ebca220fe0ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e6c55d3f8fcdb53f64debbbf4a5c7d"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a32e6c55d3f8fcdb53f64debbbf4a5c7d">roundup_size_to_alignment</a> (size_t size, size_t alignment) noexcept</td></tr>
<tr class="memdesc:a32e6c55d3f8fcdb53f64debbbf4a5c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up size to specified alignment.  <a href="#a32e6c55d3f8fcdb53f64debbbf4a5c7d">More...</a><br /></td></tr>
<tr class="separator:a32e6c55d3f8fcdb53f64debbbf4a5c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12acd05702a4128b55949434f988286"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa12acd05702a4128b55949434f988286"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aa12acd05702a4128b55949434f988286">roundup_size_to_alignment</a> (size_t size) noexcept</td></tr>
<tr class="memdesc:aa12acd05702a4128b55949434f988286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up size to specified alignment.  <a href="#aa12acd05702a4128b55949434f988286">More...</a><br /></td></tr>
<tr class="separator:aa12acd05702a4128b55949434f988286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2711d44b2c5f29fc8d25a08e5c63cb51"><td class="memItemLeft" align="right" valign="top">constexpr char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a2711d44b2c5f29fc8d25a08e5c63cb51">roundup_ptr_to_alignment</a> (char *ptr, size_t alignment) noexcept</td></tr>
<tr class="memdesc:a2711d44b2c5f29fc8d25a08e5c63cb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up pointer to specified alignment.  <a href="#a2711d44b2c5f29fc8d25a08e5c63cb51">More...</a><br /></td></tr>
<tr class="separator:a2711d44b2c5f29fc8d25a08e5c63cb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1b2db11c2e8779de5ee513948cd9d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad1b2db11c2e8779de5ee513948cd9d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aad1b2db11c2e8779de5ee513948cd9d6">roundup_ptr_to_alignment</a> (char *ptr) noexcept</td></tr>
<tr class="memdesc:aad1b2db11c2e8779de5ee513948cd9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up pointer to specified alignment.  <a href="#aad1b2db11c2e8779de5ee513948cd9d6">More...</a><br /></td></tr>
<tr class="separator:aad1b2db11c2e8779de5ee513948cd9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68beb46a3d4f1531f668d835ecf1328"><td class="memItemLeft" align="right" valign="top">constexpr char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#af68beb46a3d4f1531f668d835ecf1328">roundup_ptr_to_alignment</a> (char const *ptr, size_t alignment) noexcept</td></tr>
<tr class="memdesc:af68beb46a3d4f1531f668d835ecf1328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up pointer to specified alignment.  <a href="#af68beb46a3d4f1531f668d835ecf1328">More...</a><br /></td></tr>
<tr class="separator:af68beb46a3d4f1531f668d835ecf1328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4941a5ebaa9516677bee86d04a191ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4941a5ebaa9516677bee86d04a191ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr char const  *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ac4941a5ebaa9516677bee86d04a191ca">roundup_ptr_to_alignment</a> (char const *ptr) noexcept</td></tr>
<tr class="memdesc:ac4941a5ebaa9516677bee86d04a191ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up pointer to specified alignment.  <a href="#ac4941a5ebaa9516677bee86d04a191ca">More...</a><br /></td></tr>
<tr class="separator:ac4941a5ebaa9516677bee86d04a191ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad07072ae8b15c3cb89c45049f070b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aad07072ae8b15c3cb89c45049f070b7c">copy_data</a> (char *to_buffer, char const *from_buffer, size_t length) noexcept</td></tr>
<tr class="memdesc:aad07072ae8b15c3cb89c45049f070b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies length bytes from from_buffer to to_buffer. source and destination buffers cannot overlap  <a href="#aad07072ae8b15c3cb89c45049f070b7c">More...</a><br /></td></tr>
<tr class="separator:aad07072ae8b15c3cb89c45049f070b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18f9699312805dc2f72a5d4a00ef790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ab18f9699312805dc2f72a5d4a00ef790">move_data</a> (char *to_buffer, char const *from_buffer, size_t length) noexcept</td></tr>
<tr class="memdesc:ab18f9699312805dc2f72a5d4a00ef790"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies length bytes from from_buffer to to_buffer. source and destination buffers can overlap  <a href="#ab18f9699312805dc2f72a5d4a00ef790">More...</a><br /></td></tr>
<tr class="separator:ab18f9699312805dc2f72a5d4a00ef790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bf093b969e4bf780b6d0347a942a2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ac8bf093b969e4bf780b6d0347a942a2e">fill_buffer</a> (char *buffer, int value, size_t length) noexcept</td></tr>
<tr class="memdesc:ac8bf093b969e4bf780b6d0347a942a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets "length" consequative bytes of "to_buffer" to "value".  <a href="#ac8bf093b969e4bf780b6d0347a942a2e">More...</a><br /></td></tr>
<tr class="separator:ac8bf093b969e4bf780b6d0347a942a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395800a3bee8537b31af93bbba3927ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a395800a3bee8537b31af93bbba3927ac">zero_buffer</a> (char *buffer, size_t length) noexcept</td></tr>
<tr class="memdesc:a395800a3bee8537b31af93bbba3927ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets "length" consequative bytes of "to_buffer" to 0.  <a href="#a395800a3bee8537b31af93bbba3927ac">More...</a><br /></td></tr>
<tr class="separator:a395800a3bee8537b31af93bbba3927ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b398fb9f25e87b28239b8cd37adc324"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a9b398fb9f25e87b28239b8cd37adc324"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a9b398fb9f25e87b28239b8cd37adc324">make_scope_guard</a> (G &amp;&amp;g)</td></tr>
<tr class="memdesc:a9b398fb9f25e87b28239b8cd37adc324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for scoped_guard.  <a href="#a9b398fb9f25e87b28239b8cd37adc324">More...</a><br /></td></tr>
<tr class="separator:a9b398fb9f25e87b28239b8cd37adc324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08282dc6d83606cfa21360ac38a5e4d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a08282dc6d83606cfa21360ac38a5e4d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, char const * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a08282dc6d83606cfa21360ac38a5e4d3">flat_forward_list_validate_has_next_offset</a> (char const *first, char const *end, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a08282dc6d83606cfa21360ac38a5e4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae920385401594f97333a170134baab29"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ae920385401594f97333a170134baab29"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, char const * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ae920385401594f97333a170134baab29">flat_forward_list_validate_no_next_offset</a> (char const *first, char const *end, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:ae920385401594f97333a170134baab29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc441db8c5aefecefdb749acc8b5c50f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:acc441db8c5aefecefdb749acc8b5c50f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, char const * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#acc441db8c5aefecefdb749acc8b5c50f">flat_forward_list_validate</a> (char const *first, char const *end, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:acc441db8c5aefecefdb749acc8b5c50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f0f5df34bd62ac61a3189f5d00ea76"><td class="memTemplParams" colspan="2"><a id="af2f0f5df34bd62ac61a3189f5d00ea76"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:af2f0f5df34bd62ac61a3189f5d00ea76"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, char * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_forward_list_validate</b> (char *first, char *end, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:af2f0f5df34bd62ac61a3189f5d00ea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb393ce6af1821a62c00872ee48d1b6"><td class="memTemplParams" colspan="2"><a id="a6fb393ce6af1821a62c00872ee48d1b6"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a6fb393ce6af1821a62c00872ee48d1b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_forward_list_validate</b> (T *first, T *end, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a6fb393ce6af1821a62c00872ee48d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0217b57f9962ee4b4b7629c552ee6f2b"><td class="memTemplParams" colspan="2"><a id="a0217b57f9962ee4b4b7629c552ee6f2b"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a0217b57f9962ee4b4b7629c552ee6f2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, unsigned char const  * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_forward_list_validate</b> (unsigned char const *first, unsigned char const *end, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a0217b57f9962ee4b4b7629c552ee6f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419a43a96964addc4215c3263150040e"><td class="memTemplParams" colspan="2"><a id="a419a43a96964addc4215c3263150040e"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a419a43a96964addc4215c3263150040e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, unsigned char * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_forward_list_validate</b> (unsigned char *first, unsigned char *end, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a419a43a96964addc4215c3263150040e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade435bc052f680dc17f75a8df38a25af"><td class="memTemplParams" colspan="2"><a id="ade435bc052f680dc17f75a8df38a25af"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ade435bc052f680dc17f75a8df38a25af"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, void const  * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_forward_list_validate</b> (void const *first, void const *end, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:ade435bc052f680dc17f75a8df38a25af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4dfb7b898662166e9d42f5fd0b7bb1"><td class="memTemplParams" colspan="2"><a id="a9c4dfb7b898662166e9d42f5fd0b7bb1"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a9c4dfb7b898662166e9d42f5fd0b7bb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, void * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_forward_list_validate</b> (void *first, void *end, F const &amp;validate_element_fn=<a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a9c4dfb7b898662166e9d42f5fd0b7bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memTemplParams" colspan="2"><a id="a2d40ccf303e60a784cfff4f8ea9a0f0f"></a>
template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;lhs, <a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; T, TT, A &gt; &amp;rhs) noexcept(std::allocator_traits&lt; A &gt;::propagate_on_container_swap::value||std::allocator_traits&lt; A &gt;::propagate_on_container_move_assignment::value)</td></tr>
<tr class="separator:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>intrusive flat forward list </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ace96c3c6ed1ce29a0f02840ce536f390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace96c3c6ed1ce29a0f02840ce536f390">&#9670;&nbsp;</a></span>flat_forward_list_const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceiffl.html#ace96c3c6ed1ce29a0f02840ce536f390">iffl::flat_forward_list_const_iterator</a> = typedef <a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">flat_forward_list_iterator_t</a>&lt; std::add_const_t&lt;T&gt;, TT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>const_iteartor </p>

</div>
</div>
<a id="a1f50ff6d7c734841c0c7d8e009be7be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f50ff6d7c734841c0c7d8e009be7be1">&#9670;&nbsp;</a></span>flat_forward_list_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceiffl.html#a1f50ff6d7c734841c0c7d8e009be7be1">iffl::flat_forward_list_iterator</a> = typedef <a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">flat_forward_list_iterator_t</a>&lt;T, TT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>non-const iterator </p>

</div>
</div>
<a id="aa9817958ce267c5966e43736d9d7aab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9817958ce267c5966e43736d9d7aab2">&#9670;&nbsp;</a></span>pmr_flat_forward_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceiffl.html#aa9817958ce267c5966e43736d9d7aab2">iffl::pmr_flat_forward_list</a> = typedef <a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt;T, TT, std::pmr::polymorphic_allocator&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this typedef if you want to use container with polimorfic allocator </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aad07072ae8b15c3cb89c45049f070b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad07072ae8b15c3cb89c45049f070b7c">&#9670;&nbsp;</a></span>copy_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::copy_data </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies length bytes from from_buffer to to_buffer. source and destination buffers cannot overlap </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_buffer</td><td>- Destination buffer. Must be at least length bytes long </td></tr>
    <tr><td class="paramname">from_buffer</td><td>- Source buffer. Must be at least length bytes long </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8bf093b969e4bf780b6d0347a942a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bf093b969e4bf780b6d0347a942a2e">&#9670;&nbsp;</a></span>fill_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::fill_buffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets "length" consequative bytes of "to_buffer" to "value". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- Destination buffer. </td></tr>
    <tr><td class="paramname">value</td><td>- value we are assigning </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes to assign value to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc441db8c5aefecefdb749acc8b5c50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc441db8c5aefecefdb749acc8b5c50f">&#9670;&nbsp;</a></span>flat_forward_list_validate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt;bool, char const *&gt; iffl::flat_forward_list_validate </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em> = <code><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt;T,&#160;TT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validates that buffer contains valid flat forward list and returns a pointer to the last element.</p>
<p>Template parameters: T - type of element header TT - type trait for T. algorithms expects following methods</p><ul>
<li>get_next_offset</li>
<li>minimum_size</li>
<li>validate F - functor type that should be used to validate element data.</li>
</ul>
<p>Note: When TT has get_next_offset we will use flat_forward_list_validate_has_next_offset, otherwise we call flat_forward_list_validate_no_next_offset</p><ul>
<li>flat_forward_list_validate_has_next_offset stops when next element offset is 0</li>
<li>flat_forward_list_validate_no_next_offset stops when buffer cannot fit next element</li>
</ul>
<p>Input: first - start of buffer we are validating end - first byte pass the buffer we are validation buffer size == end - first validate_element_fn - a functor that is used to validate element. For instance if element contains offset to variable lengths data, it can check that these data are in bound of the buffer. Default dunctor calls TT::validate. You can use <a class="el" href="structiffl_1_1noop__validate__element__fn.html">noop_validate_element_fn</a> if you do not want validate element</p>
<p>Output: pair first - result of validation</p><ul>
<li>true if buffer is null</li>
<li>true if buffer is empty</li>
<li>true if we found a valid element with offset to the next element equals 0</li>
<li>false is all other cases second - pointer to the last valid element<ul>
<li>null if no valid elements were found</li>
</ul>
</li>
</ul>
<p>Examples: &lt;true, nullptr&gt; - buffer is NULL or empty It is safe to use iterators. &lt;false, nullptr&gt; - buffer is too small to query next element offset, or offset to next element is pointing beyond end, or element fields validation did not pass. We did not find any entries that pass validation so far. Buffer contains no flat list. &lt;false, ptr&gt; - same as above, but we did found at least one valid element. Buffer contains valid head, but tail is corrupt and have to be either truncated by setting next offset on the last valid element to 0 or if possible by fixing first elements pass the last valid element. &lt;true, ptr&gt; - buffer contains a valid flat forward list, it is safe to use iterators </p>

</div>
</div>
<a id="a08282dc6d83606cfa21360ac38a5e4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08282dc6d83606cfa21360ac38a5e4d3">&#9670;&nbsp;</a></span>flat_forward_list_validate_has_next_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt;bool, char const *&gt; iffl::flat_forward_list_validate_has_next_offset </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em> = <code><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt;T,&#160;TT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See below commment for flat_forward_list_validate. Users are not expected to use this function directly, instead use flat_forward_list_validate, which will call flat_forward_list_validate_has_next_offset if TT::get_next_offset is defined. </p>

</div>
</div>
<a id="ae920385401594f97333a170134baab29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae920385401594f97333a170134baab29">&#9670;&nbsp;</a></span>flat_forward_list_validate_no_next_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt;bool, char const *&gt; iffl::flat_forward_list_validate_no_next_offset </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>validate_element_fn</em> = <code><a class="el" href="structiffl_1_1default__validate__element__fn.html">default_validate_element_fn</a>&lt;T,&#160;TT&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See below commment for flat_forward_list_validate. Users are not expected to use this function directly, instead prefer to use flat_forward_list_validate, which will call flat_forward_list_validate_no_next_offset if TT::get_next_offset is NOT defined.</p>
<p>You can call this function directly IFF TT::get_next_offset is defined, but you want to run validation as if it is not defined. </p>

</div>
</div>
<a id="a9b398fb9f25e87b28239b8cd37adc324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b398fb9f25e87b28239b8cd37adc324">&#9670;&nbsp;</a></span>make_scope_guard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto iffl::make_scope_guard </td>
          <td>(</td>
          <td class="paramtype">G &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method for scoped_guard. </p>
<p>Creates an instance of guard given input functor. Helper for lambdas where we do not know name of lambda type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>- type of functor. It is deduced by compiler from parameter type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>- forwarding reference for the functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab18f9699312805dc2f72a5d4a00ef790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18f9699312805dc2f72a5d4a00ef790">&#9670;&nbsp;</a></span>move_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::move_data </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies length bytes from from_buffer to to_buffer. source and destination buffers can overlap </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_buffer</td><td>- Destination buffer. Must be at least length bytes long </td></tr>
    <tr><td class="paramname">from_buffer</td><td>- Source buffer. Must be at least length bytes long </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74b25575152028e6785daff889608baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b25575152028e6785daff889608baa">&#9670;&nbsp;</a></span>ptr_to_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t iffl::ptr_to_size </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore saved min and max definition. </p>
<p>Reinterprets pointer to void value as size_t value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer that value we want to put in size_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of pointer places in size_t </dd></dl>

</div>
</div>
<a id="a2711d44b2c5f29fc8d25a08e5c63cb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2711d44b2c5f29fc8d25a08e5c63cb51">&#9670;&nbsp;</a></span>roundup_ptr_to_alignment() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char* iffl::roundup_ptr_to_alignment </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up pointer to specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to round up </td></tr>
    <tr><td class="paramname">alignment</td><td>- alignment we are rounding up to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of pointer rounded up to alignment </dd></dl>

</div>
</div>
<a id="aad1b2db11c2e8779de5ee513948cd9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1b2db11c2e8779de5ee513948cd9d6">&#9670;&nbsp;</a></span>roundup_ptr_to_alignment() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char* iffl::roundup_ptr_to_alignment </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up pointer to specified alignment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type that alignment we are aligning to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to round up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- pointer rounded up to the type alignment </dd></dl>

</div>
</div>
<a id="af68beb46a3d4f1531f668d835ecf1328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68beb46a3d4f1531f668d835ecf1328">&#9670;&nbsp;</a></span>roundup_ptr_to_alignment() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char const* iffl::roundup_ptr_to_alignment </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up pointer to specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to round up </td></tr>
    <tr><td class="paramname">alignment</td><td>- alignment we are rounding up to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of pointer rounded up to alignment </dd></dl>

</div>
</div>
<a id="ac4941a5ebaa9516677bee86d04a191ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4941a5ebaa9516677bee86d04a191ca">&#9670;&nbsp;</a></span>roundup_ptr_to_alignment() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char const* iffl::roundup_ptr_to_alignment </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up pointer to specified alignment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type that alignment we are aligning to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to round up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- pointer rounded up to the type alignment </dd></dl>

</div>
</div>
<a id="a32e6c55d3f8fcdb53f64debbbf4a5c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e6c55d3f8fcdb53f64debbbf4a5c7d">&#9670;&nbsp;</a></span>roundup_size_to_alignment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t iffl::roundup_size_to_alignment </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up size to specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- value to round up </td></tr>
    <tr><td class="paramname">alignment</td><td>- alignment we are rounding up to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of size rounded up to alignment </dd></dl>

</div>
</div>
<a id="aa12acd05702a4128b55949434f988286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12acd05702a4128b55949434f988286">&#9670;&nbsp;</a></span>roundup_size_to_alignment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t iffl::roundup_size_to_alignment </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up size to specified alignment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type that alignment we are aligning to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- value to round up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- value of size rounded up to the type alignment </dd></dl>

</div>
</div>
<a id="a42809efec1dceee6007ebca220fe0ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42809efec1dceee6007ebca220fe0ba3">&#9670;&nbsp;</a></span>size_to_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void* const iffl::size_to_ptr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterprets size_t value as pointer to void. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- value that we want to reinterpret as a pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- pointer that contains same value as passed in size parameter </dd></dl>

</div>
</div>
<a id="a395800a3bee8537b31af93bbba3927ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395800a3bee8537b31af93bbba3927ac">&#9670;&nbsp;</a></span>zero_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::zero_buffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets "length" consequative bytes of "to_buffer" to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- Destination buffer. </td></tr>
    <tr><td class="paramname">length</td><td>- number of bytes to assign 0 to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

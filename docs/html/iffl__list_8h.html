<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: include/iffl_list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">iffl_list.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements intrusive flat forward list.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="iffl__config_8h_source.html">iffl_config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="iffl__common_8h_source.html">iffl_common.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="iffl__mpl_8h_source.html">iffl_mpl.h</a>&gt;</code><br />
</div>
<p><a href="iffl__list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits.html">iffl::flat_forward_list_traits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits for an elements that are in the  <a href="structiffl_1_1flat__forward__list__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits&lt; TT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits for <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the">flat_forward_list_traits</a>  <a href="structiffl_1_1flat__forward__list__traits__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1default__validate__element__fn.html">iffl::default_validate_element_fn&lt; T, TT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1noop__validate__element__fn.html">iffl::noop_validate_element_fn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">iffl::flat_forward_list_iterator_t&lt; T, TT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list&lt; T, TT, A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceiffl_1_1mpl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl_1_1mpl.html">iffl::mpl</a></td></tr>
<tr class="memdesc:namespaceiffl_1_1mpl"><td class="mdescLeft">&#160;</td><td class="mdescRight">intrusive flat forward list <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceiffl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html">iffl</a></td></tr>
<tr class="memdesc:namespaceiffl"><td class="mdescLeft">&#160;</td><td class="mdescRight">intrusive flat forward list <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1f50ff6d7c734841c0c7d8e009be7be1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1f50ff6d7c734841c0c7d8e009be7be1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a1f50ff6d7c734841c0c7d8e009be7be1">iffl::flat_forward_list_iterator</a> = flat_forward_list_iterator_t&lt; T, TT &gt;</td></tr>
<tr class="separator:a1f50ff6d7c734841c0c7d8e009be7be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace96c3c6ed1ce29a0f02840ce536f390"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ace96c3c6ed1ce29a0f02840ce536f390"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ace96c3c6ed1ce29a0f02840ce536f390">iffl::flat_forward_list_const_iterator</a> = flat_forward_list_iterator_t&lt; std::add_const_t&lt; T &gt;, TT &gt;</td></tr>
<tr class="separator:ace96c3c6ed1ce29a0f02840ce536f390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9817958ce267c5966e43736d9d7aab2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aa9817958ce267c5966e43736d9d7aab2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aa9817958ce267c5966e43736d9d7aab2">iffl::pmr_flat_forward_list</a> = flat_forward_list&lt; T, TT, std::pmr::polymorphic_allocator&lt; char &gt; &gt;</td></tr>
<tr class="separator:aa9817958ce267c5966e43736d9d7aab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a08282dc6d83606cfa21360ac38a5e4d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a08282dc6d83606cfa21360ac38a5e4d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, char const * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a08282dc6d83606cfa21360ac38a5e4d3">iffl::flat_forward_list_validate_has_next_offset</a> (char const *first, char const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a08282dc6d83606cfa21360ac38a5e4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae920385401594f97333a170134baab29"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ae920385401594f97333a170134baab29"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, char const * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ae920385401594f97333a170134baab29">iffl::flat_forward_list_validate_no_next_offset</a> (char const *first, char const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:ae920385401594f97333a170134baab29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc441db8c5aefecefdb749acc8b5c50f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:acc441db8c5aefecefdb749acc8b5c50f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, char const * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#acc441db8c5aefecefdb749acc8b5c50f">iffl::flat_forward_list_validate</a> (char const *first, char const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:acc441db8c5aefecefdb749acc8b5c50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f0f5df34bd62ac61a3189f5d00ea76"><td class="memTemplParams" colspan="2"><a id="af2f0f5df34bd62ac61a3189f5d00ea76"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:af2f0f5df34bd62ac61a3189f5d00ea76"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, char * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iffl::flat_forward_list_validate</b> (char *first, char *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:af2f0f5df34bd62ac61a3189f5d00ea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb393ce6af1821a62c00872ee48d1b6"><td class="memTemplParams" colspan="2"><a id="a6fb393ce6af1821a62c00872ee48d1b6"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a6fb393ce6af1821a62c00872ee48d1b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iffl::flat_forward_list_validate</b> (T *first, T *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a6fb393ce6af1821a62c00872ee48d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0217b57f9962ee4b4b7629c552ee6f2b"><td class="memTemplParams" colspan="2"><a id="a0217b57f9962ee4b4b7629c552ee6f2b"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a0217b57f9962ee4b4b7629c552ee6f2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, unsigned char const  * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iffl::flat_forward_list_validate</b> (unsigned char const *first, unsigned char const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a0217b57f9962ee4b4b7629c552ee6f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419a43a96964addc4215c3263150040e"><td class="memTemplParams" colspan="2"><a id="a419a43a96964addc4215c3263150040e"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a419a43a96964addc4215c3263150040e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, unsigned char * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iffl::flat_forward_list_validate</b> (unsigned char *first, unsigned char *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a419a43a96964addc4215c3263150040e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade435bc052f680dc17f75a8df38a25af"><td class="memTemplParams" colspan="2"><a id="ade435bc052f680dc17f75a8df38a25af"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ade435bc052f680dc17f75a8df38a25af"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, void const  * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iffl::flat_forward_list_validate</b> (void const *first, void const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:ade435bc052f680dc17f75a8df38a25af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4dfb7b898662166e9d42f5fd0b7bb1"><td class="memTemplParams" colspan="2"><a id="a9c4dfb7b898662166e9d42f5fd0b7bb1"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a9c4dfb7b898662166e9d42f5fd0b7bb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, void * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iffl::flat_forward_list_validate</b> (void *first, void *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="separator:a9c4dfb7b898662166e9d42f5fd0b7bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memTemplParams" colspan="2"><a id="a2d40ccf303e60a784cfff4f8ea9a0f0f"></a>
template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iffl::swap</b> (flat_forward_list&lt; T, TT, A &gt; &amp;lhs, flat_forward_list&lt; T, TT, A &gt; &amp;rhs) noexcept(std::allocator_traits&lt; A &gt;::propagate_on_container_swap::value||std::allocator_traits&lt; A &gt;::propagate_on_container_move_assignment::value)</td></tr>
<tr class="separator:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements intrusive flat forward list. </p>
<dl class="section author"><dt>Author</dt><dd>Vladimir Petter</dd></dl>
<p><a href="https://github.com/vladp72/iffl">iffl github</a></p>
<p>This container is designed for POD types with following general structure: </p><div class="fragment"><div class="line">                     ------------------------------------------------------------</div><div class="line">                     |                                                          |</div><div class="line">                     |                                                          V</div><div class="line">| &lt;fields&gt; | offset to next element | &lt;offsets of data&gt; | [data] | [padding] || [next element] ...</div><div class="line">|                        header                         | [data] | [padding] || [next element] ...</div></div><!-- fragment --><p>Examples:</p>
<p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_file_full_ea_information">FILE_FULL_EA_INFORMATION</a> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_FILE_FULL_EA_INFORMATION {</div><div class="line">    ULONG  NextEntryOffset;</div><div class="line">    UCHAR  Flags;</div><div class="line">    UCHAR  EaNameLength;</div><div class="line">    USHORT EaValueLength;</div><div class="line">    CHAR   EaName[1];</div><div class="line">} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;</div></div><!-- fragment --><p> <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-_file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION</a> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_FILE_NOTIFY_EXTENDED_INFORMATION {</div><div class="line">    DWORD         NextEntryOffset;</div><div class="line">    DWORD         Action;</div><div class="line">    LARGE_INTEGER CreationTime;</div><div class="line">    LARGE_INTEGER LastModificationTime;</div><div class="line">    LARGE_INTEGER LastChangeTime;</div><div class="line">    LARGE_INTEGER LastAccessTime;</div><div class="line">    LARGE_INTEGER AllocatedLength;</div><div class="line">    LARGE_INTEGER FileSize;</div><div class="line">    DWORD         FileAttributes;</div><div class="line">    DWORD         ReparsePointTag;</div><div class="line">    LARGE_INTEGER FileId;</div><div class="line">    LARGE_INTEGER ParentFileId;</div><div class="line">    DWORD         FileNameLength;</div><div class="line">    WCHAR         FileName[1];</div><div class="line">} FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;</div></div><!-- fragment --><p> <a href="https://msdn.microsoft.com/en-us/8f02e824-ca41-48c1-a5e8-5b12d81886b5">FILE_INFO_BY_HANDLE_CLASS</a> output for the following information classes </p><div class="fragment"><div class="line">FileIdBothDirectoryInfo</div><div class="line">FileIdBothDirectoryRestartInfo</div><div class="line">FileIoPriorityHintInfo</div><div class="line">FileRemoteProtocolInfo</div><div class="line">FileFullDirectoryInfo</div><div class="line">FileFullDirectoryRestartInfo</div><div class="line">FileStorageInfo</div><div class="line">FileAlignmentInfo</div><div class="line">FileIdInfo</div><div class="line">FileIdExtdDirectoryInfo</div><div class="line">FileIdExtdDirectoryRestartInfo</div></div><!-- fragment --><p>Output of <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/ns-ntifs-_file_both_dir_information">NtQueryDirectoryFile</a> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_FILE_BOTH_DIR_INFORMATION {</div><div class="line">    ULONG         NextEntryOffset;</div><div class="line">    ULONG         FileIndex;</div><div class="line">    LARGE_INTEGER CreationTime;</div><div class="line">    LARGE_INTEGER LastAccessTime;</div><div class="line">    LARGE_INTEGER LastWriteTime;</div><div class="line">    LARGE_INTEGER ChangeTime;</div><div class="line">    LARGE_INTEGER EndOfFile;</div><div class="line">    LARGE_INTEGER AllocationSize;</div><div class="line">    ULONG         FileAttributes;</div><div class="line">    ULONG         FileNameLength;</div><div class="line">    ULONG         EaSize;</div><div class="line">    CCHAR         ShortNameLength;</div><div class="line">    WCHAR         ShortName[12];</div><div class="line">    WCHAR         FileName[1];</div><div class="line">} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;</div></div><!-- fragment --><p>Or types that do not have next element offset, but it can be calculated.</p>
<p>Offset of the next element is size of this element data, plus optional padding to keep next element propertly alligned </p><div class="fragment"><div class="line">                     -----------------------------------</div><div class="line">                     |                                 |</div><div class="line">                     |                                 V</div><div class="line">| &lt;fields&gt; | &lt;offsets of data&gt; | [data] | [padding] || [next element] ...</div><div class="line">|       header                 | [data] | [padding] || [next element] ...</div></div><!-- fragment --><p> Exanmples:</p>
<p>CLUSPROP_SYNTAX <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/property-lists">property list</a></p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/data-structures">data structures</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/clusapi/ns-clusapi-clusprop_syntax">cluster property syntax</a></p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span>CLUSPROP_SYNTAX {</div><div class="line">  DWORD  dw;</div><div class="line">  <span class="keyword">struct </span>{</div><div class="line">      WORD wFormat;</div><div class="line">      WORD wType;</div><div class="line">  } DUMMYSTRUCTNAME;</div><div class="line">} CLUSPROP_SYNTAX;</div></div><!-- fragment --><p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/clusapi/ns-clusapi-clusprop_value">CLUSPROP_VALUE</a> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>CLUSPROP_VALUE {</div><div class="line">    CLUSPROP_SYNTAX Syntax;</div><div class="line">    DWORD           cbLength;</div><div class="line">} CLUSPROP_VALUE;</div></div><!-- fragment --><p>This module implements</p>
<p>function flat_forward_list_validate that can be use to deal with untrusted buffers. You can use it to validate if untrusted buffer contains a valid list, and to find entry at which list gets invalid. It also can be used to enumerate over validated elements.</p>
<p>flat_forward_list_iterator and flat_forward_list_const_iterator that can be used to enumerate over previously validated buffer.</p>
<p>flat_forward_list a container that provides a set of helper algorithms and manages buffer lifetime while list changes.</p>
<p>pmr_flat_forward_list is a an aliase of flat_forward_list where allocator is polimorfic_allocator.</p>
<p>Interface that user have to implement for a type that will be stored in the container:</p>
<p>Since we are implementing intrusive container, user have to give us a helper class that implements folowing methods</p><ul>
<li>Specifies alignment requirements for the type <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> <span class="keyword">const</span> alignment{ TYPE_ALIGNMENT }; </div></div><!-- fragment --></li>
<li>tell minimum required size am element must have to be able to query element size <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> minimum_size() noexcept </div></div><!-- fragment --></li>
<li>query offset to next element <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> get_next_offset(<span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept </div></div><!-- fragment --></li>
<li>update offset to the next element <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">void</span> set_next_offset(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> size) noexcept </div></div><!-- fragment --></li>
<li>calculate element size from data <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> get_size(<span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept </div></div><!-- fragment --></li>
<li>validate that data fit into the buffer <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">bool</span> validate(<span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept </div></div><!-- fragment --></li>
</ul>
<p>By default algorithms and conteiners in this library are looking for specialization of flat_forward_list_traits for the element type. For example: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceiffl.html">iffl</a> {</div><div class="line">    <span class="keyword">template</span> &lt;&gt;</div><div class="line">    <span class="keyword">struct </span>flat_forward_list_traits&lt;FLAT_FORWARD_LIST_TEST&gt; {</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> <span class="keyword">const</span> alignment{ TYPE_ALIGNMENT };</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> minimum_size() noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> get_next_offset(<span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">void</span> set_next_offset(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> size) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> get_size(<span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">bool</span> validate(<span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept {&lt;implementation&gt;}</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>for sample implementation see flat_forward_list_traits&lt;FLAT_FORWARD_LIST_TEST&gt; @ test\iffl_test_cases.cpp and addition documetation in this mode right before primary template for flat_forward_list_traits definition</p>
<p>If picking traits using partial specialization is not preferable then traits can be passed as an explicit template parameter. For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> ffl_iterator = <a class="code" href="classiffl_1_1flat__forward__list__iterator__t.html">iffl::flat_forward_list_iterator&lt;FLAT_FORWARD_LIST_TEST, my_traits&gt;</a>;</div></div><!-- fragment --><p> Debugging:</p>
<p>if you define FFL_DBG_CHECK_DATA_VALID then every method that modifies data in container will call flat_forward_list_validate at the end and makes sure that data are valid, and last element is where container believes it should be. Cost O(n).</p>
<p>If you define FFL_DBG_CHECK_ITERATOR_VALID then every input iterator will be cheked to match to valid element in the container. Cost O(n)</p>
<p>You can use debug_memory_resource and pmr_flat_forward_list to validate that all allocations are freed and that there are no buffer overruns/underruns </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

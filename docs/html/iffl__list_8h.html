<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: include/iffl_list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">iffl_list.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements intrusive flat forward list.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="iffl__config_8h_source.html">iffl_config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="iffl__common_8h_source.html">iffl_common.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="iffl__mpl_8h_source.html">iffl_mpl.h</a>&gt;</code><br />
</div>
<p><a href="iffl__list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits.html">iffl::flat_forward_list_traits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits for an elements that are in the flat forward list  <a href="structiffl_1_1flat__forward__list__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits&lt; T, TT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits for <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">flat_forward_list_traits</a>  <a href="structiffl_1_1flat__forward__list__traits__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list&lt; T, TT, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive flat forward list container.  <a href="classiffl_1_1flat__forward__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref&lt; T, TT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non owning container for flat forward list.  <a href="classiffl_1_1flat__forward__list__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1default__validate__element__fn.html">iffl::default_validate_element_fn&lt; T, TT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1noop__validate__element__fn.html">iffl::noop_validate_element_fn&lt; T, TT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__iterator__t.html">iffl::flat_forward_list_iterator_t&lt; T, TT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">THis class implements forward iterator for intrusive flat forward list.  <a href="classiffl_1_1flat__forward__list__iterator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref&lt; T, TT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non owning container for flat forward list.  <a href="classiffl_1_1flat__forward__list__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list.html">iffl::flat_forward_list&lt; T, TT, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive flat forward list container.  <a href="classiffl_1_1flat__forward__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceiffl_1_1mpl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl_1_1mpl.html">iffl::mpl</a></td></tr>
<tr class="memdesc:namespaceiffl_1_1mpl"><td class="mdescLeft">&#160;</td><td class="mdescRight">intrusive flat forward list <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceiffl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiffl.html">iffl</a></td></tr>
<tr class="memdesc:namespaceiffl"><td class="mdescLeft">&#160;</td><td class="mdescRight">intrusive flat forward list <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0cc99c7f27e6b377339364aef8b45b0c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a0cc99c7f27e6b377339364aef8b45b0c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">iffl::flat_forward_list_iterator</a> = flat_forward_list_iterator_t&lt; T, TT &gt;</td></tr>
<tr class="memdesc:a0cc99c7f27e6b377339364aef8b45b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const iterator  <a href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">More...</a><br /></td></tr>
<tr class="separator:a0cc99c7f27e6b377339364aef8b45b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67086ee8db08a7b96df7f9759d02a1b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ad67086ee8db08a7b96df7f9759d02a1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ad67086ee8db08a7b96df7f9759d02a1b">iffl::flat_forward_list_const_iterator</a> = flat_forward_list_iterator_t&lt; std::add_const_t&lt; T &gt;, TT &gt;</td></tr>
<tr class="memdesc:ad67086ee8db08a7b96df7f9759d02a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator  <a href="namespaceiffl.html#ad67086ee8db08a7b96df7f9759d02a1b">More...</a><br /></td></tr>
<tr class="separator:ad67086ee8db08a7b96df7f9759d02a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df220d9126052279a6c8c6cd3e482a"><td class="memTemplParams" colspan="2"><a id="a06df220d9126052279a6c8c6cd3e482a"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a06df220d9126052279a6c8c6cd3e482a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a06df220d9126052279a6c8c6cd3e482a">iffl::flat_forward_list_view</a> = flat_forward_list_ref&lt; T const, TT &gt;</td></tr>
<tr class="memdesc:a06df220d9126052279a6c8c6cd3e482a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant view to flat forward list. <br /></td></tr>
<tr class="separator:a06df220d9126052279a6c8c6cd3e482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3cdfbfc81a514a8e68df0854789a00"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aed3cdfbfc81a514a8e68df0854789a00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aed3cdfbfc81a514a8e68df0854789a00">iffl::pmr_flat_forward_list</a> = flat_forward_list&lt; T, TT, FFL_PMR::polymorphic_allocator&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:aed3cdfbfc81a514a8e68df0854789a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this typedef if you want to use container with polimorfic allocator.  <a href="namespaceiffl.html#aed3cdfbfc81a514a8e68df0854789a00">More...</a><br /></td></tr>
<tr class="separator:aed3cdfbfc81a514a8e68df0854789a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4283508b0594464b208680293c8fa1f5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a4283508b0594464b208680293c8fa1f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a4283508b0594464b208680293c8fa1f5">iffl::flat_forward_list_validate_has_next_offset</a> (char const *first, char const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a4283508b0594464b208680293c8fa1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="namespaceiffl.html#a4283508b0594464b208680293c8fa1f5">More...</a><br /></td></tr>
<tr class="separator:a4283508b0594464b208680293c8fa1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f6375903d5162437963a66888259a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ac7f6375903d5162437963a66888259a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ac7f6375903d5162437963a66888259a9">iffl::flat_forward_list_validate_no_next_offset</a> (char const *first, char const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:ac7f6375903d5162437963a66888259a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="namespaceiffl.html#ac7f6375903d5162437963a66888259a9">More...</a><br /></td></tr>
<tr class="separator:ac7f6375903d5162437963a66888259a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bb0b65178106f5fb0634982ec75668"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a06bb0b65178106f5fb0634982ec75668"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a06bb0b65178106f5fb0634982ec75668">iffl::flat_forward_list_validate</a> (char const *first, char const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a06bb0b65178106f5fb0634982ec75668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="namespaceiffl.html#a06bb0b65178106f5fb0634982ec75668">More...</a><br /></td></tr>
<tr class="separator:a06bb0b65178106f5fb0634982ec75668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae26253c6bd5e08b98229024e59dd2"><td class="memTemplParams" colspan="2"><a id="a2fae26253c6bd5e08b98229024e59dd2"></a>
template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a2fae26253c6bd5e08b98229024e59dd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a2fae26253c6bd5e08b98229024e59dd2">iffl::flat_forward_list_validate</a> (char *first, char *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a2fae26253c6bd5e08b98229024e59dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration. <br /></td></tr>
<tr class="separator:a2fae26253c6bd5e08b98229024e59dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fc601092b4f211fa1369f540d43269"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:af3fc601092b4f211fa1369f540d43269"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#af3fc601092b4f211fa1369f540d43269">iffl::flat_forward_list_validate</a> (T *first, T *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:af3fc601092b4f211fa1369f540d43269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="namespaceiffl.html#af3fc601092b4f211fa1369f540d43269">More...</a><br /></td></tr>
<tr class="separator:af3fc601092b4f211fa1369f540d43269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dae54f1aef65189d4b3cf86ababc16"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a23dae54f1aef65189d4b3cf86ababc16"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a23dae54f1aef65189d4b3cf86ababc16">iffl::flat_forward_list_validate</a> (T const *first, T const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a23dae54f1aef65189d4b3cf86ababc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="namespaceiffl.html#a23dae54f1aef65189d4b3cf86ababc16">More...</a><br /></td></tr>
<tr class="separator:a23dae54f1aef65189d4b3cf86ababc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae577c0f1290fec5e15d08e818cb7526c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ae577c0f1290fec5e15d08e818cb7526c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ae577c0f1290fec5e15d08e818cb7526c">iffl::flat_forward_list_validate</a> (unsigned char const *first, unsigned char const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:ae577c0f1290fec5e15d08e818cb7526c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="namespaceiffl.html#ae577c0f1290fec5e15d08e818cb7526c">More...</a><br /></td></tr>
<tr class="separator:ae577c0f1290fec5e15d08e818cb7526c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d6f5e151074d2e05b3b3a79e9442b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:ae9d6f5e151074d2e05b3b3a79e9442b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ae9d6f5e151074d2e05b3b3a79e9442b5">iffl::flat_forward_list_validate</a> (unsigned char *first, unsigned char *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:ae9d6f5e151074d2e05b3b3a79e9442b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="namespaceiffl.html#ae9d6f5e151074d2e05b3b3a79e9442b5">More...</a><br /></td></tr>
<tr class="separator:ae9d6f5e151074d2e05b3b3a79e9442b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b033d750706d5f1127b2559fe7560ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:a8b033d750706d5f1127b2559fe7560ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a8b033d750706d5f1127b2559fe7560ec">iffl::flat_forward_list_validate</a> (void const *first, void const *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:a8b033d750706d5f1127b2559fe7560ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="namespaceiffl.html#a8b033d750706d5f1127b2559fe7560ec">More...</a><br /></td></tr>
<tr class="separator:a8b033d750706d5f1127b2559fe7560ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea923b5cc9b6104200156f3df7931c49"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT  = flat_forward_list_traits&lt;T&gt;, typename F  = default_validate_element_fn&lt;T, TT&gt;&gt; </td></tr>
<tr class="memitem:aea923b5cc9b6104200156f3df7931c49"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; bool, flat_forward_list_ref&lt; T, TT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aea923b5cc9b6104200156f3df7931c49">iffl::flat_forward_list_validate</a> (void *first, void *end, F const &amp;validate_element_fn=default_validate_element_fn&lt; T, TT &gt;{}) noexcept</td></tr>
<tr class="memdesc:aea923b5cc9b6104200156f3df7931c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="namespaceiffl.html#aea923b5cc9b6104200156f3df7931c49">More...</a><br /></td></tr>
<tr class="separator:aea923b5cc9b6104200156f3df7931c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd3eeb508b416cd1b2babd413ee3094"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a7dd3eeb508b416cd1b2babd413ee3094"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a7dd3eeb508b416cd1b2babd413ee3094">iffl::swap</a> (flat_forward_list_ref&lt; T, TT &gt; &amp;lhs, flat_forward_list_ref&lt; T, TT &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7dd3eeb508b416cd1b2babd413ee3094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47edc2d9ad6c13bd5daf398339c503a7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a47edc2d9ad6c13bd5daf398339c503a7"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list_ref&lt; T, TT &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a47edc2d9ad6c13bd5daf398339c503a7">iffl::begin</a> (flat_forward_list_ref&lt; T, TT &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a47edc2d9ad6c13bd5daf398339c503a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bf660549a5277a9fe6c3b748691a70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:ab1bf660549a5277a9fe6c3b748691a70"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list_ref&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ab1bf660549a5277a9fe6c3b748691a70">iffl::begin</a> (flat_forward_list_ref&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:ab1bf660549a5277a9fe6c3b748691a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3483d80adcb51f15ad68424b94854b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a5e3483d80adcb51f15ad68424b94854b"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list_ref&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a5e3483d80adcb51f15ad68424b94854b">iffl::cbegin</a> (flat_forward_list_ref&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a5e3483d80adcb51f15ad68424b94854b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca996347cdbe2a4522fca54db163341e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:aca996347cdbe2a4522fca54db163341e"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list_ref&lt; T, TT &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#aca996347cdbe2a4522fca54db163341e">iffl::end</a> (flat_forward_list_ref&lt; T, TT &gt; &amp;c) noexcept</td></tr>
<tr class="separator:aca996347cdbe2a4522fca54db163341e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca615bfaaa4c2b7d2248da38e8acdf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a21ca615bfaaa4c2b7d2248da38e8acdf"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list_ref&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a21ca615bfaaa4c2b7d2248da38e8acdf">iffl::end</a> (flat_forward_list_ref&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a21ca615bfaaa4c2b7d2248da38e8acdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a4c70fd8e0545da85cfd9d126dd49d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a88a4c70fd8e0545da85cfd9d126dd49d"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list_ref&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a88a4c70fd8e0545da85cfd9d126dd49d">iffl::cend</a> (flat_forward_list_ref&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a88a4c70fd8e0545da85cfd9d126dd49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a2f8925bbbeb9f7271df2fb18985eb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a69a2f8925bbbeb9f7271df2fb18985eb"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list_ref&lt; T, TT &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a69a2f8925bbbeb9f7271df2fb18985eb">iffl::last</a> (flat_forward_list_ref&lt; T, TT &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a69a2f8925bbbeb9f7271df2fb18985eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc232774c0c58e5bcead2de64ab4320d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:adc232774c0c58e5bcead2de64ab4320d"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list_ref&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#adc232774c0c58e5bcead2de64ab4320d">iffl::last</a> (flat_forward_list_ref&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:adc232774c0c58e5bcead2de64ab4320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868d2563e5cdef40f42d86a40f93a4f5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT &gt; </td></tr>
<tr class="memitem:a868d2563e5cdef40f42d86a40f93a4f5"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list_ref&lt; T, TT &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a868d2563e5cdef40f42d86a40f93a4f5">iffl::clast</a> (flat_forward_list_ref&lt; T, TT &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a868d2563e5cdef40f42d86a40f93a4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a2d40ccf303e60a784cfff4f8ea9a0f0f">iffl::swap</a> (flat_forward_list&lt; T, TT, A &gt; &amp;lhs, flat_forward_list&lt; T, TT, A &gt; &amp;rhs) noexcept(std::allocator_traits&lt; A &gt;::propagate_on_container_swap::value||std::allocator_traits&lt; A &gt;::propagate_on_container_move_assignment::value)</td></tr>
<tr class="separator:a2d40ccf303e60a784cfff4f8ea9a0f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f907eb811c77f049dca024209eed762"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a5f907eb811c77f049dca024209eed762"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list&lt; T, TT, A &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a5f907eb811c77f049dca024209eed762">iffl::begin</a> (flat_forward_list&lt; T, TT, A &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a5f907eb811c77f049dca024209eed762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14ae5aba5710a855ee30f71497d424b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:ac14ae5aba5710a855ee30f71497d424b"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ac14ae5aba5710a855ee30f71497d424b">iffl::begin</a> (flat_forward_list&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:ac14ae5aba5710a855ee30f71497d424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad079ba0fbe009855bd9ded66042ffecb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:ad079ba0fbe009855bd9ded66042ffecb"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ad079ba0fbe009855bd9ded66042ffecb">iffl::cbegin</a> (flat_forward_list&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:ad079ba0fbe009855bd9ded66042ffecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92577b98f2f75826d23fe812b7528aee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a92577b98f2f75826d23fe812b7528aee"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list&lt; T, TT, A &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a92577b98f2f75826d23fe812b7528aee">iffl::end</a> (flat_forward_list&lt; T, TT, A &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a92577b98f2f75826d23fe812b7528aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ba70defcf0734c06b5739b5602e8ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a99ba70defcf0734c06b5739b5602e8ea"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a99ba70defcf0734c06b5739b5602e8ea">iffl::end</a> (flat_forward_list&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a99ba70defcf0734c06b5739b5602e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65241d0538dfc01491dd32e91479526a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a65241d0538dfc01491dd32e91479526a"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a65241d0538dfc01491dd32e91479526a">iffl::cend</a> (flat_forward_list&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a65241d0538dfc01491dd32e91479526a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124055658113add932f06206bbd1d0aa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a124055658113add932f06206bbd1d0aa"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list&lt; T, TT, A &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a124055658113add932f06206bbd1d0aa">iffl::last</a> (flat_forward_list&lt; T, TT, A &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a124055658113add932f06206bbd1d0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b11ae3383487d038594a8eab32a7d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:ad2b11ae3383487d038594a8eab32a7d2"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#ad2b11ae3383487d038594a8eab32a7d2">iffl::last</a> (flat_forward_list&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:ad2b11ae3383487d038594a8eab32a7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa7fd7260e1286c3bce683e092b86fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TT , typename A &gt; </td></tr>
<tr class="memitem:a0fa7fd7260e1286c3bce683e092b86fa"><td class="memTemplItemLeft" align="right" valign="top">flat_forward_list&lt; T, TT, A &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceiffl.html#a0fa7fd7260e1286c3bce683e092b86fa">iffl::clast</a> (flat_forward_list&lt; T, TT, A &gt; const &amp;c) noexcept</td></tr>
<tr class="separator:a0fa7fd7260e1286c3bce683e092b86fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements intrusive flat forward list. </p>
<dl class="section author"><dt>Author</dt><dd>Vladimir Petter</dd></dl>
<p><a href="https://github.com/vladp72/iffl">iffl github</a></p>
<p>This container is designed for POD types with following general structure: </p><div class="fragment"><div class="line">                     ------------------------------------------------------------</div><div class="line">                     |                                                          |</div><div class="line">                     |                                                          V</div><div class="line">| &lt;fields&gt; | offset to next element | &lt;offsets of data&gt; | [data] | [padding] || [next element] ...</div><div class="line">|                        header                         | [data] | [padding] || [next element] ...</div></div><!-- fragment --><p>Examples:</p>
<p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_file_full_ea_information">FILE_FULL_EA_INFORMATION</a> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_FILE_FULL_EA_INFORMATION {</div><div class="line">    ULONG  NextEntryOffset;</div><div class="line">    UCHAR  Flags;</div><div class="line">    UCHAR  EaNameLength;</div><div class="line">    USHORT EaValueLength;</div><div class="line">    CHAR   EaName[1];</div><div class="line">} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;</div></div><!-- fragment --><p> <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-_file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION</a> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_FILE_NOTIFY_EXTENDED_INFORMATION {</div><div class="line">    DWORD         NextEntryOffset;</div><div class="line">    DWORD         Action;</div><div class="line">    LARGE_INTEGER CreationTime;</div><div class="line">    LARGE_INTEGER LastModificationTime;</div><div class="line">    LARGE_INTEGER LastChangeTime;</div><div class="line">    LARGE_INTEGER LastAccessTime;</div><div class="line">    LARGE_INTEGER AllocatedLength;</div><div class="line">    LARGE_INTEGER FileSize;</div><div class="line">    DWORD         FileAttributes;</div><div class="line">    DWORD         ReparsePointTag;</div><div class="line">    LARGE_INTEGER FileId;</div><div class="line">    LARGE_INTEGER ParentFileId;</div><div class="line">    DWORD         FileNameLength;</div><div class="line">    WCHAR         FileName[1];</div><div class="line">} FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;</div></div><!-- fragment --><p> <a href="https://msdn.microsoft.com/en-us/8f02e824-ca41-48c1-a5e8-5b12d81886b5">FILE_INFO_BY_HANDLE_CLASS</a> output for the following information classes </p><div class="fragment"><div class="line">FileIdBothDirectoryInfo</div><div class="line">FileIdBothDirectoryRestartInfo</div><div class="line">FileIoPriorityHintInfo</div><div class="line">FileRemoteProtocolInfo</div><div class="line">FileFullDirectoryInfo</div><div class="line">FileFullDirectoryRestartInfo</div><div class="line">FileStorageInfo</div><div class="line">FileAlignmentInfo</div><div class="line">FileIdInfo</div><div class="line">FileIdExtdDirectoryInfo</div><div class="line">FileIdExtdDirectoryRestartInfo</div></div><!-- fragment --><p>Output of <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/ns-ntifs-_file_both_dir_information">NtQueryDirectoryFile</a> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_FILE_BOTH_DIR_INFORMATION {</div><div class="line">    ULONG         NextEntryOffset;</div><div class="line">    ULONG         FileIndex;</div><div class="line">    LARGE_INTEGER CreationTime;</div><div class="line">    LARGE_INTEGER LastAccessTime;</div><div class="line">    LARGE_INTEGER LastWriteTime;</div><div class="line">    LARGE_INTEGER ChangeTime;</div><div class="line">    LARGE_INTEGER EndOfFile;</div><div class="line">    LARGE_INTEGER AllocationSize;</div><div class="line">    ULONG         FileAttributes;</div><div class="line">    ULONG         FileNameLength;</div><div class="line">    ULONG         EaSize;</div><div class="line">    CCHAR         ShortNameLength;</div><div class="line">    WCHAR         ShortName[12];</div><div class="line">    WCHAR         FileName[1];</div><div class="line">} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;</div></div><!-- fragment --><p>Or types that do not have next element offset, but it can be calculated.</p>
<p>Offset of the next element is size of this element data, plus optional padding to keep next element propertly alligned </p><div class="fragment"><div class="line">                     -----------------------------------</div><div class="line">                     |                                 |</div><div class="line">    (next element offset = <span class="keyword">sizeof</span>(<span class="keyword">this</span> element)        |</div><div class="line">                     |   + padding)                    |</div><div class="line">                     |                                 V</div><div class="line">| &lt;fields&gt; | &lt;offsets of data&gt; | [data] | [padding] || [next element] ...</div><div class="line">|       header                 | [data] | [padding] || [next element] ...</div></div><!-- fragment --><p> Exanmples:</p>
<p>CLUSPROP_SYNTAX <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/property-lists">property list</a></p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/data-structures">data structures</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/clusapi/ns-clusapi-clusprop_syntax">cluster property syntax</a></p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span>CLUSPROP_SYNTAX {</div><div class="line">  DWORD  dw;</div><div class="line">  <span class="keyword">struct </span>{</div><div class="line">      WORD wFormat;</div><div class="line">      WORD wType;</div><div class="line">  } DUMMYSTRUCTNAME;</div><div class="line">} CLUSPROP_SYNTAX;</div></div><!-- fragment --><p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/clusapi/ns-clusapi-clusprop_value">CLUSPROP_VALUE</a> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>CLUSPROP_VALUE {</div><div class="line">    CLUSPROP_SYNTAX Syntax;</div><div class="line">    DWORD           cbLength;</div><div class="line">} CLUSPROP_VALUE;</div></div><!-- fragment --><p>This module implements</p>
<p>function flat_forward_list_validate that can be use to deal with untrusted buffers. You can use it to validate if untrusted buffer contains a valid list, and to find entry at which list gets invalid. It also can be used to enumerate over validated elements.</p>
<p>flat_forward_list_iterator and flat_forward_list_const_iterator that can be used to enumerate over previously validated buffer.</p>
<p>flat_forward_list a container that provides a set of helper algorithms and manages buffer lifetime while list changes.</p>
<p>pmr_flat_forward_list is a an aliase of flat_forward_list where allocator is polimorfic_allocator.</p>
<p>Interface that user have to implement for a type that will be stored in the container:</p>
<p>Since we are implementing intrusive container, user have to give us a helper class that implements folowing methods</p><ul>
<li>Specifies alignment requirements for the type <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> <span class="keyword">const</span> alignment{ TYPE_ALIGNMENT }; </div></div><!-- fragment --></li>
<li>tell minimum required size am element must have to be able to query element size <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> minimum_size() noexcept </div></div><!-- fragment --></li>
<li>query offset to next element <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> get_next_offset(<span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept </div></div><!-- fragment --></li>
<li>update offset to the next element <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">void</span> set_next_offset(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> size) noexcept </div></div><!-- fragment --></li>
<li>calculate element size from data <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> get_size(<span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept </div></div><!-- fragment --></li>
<li>validate that data fit into the buffer <div class="fragment"><div class="line">constexpr <span class="keyword">static</span> <span class="keywordtype">bool</span> validate(<span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept </div></div><!-- fragment --></li>
</ul>
<p>By default algorithms and conteiners in this library are looking for specialization of flat_forward_list_traits for the element type. For example: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceiffl.html">iffl</a> {</div><div class="line">    <span class="keyword">template</span> &lt;&gt;</div><div class="line">    <span class="keyword">struct </span>flat_forward_list_traits&lt;FLAT_FORWARD_LIST_TEST&gt; {</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> <span class="keyword">const</span> alignment{ TYPE_ALIGNMENT };</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> minimum_size() noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> get_next_offset(<span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">void</span> set_next_offset(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> size) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">size_t</span> get_size(<span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr <span class="keyword">static</span> <span class="keywordtype">bool</span> validate(<span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">char</span> <span class="keyword">const</span> *buffer) noexcept {&lt;implementation&gt;}</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>for sample implementation see flat_forward_list_traits&lt;FLAT_FORWARD_LIST_TEST&gt; @ test\iffl_test_cases.cpp and addition documetation in this mode right before primary template for flat_forward_list_traits definition</p>
<p>If picking traits using partial specialization is not preferable then traits can be passed as an explicit template parameter. For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> ffl_iterator = <a class="code" href="classiffl_1_1flat__forward__list__iterator__t.html">iffl::flat_forward_list_iterator&lt;FLAT_FORWARD_LIST_TEST, my_traits&gt;</a>;</div></div><!-- fragment --><p> Debugging:</p>
<p>if you define FFL_DBG_CHECK_DATA_VALID then every method that modifies data in container will call flat_forward_list_validate at the end and makes sure that data are valid, and last element is where container believes it should be. Cost O(n).</p>
<p>If you define FFL_DBG_CHECK_ITERATOR_VALID then every input iterator will be cheked to match to valid element in the container. Cost O(n)</p>
<p>You can use debug_memory_resource and pmr_flat_forward_list to validate that all allocations are freed and that there are no buffer overruns/underruns </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

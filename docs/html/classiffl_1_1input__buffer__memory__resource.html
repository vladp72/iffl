<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: iffl::input_buffer_memory_resource Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceiffl.html">iffl</a></li><li class="navelem"><a class="el" href="classiffl_1_1input__buffer__memory__resource.html">input_buffer_memory_resource</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classiffl_1_1input__buffer__memory__resource-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iffl::input_buffer_memory_resource Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>implements std::pmr::memory_resource interface.  
 <a href="classiffl_1_1input__buffer__memory__resource.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iffl__allocator_8h_source.html">iffl_allocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for iffl::input_buffer_memory_resource:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classiffl_1_1input__buffer__memory__resource.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1e67818b78585ebeeb8e277e52300219"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1input__buffer__memory__resource.html#a1e67818b78585ebeeb8e277e52300219">input_buffer_memory_resource</a> (void *buffer, size_t buffer_size) noexcept</td></tr>
<tr class="memdesc:a1e67818b78585ebeeb8e277e52300219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs memory resource with information about buffer that should be used for allocation.  <a href="#a1e67818b78585ebeeb8e277e52300219">More...</a><br /></td></tr>
<tr class="separator:a1e67818b78585ebeeb8e277e52300219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cf8ccbff1a4e762129410fa3efbace"><td class="memItemLeft" align="right" valign="top"><a id="a40cf8ccbff1a4e762129410fa3efbace"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1input__buffer__memory__resource.html#a40cf8ccbff1a4e762129410fa3efbace">~input_buffer_memory_resource</a> () noexcept</td></tr>
<tr class="memdesc:a40cf8ccbff1a4e762129410fa3efbace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor verifies that there are no outstanding allocations. <br /></td></tr>
<tr class="separator:a40cf8ccbff1a4e762129410fa3efbace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dd59c0c172c71e4fc13b71f2080b69"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1input__buffer__memory__resource.html#aa4dd59c0c172c71e4fc13b71f2080b69">get_busy_blocks_count</a> () const noexcept</td></tr>
<tr class="memdesc:aa4dd59c0c172c71e4fc13b71f2080b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to query number of outstanding allocations.  <a href="#aa4dd59c0c172c71e4fc13b71f2080b69">More...</a><br /></td></tr>
<tr class="separator:aa4dd59c0c172c71e4fc13b71f2080b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a3f4559c0891b0993c88e9f59c10c4"><td class="memItemLeft" align="right" valign="top"><a id="a22a3f4559c0891b0993c88e9f59c10c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1input__buffer__memory__resource.html#a22a3f4559c0891b0993c88e9f59c10c4">validate_no_busy_blocks</a> () const noexcept</td></tr>
<tr class="memdesc:a22a3f4559c0891b0993c88e9f59c10c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers fail fast if there are outstanding allocations. <br /></td></tr>
<tr class="separator:a22a3f4559c0891b0993c88e9f59c10c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa7df8cad423f4fcdc0cb9e2b420548a9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1input__buffer__memory__resource.html#aa7df8cad423f4fcdc0cb9e2b420548a9">do_allocate</a> (size_t bytes, size_t alignment) override</td></tr>
<tr class="memdesc:aa7df8cad423f4fcdc0cb9e2b420548a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides memory resource virtual method that performs allocation.  <a href="#aa7df8cad423f4fcdc0cb9e2b420548a9">More...</a><br /></td></tr>
<tr class="separator:aa7df8cad423f4fcdc0cb9e2b420548a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0773a1e829b86a8853749d7f09c3e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1input__buffer__memory__resource.html#ac0773a1e829b86a8853749d7f09c3e52">do_deallocate</a> (void *p, size_t bytes, size_t alignment) noexcept override</td></tr>
<tr class="memdesc:ac0773a1e829b86a8853749d7f09c3e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides memory resource virtual method that performs deallocation.  <a href="#ac0773a1e829b86a8853749d7f09c3e52">More...</a><br /></td></tr>
<tr class="separator:ac0773a1e829b86a8853749d7f09c3e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d630e0212c871020e83419ff6a616c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1input__buffer__memory__resource.html#a6d630e0212c871020e83419ff6a616c4">do_is_equal</a> (memory_resource const &amp;other) const noexcept override</td></tr>
<tr class="memdesc:a6d630e0212c871020e83419ff6a616c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates that two memory resources are equivalent. For this class they must be equal.  <a href="#a6d630e0212c871020e83419ff6a616c4">More...</a><br /></td></tr>
<tr class="separator:a6d630e0212c871020e83419ff6a616c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>implements std::pmr::memory_resource interface. </p>
<p>This class can be used with Polimorfic Memory Allocator. Forward Linked List has typedef for PMR called pmr_flat_forward_list. This memory resource allows constructing flat forward list on a buffer owned by someone else.</p>
<p>This memory resource can be instantiated to point to a buffer that is owned elsewhere. Using this memory resource you can allocate buffer to a single owned Consequent allocations will throw bad_alloc until buffer is deallcoated. On deallocation it checks that deallocated buffer is the same as allocation buffer. It will fail-fast on mismatch. Deallocated buffer can be allocated again. Deallocation does not free the buffer. It is assumed that buffer is owned by someone else.</p>
<p>Sample usage:</p>
<p>In the below example memory resource is instantiated to point to the input buffer. Container is parametrized to use this memory resource. We resize container buffer to consume entire input buffer in one allocation. After that we keep appending data to the container try_* methods that would not attempt to reallocate larger buffer, and consequently are noexcept as long as caller's functor does not throw. Instead they return false when buffer cannot fit new element. Once a try_* function returns false, we know that buffer is filled, and we can exit. To let caller know how much of the buffer was filled with data we will set output_size to the size of part of the buffer used by the inserted elements. Optionally, if we want caller to adopt buffer without verification, we can return offset to the last element in the buffer. Container destructor will deallocate memory back to resource. Memory resource destructor will detach from the buffer. Buffer content remains untached, and still contains a valid list. Once method returns, caller can examine buffer using flat forward list reference or view or attach it to the container with allocator compatibe to how buffer was allocated.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> build_result(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">size_t</span> *output_size) {</div><div class="line">    <a class="code" href="classiffl_1_1input__buffer__memory__resource.html">iffl::input_buffer_memory_resource</a> buffer_memory_resource{buffer, buffer_size};</div><div class="line">    <a class="code" href="classiffl_1_1flat__forward__list.html">iffl::pmr_flat_forward_list&lt;FLAT_FORWARD_LIST_TEST&gt;</a> ffl{ &amp;buffer_memory_resource };</div><div class="line">    ffl.<a class="code" href="classiffl_1_1flat__forward__list.html#a6ae342f90c0c6a7f6cf215f913691fa4">resize_buffer</a>(buffer_size);</div><div class="line">    <span class="keywordflow">for</span>(;;) {</div><div class="line">        <span class="keywordflow">if</span>(!ffl.try_push_back(&lt;data&gt;, &lt;data_size&gt;) {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    *output_size = ffl.used_capacity();</div><div class="line">}</div></div><!-- fragment --><p>Thread safety:</p>
<p>This class is not thread safe and cannot be used to perform concurent allocations from multiple threads. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1e67818b78585ebeeb8e277e52300219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e67818b78585ebeeb8e277e52300219">&#9670;&nbsp;</a></span>input_buffer_memory_resource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iffl::input_buffer_memory_resource::input_buffer_memory_resource </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs memory resource with information about buffer that should be used for allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to the buffer that we will return on allocation </td></tr>
    <tr><td class="paramname">buffer_size</td><td>- size of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa7df8cad423f4fcdc0cb9e2b420548a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7df8cad423f4fcdc0cb9e2b420548a9">&#9670;&nbsp;</a></span>do_allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* iffl::input_buffer_memory_resource::do_allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides memory resource virtual method that performs allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>- number of bytes to be allocated. </td></tr>
    <tr><td class="paramname">alignment</td><td>- alignment requirements for the allocated buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocation fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success return a pointer to the buffer of requested size. On failure throws std::bad_alloc. </dd></dl>

</div>
</div>
<a id="ac0773a1e829b86a8853749d7f09c3e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0773a1e829b86a8853749d7f09c3e52">&#9670;&nbsp;</a></span>do_deallocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iffl::input_buffer_memory_resource::do_deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides memory resource virtual method that performs deallocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- pointer to the user buffer that is deallocated. </td></tr>
    <tr><td class="paramname">bytes</td><td>- buffer size. Mast match to the size that was allocated. </td></tr>
    <tr><td class="paramname">alignment</td><td>- alignment of the buffer. Must match to alignment at allocation time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. Checks buffer that buffer was allocated, and that deallocated buffer match to the buffer that we own. Triggers fail fast if check does not pass. </dd></dl>

</div>
</div>
<a id="a6d630e0212c871020e83419ff6a616c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d630e0212c871020e83419ff6a616c4">&#9670;&nbsp;</a></span>do_is_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iffl::input_buffer_memory_resource::do_is_equal </td>
          <td>(</td>
          <td class="paramtype">memory_resource const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates that two memory resources are equivalent. For this class they must be equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- reference to the other memory resource. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if other memory resource is the same object, and false otherwise. </dd></dl>

</div>
</div>
<a id="aa4dd59c0c172c71e4fc13b71f2080b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4dd59c0c172c71e4fc13b71f2080b69">&#9670;&nbsp;</a></span>get_busy_blocks_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t iffl::input_buffer_memory_resource::get_busy_blocks_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used to query number of outstanding allocations. </p>
<dl class="section return"><dt>Returns</dt><dd>number of outstanding allocations </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="iffl__allocator_8h_source.html">iffl_allocator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

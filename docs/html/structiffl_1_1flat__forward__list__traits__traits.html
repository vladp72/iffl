<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: iffl::flat_forward_list_traits_traits&lt; TT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceiffl.html">iffl</a></li><li class="navelem"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">flat_forward_list_traits_traits</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structiffl_1_1flat__forward__list__traits__traits-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iffl::flat_forward_list_traits_traits&lt; TT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>traits for <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the">flat_forward_list_traits</a>  
 <a href="structiffl_1_1flat__forward__list__traits__traits.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iffl__list_8h_source.html">iffl_list.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2c7bb0eb41f0e88bf417fd49f535d904"><td class="memItemLeft" align="right" valign="top"><a id="a2c7bb0eb41f0e88bf417fd49f535d904"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>type_traits</b> = TT</td></tr>
<tr class="separator:a2c7bb0eb41f0e88bf417fd49f535d904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf334257fc91f2db91473e9298c85245"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#aaf334257fc91f2db91473e9298c85245">has_minimum_size_t</a> = <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a>&lt; has_minimum_size_mfn, type_traits &gt;</td></tr>
<tr class="separator:aaf334257fc91f2db91473e9298c85245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeefbd9e550a81b9cb19c2dae755d6f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#afeefbd9e550a81b9cb19c2dae755d6f1">has_get_size_t</a> = <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a>&lt; has_get_size_mfn, type_traits &gt;</td></tr>
<tr class="separator:afeefbd9e550a81b9cb19c2dae755d6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca58aac8fb21dd3ee2be704bab92ed8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#acca58aac8fb21dd3ee2be704bab92ed8">has_next_offset_t</a> = <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a>&lt; has_next_offset_mfn, type_traits &gt;</td></tr>
<tr class="separator:acca58aac8fb21dd3ee2be704bab92ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e9945972bafae6479211448952245a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#ad0e9945972bafae6479211448952245a">can_set_next_offset_t</a> = <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a>&lt; can_set_next_offset_mfn, type_traits &gt;</td></tr>
<tr class="separator:ad0e9945972bafae6479211448952245a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e95398875258da24ffc1f9556962531"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#a1e95398875258da24ffc1f9556962531">can_validate_t</a> = <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a>&lt; can_validate_mfn, type_traits &gt;</td></tr>
<tr class="separator:a1e95398875258da24ffc1f9556962531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f2d3437212d2e091f259743f6d5448"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#a77f2d3437212d2e091f259743f6d5448">has_alignment_t</a> = <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a>&lt; has_alignment_mfn, type_traits &gt;</td></tr>
<tr class="separator:a77f2d3437212d2e091f259743f6d5448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af391b7538840fe6cde22ad6130d7b806"><td class="memItemLeft" align="right" valign="top"><a id="af391b7538840fe6cde22ad6130d7b806"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>range_t</b> = <a class="el" href="structiffl_1_1range__with__alighment.html">range_with_alighment</a>&lt; alignment &gt;</td></tr>
<tr class="separator:af391b7538840fe6cde22ad6130d7b806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44d1aae0d21707b9dedc09cb09313e9"><td class="memItemLeft" align="right" valign="top"><a id="aa44d1aae0d21707b9dedc09cb09313e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_with_padding_t</b> = <a class="el" href="structiffl_1_1size__with__padding.html">size_with_padding</a>&lt; alignment &gt;</td></tr>
<tr class="separator:aa44d1aae0d21707b9dedc09cb09313e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a87e98b68fd4ea5be3a63495cb4cfb4"><td class="memItemLeft" align="right" valign="top"><a id="a7a87e98b68fd4ea5be3a63495cb4cfb4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>offset_with_aligment_t</b> = <a class="el" href="structiffl_1_1offset__with__aligment.html">offset_with_aligment</a>&lt; alignment &gt;</td></tr>
<tr class="separator:a7a87e98b68fd4ea5be3a63495cb4cfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9de26b3d77ac24bd161409f50c8d89fb"><td class="memItemLeft" align="right" valign="top"><a id="a9de26b3d77ac24bd161409f50c8d89fb"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>minimum_size</b> () noexcept</td></tr>
<tr class="separator:a9de26b3d77ac24bd161409f50c8d89fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b04725bc83f2016c5de44f844521937"><td class="memItemLeft" align="right" valign="top"><a id="a5b04725bc83f2016c5de44f844521937"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_alignment</b> () noexcept</td></tr>
<tr class="separator:a5b04725bc83f2016c5de44f844521937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619b601da2eb1a2fa55664db2dd857fb"><td class="memItemLeft" align="right" valign="top"><a id="a619b601da2eb1a2fa55664db2dd857fb"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>roundup_to_alignment</b> (size_t s) noexcept</td></tr>
<tr class="separator:a619b601da2eb1a2fa55664db2dd857fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7fb2211cbe5c87e79dcbb964b0a64c"><td class="memItemLeft" align="right" valign="top"><a id="a6c7fb2211cbe5c87e79dcbb964b0a64c"></a>
static constexpr <a class="el" href="structiffl_1_1size__with__padding.html">size_with_padding_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_size</b> (char const *buffer) noexcept</td></tr>
<tr class="separator:a6c7fb2211cbe5c87e79dcbb964b0a64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07f0493befe4419703714d53a4e8260"><td class="memItemLeft" align="right" valign="top"><a id="ab07f0493befe4419703714d53a4e8260"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>validate</b> (size_t buffer_size, char const *buffer) noexcept</td></tr>
<tr class="separator:ab07f0493befe4419703714d53a4e8260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ff3cec75c5ef3da8b37602eb21ab46"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structiffl_1_1offset__with__aligment.html">offset_with_aligment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#ae9ff3cec75c5ef3da8b37602eb21ab46">get_next_offset_ex</a> (char const *buffer) noexcept</td></tr>
<tr class="separator:ae9ff3cec75c5ef3da8b37602eb21ab46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bd33757d170ad44881c9e5cf8a5db4"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#ab1bd33757d170ad44881c9e5cf8a5db4">get_next_offset</a> (char const *buffer) noexcept</td></tr>
<tr class="separator:ab1bd33757d170ad44881c9e5cf8a5db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae578d68dfd27c9b5f82cbf7cd2482fc2"><td class="memItemLeft" align="right" valign="top"><a id="ae578d68dfd27c9b5f82cbf7cd2482fc2"></a>
static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>set_next_offset</b> (char *buffer, size_t size) noexcept</td></tr>
<tr class="separator:ae578d68dfd27c9b5f82cbf7cd2482fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7551d5f3bf716e50a2fd4bbd167a74ca"><td class="memItemLeft" align="right" valign="top"><a id="a7551d5f3bf716e50a2fd4bbd167a74ca"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>print_traits_info</b> () noexcept</td></tr>
<tr class="separator:a7551d5f3bf716e50a2fd4bbd167a74ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5a4164badd536348e427683d6e5c6e11"><td class="memItemLeft" align="right" valign="top"><a id="a5a4164badd536348e427683d6e5c6e11"></a>
static constexpr auto const&#160;</td><td class="memItemRight" valign="bottom"><b>has_minimum_size_v</b> { <a class="el" href="namespaceiffl_1_1mpl.html#afac0434045e5cf64ebb4d731266ffc56">iffl::mpl::is_detected_v</a> &lt; has_minimum_size_mfn, type_traits&gt; }</td></tr>
<tr class="separator:a5a4164badd536348e427683d6e5c6e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8f7857effc1c2ee92d3589e8e04d21"><td class="memItemLeft" align="right" valign="top"><a id="a9a8f7857effc1c2ee92d3589e8e04d21"></a>
static constexpr auto const&#160;</td><td class="memItemRight" valign="bottom"><b>has_get_size_v</b> { <a class="el" href="namespaceiffl_1_1mpl.html#afac0434045e5cf64ebb4d731266ffc56">iffl::mpl::is_detected_v</a> &lt; has_get_size_mfn, type_traits&gt; }</td></tr>
<tr class="separator:a9a8f7857effc1c2ee92d3589e8e04d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e96ecd83d331e5aebf4717972c5e9e"><td class="memItemLeft" align="right" valign="top"><a id="a76e96ecd83d331e5aebf4717972c5e9e"></a>
static constexpr auto const&#160;</td><td class="memItemRight" valign="bottom"><b>has_next_offset_v</b> { <a class="el" href="namespaceiffl_1_1mpl.html#afac0434045e5cf64ebb4d731266ffc56">iffl::mpl::is_detected_v</a> &lt; has_next_offset_mfn, type_traits&gt; }</td></tr>
<tr class="separator:a76e96ecd83d331e5aebf4717972c5e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c92a8f60d412da34a653d26a6d5065"><td class="memItemLeft" align="right" valign="top"><a id="a98c92a8f60d412da34a653d26a6d5065"></a>
static constexpr auto const&#160;</td><td class="memItemRight" valign="bottom"><b>can_set_next_offset_v</b> { <a class="el" href="namespaceiffl_1_1mpl.html#afac0434045e5cf64ebb4d731266ffc56">iffl::mpl::is_detected_v</a> &lt; can_set_next_offset_mfn, type_traits&gt; }</td></tr>
<tr class="separator:a98c92a8f60d412da34a653d26a6d5065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b342e69b43a8275191df67211b6ca6"><td class="memItemLeft" align="right" valign="top"><a id="a05b342e69b43a8275191df67211b6ca6"></a>
static constexpr auto const&#160;</td><td class="memItemRight" valign="bottom"><b>can_validate_v</b> { <a class="el" href="namespaceiffl_1_1mpl.html#afac0434045e5cf64ebb4d731266ffc56">iffl::mpl::is_detected_v</a> &lt; can_validate_mfn, type_traits&gt; }</td></tr>
<tr class="separator:a05b342e69b43a8275191df67211b6ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f04621fe08d7c6574756cf935352245"><td class="memItemLeft" align="right" valign="top"><a id="a9f04621fe08d7c6574756cf935352245"></a>
static constexpr auto const&#160;</td><td class="memItemRight" valign="bottom"><b>has_alignment_v</b> { <a class="el" href="namespaceiffl_1_1mpl.html#afac0434045e5cf64ebb4d731266ffc56">iffl::mpl::is_detected_v</a> &lt; has_alignment_mfn, type_traits&gt; }</td></tr>
<tr class="separator:a9f04621fe08d7c6574756cf935352245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fe68f843e48534915ef6303cd45deb"><td class="memItemLeft" align="right" valign="top"><a id="aa3fe68f843e48534915ef6303cd45deb"></a>
static constexpr size_t const&#160;</td><td class="memItemRight" valign="bottom"><b>alignment</b> { get_alignment() }</td></tr>
<tr class="separator:aa3fe68f843e48534915ef6303cd45deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TT&gt;<br />
class iffl::flat_forward_list_traits_traits&lt; TT &gt;</h3>

<p>traits for <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the">flat_forward_list_traits</a> </p>
<p>I know, traits of traits does sounds redicules, but this is exactly what this class is. Given <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the">flat_forward_list_traits</a> instantiation, or a class that you want to use as traits for your <a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a> element types, it detects what methods are implemented by this trait so in the rest of algorithms and containers we can use this helper, and avoid rewriting same complicated and nusty machinery.</p>
<p>How to use: </p><div class="fragment"><div class="line"><span class="keyword">using</span> my_traits_traits = flat_forward_list_traits_traits&lt;my_traits&gt;;</div></div><!-- fragment --><p> If traits provide us a way to get value of the next element offset for a type then use it, otherwise ask it to calculate next element offset from its own size </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> constexpr (my_traits_traits::has_next_offset_v) {</div><div class="line">     my_traits::get_next_offset(buffer)</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">     my_traits::get_size(buffer)</div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad0e9945972bafae6479211448952245a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e9945972bafae6479211448952245a">&#9670;&nbsp;</a></span>can_set_next_offset_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits</a>&lt; TT &gt;::<a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#ad0e9945972bafae6479211448952245a">can_set_next_offset_t</a> =  <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a> &lt; can_set_next_offset_mfn, type_traits&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If traits have set_next_offset then can_set_next_offset_t is std::true_type otherwise std::false_type can_set_next_offset_v is std::true_type{} otherwise std::false_type{} </p>

</div>
</div>
<a id="a1e95398875258da24ffc1f9556962531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e95398875258da24ffc1f9556962531">&#9670;&nbsp;</a></span>can_validate_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits</a>&lt; TT &gt;::<a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#a1e95398875258da24ffc1f9556962531">can_validate_t</a> =  <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a> &lt; can_validate_mfn, type_traits&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If traits have validate then can_validate_t is std::true_type otherwise std::false_type can_validate_v is std::true_type{} otherwise std::false_type{} </p>

</div>
</div>
<a id="a77f2d3437212d2e091f259743f6d5448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f2d3437212d2e091f259743f6d5448">&#9670;&nbsp;</a></span>has_alignment_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits</a>&lt; TT &gt;::<a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#a77f2d3437212d2e091f259743f6d5448">has_alignment_t</a> =  <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a> &lt; has_alignment_mfn, type_traits&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If traits have validate then has_alignment_t is std::true_type otherwise std::false_type has_alignment_v is std::true_type{} otherwise std::false_type{} </p>

</div>
</div>
<a id="afeefbd9e550a81b9cb19c2dae755d6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeefbd9e550a81b9cb19c2dae755d6f1">&#9670;&nbsp;</a></span>has_get_size_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits</a>&lt; TT &gt;::<a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#afeefbd9e550a81b9cb19c2dae755d6f1">has_get_size_t</a> =  <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a> &lt; has_get_size_mfn, type_traits&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If traits have get_size then has_get_size_t is std::true_type otherwise std::false_type has_get_size_v is std::true_type{} otherwise std::false_type{} </p>

</div>
</div>
<a id="aaf334257fc91f2db91473e9298c85245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf334257fc91f2db91473e9298c85245">&#9670;&nbsp;</a></span>has_minimum_size_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits</a>&lt; TT &gt;::<a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#aaf334257fc91f2db91473e9298c85245">has_minimum_size_t</a> =  <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a> &lt; has_minimum_size_mfn, type_traits&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If traits have minimum_size then has_minimum_size_t is std::true_type otherwise std::false_type has_minimum_size_v is std::true_type{} otherwise std::false_type{} </p>

</div>
</div>
<a id="acca58aac8fb21dd3ee2be704bab92ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca58aac8fb21dd3ee2be704bab92ed8">&#9670;&nbsp;</a></span>has_next_offset_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits</a>&lt; TT &gt;::<a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#acca58aac8fb21dd3ee2be704bab92ed8">has_next_offset_t</a> =  <a class="el" href="namespaceiffl_1_1mpl.html#aa469046f9dd3f5ecb17eb523fce34ca6">iffl::mpl::is_detected</a> &lt; has_next_offset_mfn, type_traits&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If traits have get_next_offset then has_next_offset_t is std::true_type otherwise std::false_type has_next_offset_v is std::true_type{} otherwise std::false_type{} </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab1bd33757d170ad44881c9e5cf8a5db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bd33757d170ad44881c9e5cf8a5db4">&#9670;&nbsp;</a></span>get_next_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits</a>&lt; TT &gt;::get_next_offset </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns offset to the next element from the beginning of the current element </p>

</div>
</div>
<a id="ae9ff3cec75c5ef3da8b37602eb21ab46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ff3cec75c5ef3da8b37602eb21ab46">&#9670;&nbsp;</a></span>get_next_offset_ex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="structiffl_1_1offset__with__aligment.html">offset_with_aligment_t</a> <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">iffl::flat_forward_list_traits_traits</a>&lt; TT &gt;::get_next_offset_ex </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns both alligned and unaligned offset to the next element for types that have next element offset we should always use unaligned offset to get to the start position of the next element</p>
<p>For types without offset to the next element we should use alligned offset.</p>
<p>If you want a simple function that selects correct one then simply use get_next_offset instead of ex version. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="iffl__list_8h_source.html">iffl_list.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

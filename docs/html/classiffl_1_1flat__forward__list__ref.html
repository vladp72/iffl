<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: iffl::flat_forward_list_ref&lt; T, TT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceiffl.html">iffl</a></li><li class="navelem"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classiffl_1_1flat__forward__list__ref-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iffl::flat_forward_list_ref&lt; T, TT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Non owning container for flat forward list.  
 <a href="classiffl_1_1flat__forward__list__ref.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iffl__list_8h_source.html">iffl_list.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a52d8a90ad77b3823cc24e588b22a3dfd"><td class="memItemLeft" align="right" valign="top"><a id="a52d8a90ad77b3823cc24e588b22a3dfd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a52d8a90ad77b3823cc24e588b22a3dfd">value_type</a> = T</td></tr>
<tr class="memdesc:a52d8a90ad77b3823cc24e588b22a3dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element value type. <br /></td></tr>
<tr class="separator:a52d8a90ad77b3823cc24e588b22a3dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67fce097d83259a24f064f7b5bbf572"><td class="memItemLeft" align="right" valign="top"><a id="ab67fce097d83259a24f064f7b5bbf572"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ab67fce097d83259a24f064f7b5bbf572">pointer</a> = T *</td></tr>
<tr class="memdesc:ab67fce097d83259a24f064f7b5bbf572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to element type. <br /></td></tr>
<tr class="separator:ab67fce097d83259a24f064f7b5bbf572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6111213aaacdbafd1da00a5fca5d9dab"><td class="memItemLeft" align="right" valign="top"><a id="a6111213aaacdbafd1da00a5fca5d9dab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a6111213aaacdbafd1da00a5fca5d9dab">const_pointer</a> = T const *</td></tr>
<tr class="memdesc:a6111213aaacdbafd1da00a5fca5d9dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const element type. <br /></td></tr>
<tr class="separator:a6111213aaacdbafd1da00a5fca5d9dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4977e70b4eb173a80d9e6c51dd4b5d0"><td class="memItemLeft" align="right" valign="top"><a id="ad4977e70b4eb173a80d9e6c51dd4b5d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad4977e70b4eb173a80d9e6c51dd4b5d0">reference</a> = T &amp;</td></tr>
<tr class="memdesc:ad4977e70b4eb173a80d9e6c51dd4b5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the element type. <br /></td></tr>
<tr class="separator:ad4977e70b4eb173a80d9e6c51dd4b5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99bb4b6bed7da9f1504f74f21ed3bbe"><td class="memItemLeft" align="right" valign="top"><a id="ae99bb4b6bed7da9f1504f74f21ed3bbe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ae99bb4b6bed7da9f1504f74f21ed3bbe">const_reference</a> = T const &amp;</td></tr>
<tr class="memdesc:ae99bb4b6bed7da9f1504f74f21ed3bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the const element type. <br /></td></tr>
<tr class="separator:ae99bb4b6bed7da9f1504f74f21ed3bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c6c8d170c7b21d2fe2f2f3c4abdc91"><td class="memItemLeft" align="right" valign="top"><a id="a48c6c8d170c7b21d2fe2f2f3c4abdc91"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a48c6c8d170c7b21d2fe2f2f3c4abdc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type. <br /></td></tr>
<tr class="separator:a48c6c8d170c7b21d2fe2f2f3c4abdc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a8e1e525d40f79bbbb47d0a79803b8"><td class="memItemLeft" align="right" valign="top"><a id="ad8a8e1e525d40f79bbbb47d0a79803b8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad8a8e1e525d40f79bbbb47d0a79803b8">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:ad8a8e1e525d40f79bbbb47d0a79803b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element pointers difference type. <br /></td></tr>
<tr class="separator:ad8a8e1e525d40f79bbbb47d0a79803b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d7760d099f19d89556275a6b9d3472"><td class="memItemLeft" align="right" valign="top"><a id="a72d7760d099f19d89556275a6b9d3472"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a72d7760d099f19d89556275a6b9d3472">traits</a> = TT</td></tr>
<tr class="memdesc:a72d7760d099f19d89556275a6b9d3472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element traits type. <br /></td></tr>
<tr class="separator:a72d7760d099f19d89556275a6b9d3472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbbc7a3c941d21517e035623e6c3663"><td class="memItemLeft" align="right" valign="top"><a id="a5cbbc7a3c941d21517e035623e6c3663"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a5cbbc7a3c941d21517e035623e6c3663">traits_traits</a> = <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html">flat_forward_list_traits_traits</a>&lt; TT &gt;</td></tr>
<tr class="memdesc:a5cbbc7a3c941d21517e035623e6c3663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element traits traits type. <br /></td></tr>
<tr class="separator:a5cbbc7a3c941d21517e035623e6c3663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad253e51211833b5c2b4867e2cbd4305d"><td class="memItemLeft" align="right" valign="top"><a id="ad253e51211833b5c2b4867e2cbd4305d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad253e51211833b5c2b4867e2cbd4305d">range_t</a> = typename <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#af88543910b2f89f5cb271c57aea132ab">traits_traits::range_t</a></td></tr>
<tr class="memdesc:ad253e51211833b5c2b4867e2cbd4305d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type used to describe buffer used by the element and how much of this buffer is used by the data. Type also includes information about required alignment. <br /></td></tr>
<tr class="separator:ad253e51211833b5c2b4867e2cbd4305d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c2172bb31d16f59ce84174ef984127"><td class="memItemLeft" align="right" valign="top"><a id="a77c2172bb31d16f59ce84174ef984127"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a77c2172bb31d16f59ce84174ef984127">size_with_padding_t</a> = typename <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#ad77593ff4fd28ace80b243920a57bc51">traits_traits::size_with_padding_t</a></td></tr>
<tr class="memdesc:a77c2172bb31d16f59ce84174ef984127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type used to describe size with padding. <br /></td></tr>
<tr class="separator:a77c2172bb31d16f59ce84174ef984127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c57fa3c4f5450c0599b55abfede420"><td class="memItemLeft" align="right" valign="top"><a id="a69c57fa3c4f5450c0599b55abfede420"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a69c57fa3c4f5450c0599b55abfede420">offset_with_aligment_t</a> = typename <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#aaa01a29e472dfdd74fd15b2c63387a51">traits_traits::offset_with_aligment_t</a></td></tr>
<tr class="memdesc:a69c57fa3c4f5450c0599b55abfede420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type used to describe size with alignment. <br /></td></tr>
<tr class="separator:a69c57fa3c4f5450c0599b55abfede420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c50a220e46d774286b20a92e316270f"><td class="memItemLeft" align="right" valign="top"><a id="a9c50a220e46d774286b20a92e316270f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a9c50a220e46d774286b20a92e316270f">sizes_t</a> = <a class="el" href="structiffl_1_1flat__forward__list__sizes.html">flat_forward_list_sizes</a>&lt; <a class="el" href="structiffl_1_1flat__forward__list__traits__traits.html#aa3fe68f843e48534915ef6303cd45deb">traits_traits::alignment</a> &gt;</td></tr>
<tr class="memdesc:a9c50a220e46d774286b20a92e316270f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulary type that contains information about buffer size, and last element range. <br /></td></tr>
<tr class="separator:a9c50a220e46d774286b20a92e316270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b10ba93a64b8889b86162b22a353db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a75b10ba93a64b8889b86162b22a353db">buffer_value_type</a> = std::conditional_t&lt; std::is_const_v&lt; T &gt;, char const, char &gt;</td></tr>
<tr class="memdesc:a75b10ba93a64b8889b86162b22a353db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depending if T is const we will use const or non-const buffer pointer.  <a href="#a75b10ba93a64b8889b86162b22a353db">More...</a><br /></td></tr>
<tr class="separator:a75b10ba93a64b8889b86162b22a353db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd454d38a53ef72ad260cdaec4c7d4b"><td class="memItemLeft" align="right" valign="top"><a id="a3fd454d38a53ef72ad260cdaec4c7d4b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a3fd454d38a53ef72ad260cdaec4c7d4b">const_buffer_value_type</a> = <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a75b10ba93a64b8889b86162b22a353db">buffer_value_type</a> const</td></tr>
<tr class="memdesc:a3fd454d38a53ef72ad260cdaec4c7d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">When we do not intend to modify buffer we can treat it as a bag of const characters. <br /></td></tr>
<tr class="separator:a3fd454d38a53ef72ad260cdaec4c7d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95af31f36448292844e31fb1468dc1e0"><td class="memItemLeft" align="right" valign="top"><a id="a95af31f36448292844e31fb1468dc1e0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> = <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a75b10ba93a64b8889b86162b22a353db">buffer_value_type</a> *</td></tr>
<tr class="memdesc:a95af31f36448292844e31fb1468dc1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used as a buffer pointer. <br /></td></tr>
<tr class="separator:a95af31f36448292844e31fb1468dc1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0ccbbc34a0aaf840f1338a6fd7383f"><td class="memItemLeft" align="right" valign="top"><a id="aad0ccbbc34a0aaf840f1338a6fd7383f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#aad0ccbbc34a0aaf840f1338a6fd7383f">const_buffer_pointer</a> = <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a3fd454d38a53ef72ad260cdaec4c7d4b">const_buffer_value_type</a> *</td></tr>
<tr class="memdesc:aad0ccbbc34a0aaf840f1338a6fd7383f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used as a pointer ot the const buffer. <br /></td></tr>
<tr class="separator:aad0ccbbc34a0aaf840f1338a6fd7383f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67aa09c32ee4a1db2529f0c4e9864ddb"><td class="memItemLeft" align="right" valign="top"><a id="a67aa09c32ee4a1db2529f0c4e9864ddb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a67aa09c32ee4a1db2529f0c4e9864ddb">iterator</a> = <a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; T, TT &gt;</td></tr>
<tr class="memdesc:a67aa09c32ee4a1db2529f0c4e9864ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iterator. <br /></td></tr>
<tr class="separator:a67aa09c32ee4a1db2529f0c4e9864ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf130ebea5d4ecbbaf17692a22142ef7"><td class="memItemLeft" align="right" valign="top"><a id="adf130ebea5d4ecbbaf17692a22142ef7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> = <a class="el" href="namespaceiffl.html#ad67086ee8db08a7b96df7f9759d02a1b">flat_forward_list_const_iterator</a>&lt; T, TT &gt;</td></tr>
<tr class="memdesc:adf130ebea5d4ecbbaf17692a22142ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of const iterator. <br /></td></tr>
<tr class="separator:adf130ebea5d4ecbbaf17692a22142ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c98ea83eaa2473ef350ba01281119ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a1c98ea83eaa2473ef350ba01281119ee">buffer_type</a> = <a class="el" href="structiffl_1_1buffer__t.html">buffer_t</a>&lt; <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a75b10ba93a64b8889b86162b22a353db">buffer_value_type</a> &gt;</td></tr>
<tr class="memdesc:a1c98ea83eaa2473ef350ba01281119ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers that describe buffer.  <a href="#a1c98ea83eaa2473ef350ba01281119ee">More...</a><br /></td></tr>
<tr class="separator:a1c98ea83eaa2473ef350ba01281119ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa0b091ba603ed08e9ea7da0a3a07da94"><td class="memItemLeft" align="right" valign="top"><a id="aa0b091ba603ed08e9ea7da0a3a07da94"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#aa0b091ba603ed08e9ea7da0a3a07da94">flat_forward_list_ref</a> () noexcept</td></tr>
<tr class="memdesc:aa0b091ba603ed08e9ea7da0a3a07da94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:aa0b091ba603ed08e9ea7da0a3a07da94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae527ee21c8bea9b4cbf37d17e363f059"><td class="memTemplParams" colspan="2">template&lt;typename V , typename VV , typename  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </td></tr>
<tr class="memitem:ae527ee21c8bea9b4cbf37d17e363f059"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ae527ee21c8bea9b4cbf37d17e363f059">flat_forward_list_ref</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; V, VV &gt; const &amp;other) noexcept</td></tr>
<tr class="memdesc:ae527ee21c8bea9b4cbf37d17e363f059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator to view from a ref.  <a href="#ae527ee21c8bea9b4cbf37d17e363f059">More...</a><br /></td></tr>
<tr class="separator:ae527ee21c8bea9b4cbf37d17e363f059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620ef67dee90374d14ec3a554704366b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a620ef67dee90374d14ec3a554704366b">flat_forward_list_ref</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a1c98ea83eaa2473ef350ba01281119ee">buffer_type</a> const &amp;other_buff) noexcept</td></tr>
<tr class="memdesc:a620ef67dee90374d14ec3a554704366b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that initializas view to point to the buffer buffer.  <a href="#a620ef67dee90374d14ec3a554704366b">More...</a><br /></td></tr>
<tr class="separator:a620ef67dee90374d14ec3a554704366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d5bf31df76a855ffd85e157c54b14a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#aa3d5bf31df76a855ffd85e157c54b14a">flat_forward_list_ref</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> buffer_begin, <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> last_element, <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> buffer_end) noexcept</td></tr>
<tr class="memdesc:aa3d5bf31df76a855ffd85e157c54b14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that copies list from a buffer.  <a href="#aa3d5bf31df76a855ffd85e157c54b14a">More...</a><br /></td></tr>
<tr class="separator:aa3d5bf31df76a855ffd85e157c54b14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab479f31e98d14ecd8e3c1df7bfc2cc34"><td class="memTemplParams" colspan="2">template&lt;typename V , typename VV , typename  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </td></tr>
<tr class="memitem:ab479f31e98d14ecd8e3c1df7bfc2cc34"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ab479f31e98d14ecd8e3c1df7bfc2cc34">flat_forward_list_ref</a> (<a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; V, VV &gt; const &amp;<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a385708e4d9df77ba8330fc620ea24fc9">begin</a>, <a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; V, VV &gt; const &amp;<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a54212a504f381d4134e6f4d6979cacc2">last</a>) noexcept</td></tr>
<tr class="memdesc:ab479f31e98d14ecd8e3c1df7bfc2cc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that creaates a view over a buffer described by a pair of iterators.  <a href="#ab479f31e98d14ecd8e3c1df7bfc2cc34">More...</a><br /></td></tr>
<tr class="separator:ab479f31e98d14ecd8e3c1df7bfc2cc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06513d73a76bf9c7fd21d3682eb4664a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a06513d73a76bf9c7fd21d3682eb4664a">flat_forward_list_ref</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> *buffer, size_t buffer_size) noexcept</td></tr>
<tr class="memdesc:a06513d73a76bf9c7fd21d3682eb4664a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that checks if buffer contains a valid list and if it does then copies that list.  <a href="#a06513d73a76bf9c7fd21d3682eb4664a">More...</a><br /></td></tr>
<tr class="separator:a06513d73a76bf9c7fd21d3682eb4664a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3f85b8c59c28b250f97213faf15fc5"><td class="memTemplParams" colspan="2">template&lt;typename V , typename VV , typename A , typename UNUSED  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </td></tr>
<tr class="memitem:abb3f85b8c59c28b250f97213faf15fc5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#abb3f85b8c59c28b250f97213faf15fc5">flat_forward_list_ref</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; V, VV, A &gt; const &amp;c) noexcept</td></tr>
<tr class="memdesc:abb3f85b8c59c28b250f97213faf15fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs view from container.  <a href="#abb3f85b8c59c28b250f97213faf15fc5">More...</a><br /></td></tr>
<tr class="separator:abb3f85b8c59c28b250f97213faf15fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3effc52dddb4b989b8b814882658ff8"><td class="memTemplParams" colspan="2">template&lt;typename V , typename VV , typename  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </td></tr>
<tr class="memitem:af3effc52dddb4b989b8b814882658ff8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#af3effc52dddb4b989b8b814882658ff8">operator=</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; V, VV &gt; const &amp;other)</td></tr>
<tr class="memdesc:af3effc52dddb4b989b8b814882658ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#af3effc52dddb4b989b8b814882658ff8">More...</a><br /></td></tr>
<tr class="separator:af3effc52dddb4b989b8b814882658ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe42d0f15035f58da13f952dfbc99d87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#abe42d0f15035f58da13f952dfbc99d87">operator=</a> (<a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;other_buffer)</td></tr>
<tr class="memdesc:abe42d0f15035f58da13f952dfbc99d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#abe42d0f15035f58da13f952dfbc99d87">More...</a><br /></td></tr>
<tr class="separator:abe42d0f15035f58da13f952dfbc99d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267d2ca7575654e448aabcbdcb9f6518"><td class="memTemplParams" colspan="2">template&lt;typename V , typename VV , typename A , typename UNUSED  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </td></tr>
<tr class="memitem:a267d2ca7575654e448aabcbdcb9f6518"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a267d2ca7575654e448aabcbdcb9f6518">operator=</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; V, VV, A &gt; const &amp;c) noexcept</td></tr>
<tr class="memdesc:a267d2ca7575654e448aabcbdcb9f6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs view from container.  <a href="#a267d2ca7575654e448aabcbdcb9f6518">More...</a><br /></td></tr>
<tr class="separator:a267d2ca7575654e448aabcbdcb9f6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee045aa7a7bc09956161588a802bcd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a8ee045aa7a7bc09956161588a802bcd2">~flat_forward_list_ref</a> () noexcept</td></tr>
<tr class="memdesc:a8ee045aa7a7bc09956161588a802bcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a8ee045aa7a7bc09956161588a802bcd2">More...</a><br /></td></tr>
<tr class="separator:a8ee045aa7a7bc09956161588a802bcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d026c143a250cf5f8bbea6526c08981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a4d026c143a250cf5f8bbea6526c08981">assign</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a1c98ea83eaa2473ef350ba01281119ee">buffer_type</a> const &amp;other_buff) noexcept</td></tr>
<tr class="memdesc:a4d026c143a250cf5f8bbea6526c08981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns view to point to the described buffer.  <a href="#a4d026c143a250cf5f8bbea6526c08981">More...</a><br /></td></tr>
<tr class="separator:a4d026c143a250cf5f8bbea6526c08981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ea5b39bf43c3d416504cf67424b02f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a67ea5b39bf43c3d416504cf67424b02f">assign</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> buffer_begin, <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> last_element, <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> buffer_end) noexcept</td></tr>
<tr class="memdesc:a67ea5b39bf43c3d416504cf67424b02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns view to point to the described buffer.  <a href="#a67ea5b39bf43c3d416504cf67424b02f">More...</a><br /></td></tr>
<tr class="separator:a67ea5b39bf43c3d416504cf67424b02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6be0501313f23c60f176450efdd139"><td class="memTemplParams" colspan="2">template&lt;typename V , typename VV , typename  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </td></tr>
<tr class="memitem:acf6be0501313f23c60f176450efdd139"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#acf6be0501313f23c60f176450efdd139">assign</a> (<a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; V, VV &gt; const &amp;<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a385708e4d9df77ba8330fc620ea24fc9">begin</a>, <a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; V, VV &gt; const &amp;<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a54212a504f381d4134e6f4d6979cacc2">last</a>) noexcept</td></tr>
<tr class="memdesc:acf6be0501313f23c60f176450efdd139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns view to point to the described buffer.  <a href="#acf6be0501313f23c60f176450efdd139">More...</a><br /></td></tr>
<tr class="separator:acf6be0501313f23c60f176450efdd139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d51a6a4d21c45b952f53ae7e5f32bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a78d51a6a4d21c45b952f53ae7e5f32bf">assign</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> *buffer, size_t buffer_size) noexcept</td></tr>
<tr class="memdesc:a78d51a6a4d21c45b952f53ae7e5f32bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns view to point to the described buffer.  <a href="#a78d51a6a4d21c45b952f53ae7e5f32bf">More...</a><br /></td></tr>
<tr class="separator:a78d51a6a4d21c45b952f53ae7e5f32bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad959382b0fd29650b75b88f666b9b8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad959382b0fd29650b75b88f666b9b8d5">swap</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ad959382b0fd29650b75b88f666b9b8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps content of this container and the other container.  <a href="#ad959382b0fd29650b75b88f666b9b8d5">More...</a><br /></td></tr>
<tr class="separator:ad959382b0fd29650b75b88f666b9b8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713dba7d038e505408401d385cb85edb"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a713dba7d038e505408401d385cb85edb">front</a> ()</td></tr>
<tr class="separator:a713dba7d038e505408401d385cb85edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af433768411eca7c4d66cc3981675dab2"><td class="memItemLeft" align="right" valign="top">T const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#af433768411eca7c4d66cc3981675dab2">front</a> () const</td></tr>
<tr class="separator:af433768411eca7c4d66cc3981675dab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10dafbf8ce6f9dd39229525c3ace92f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#af10dafbf8ce6f9dd39229525c3ace92f">back</a> ()</td></tr>
<tr class="separator:af10dafbf8ce6f9dd39229525c3ace92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae541152cac3f33ac97497ba459c0af4"><td class="memItemLeft" align="right" valign="top">T const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#aae541152cac3f33ac97497ba459c0af4">back</a> () const</td></tr>
<tr class="separator:aae541152cac3f33ac97497ba459c0af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385708e4d9df77ba8330fc620ea24fc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a67aa09c32ee4a1db2529f0c4e9864ddb">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a385708e4d9df77ba8330fc620ea24fc9">begin</a> () noexcept</td></tr>
<tr class="separator:a385708e4d9df77ba8330fc620ea24fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48961715d438f7d74d54d34d362672e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48961715d438f7d74d54d34d362672e6">begin</a> () const noexcept</td></tr>
<tr class="separator:a48961715d438f7d74d54d34d362672e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54212a504f381d4134e6f4d6979cacc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a67aa09c32ee4a1db2529f0c4e9864ddb">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a54212a504f381d4134e6f4d6979cacc2">last</a> () noexcept</td></tr>
<tr class="separator:a54212a504f381d4134e6f4d6979cacc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf156cfae7e23fed52b2d5d2e593fe9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#aaf156cfae7e23fed52b2d5d2e593fe9c">last</a> () const noexcept</td></tr>
<tr class="separator:aaf156cfae7e23fed52b2d5d2e593fe9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35cf3455e5daeffd0acdb55730c133c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a67aa09c32ee4a1db2529f0c4e9864ddb">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad35cf3455e5daeffd0acdb55730c133c">end</a> () noexcept</td></tr>
<tr class="separator:ad35cf3455e5daeffd0acdb55730c133c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e181346b232fffbb2fa28decbaa35b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ae6e181346b232fffbb2fa28decbaa35b">end</a> () const noexcept</td></tr>
<tr class="separator:ae6e181346b232fffbb2fa28decbaa35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418c7f871ad89c957355707b3c07792d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a418c7f871ad89c957355707b3c07792d">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a418c7f871ad89c957355707b3c07792d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8638f22191adee9aac5b4468f643ae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#aa8638f22191adee9aac5b4468f643ae0">clast</a> () const noexcept</td></tr>
<tr class="separator:aa8638f22191adee9aac5b4468f643ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af86b197f93b4f6c4743eb33e212159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a0af86b197f93b4f6c4743eb33e212159">cend</a> () const noexcept</td></tr>
<tr class="separator:a0af86b197f93b4f6c4743eb33e212159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ae49c650483197ce08e074738443c8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad8ae49c650483197ce08e074738443c8">data</a> () noexcept</td></tr>
<tr class="separator:ad8ae49c650483197ce08e074738443c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54516df7db6b828c9194c84d0e31f460"><td class="memItemLeft" align="right" valign="top">char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a54516df7db6b828c9194c84d0e31f460">data</a> () const noexcept</td></tr>
<tr class="separator:a54516df7db6b828c9194c84d0e31f460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e92edb9357a20ed6df97200b42f304"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a36e92edb9357a20ed6df97200b42f304">revalidate_data</a> () noexcept</td></tr>
<tr class="memdesc:a36e92edb9357a20ed6df97200b42f304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates that buffer contains a valid list.  <a href="#a36e92edb9357a20ed6df97200b42f304">More...</a><br /></td></tr>
<tr class="separator:a36e92edb9357a20ed6df97200b42f304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac851e4a7d87214d118afdae000ddeaab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ac851e4a7d87214d118afdae000ddeaab">required_size</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;it) const noexcept</td></tr>
<tr class="memdesc:ac851e4a7d87214d118afdae000ddeaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns capacity used by the element's data.  <a href="#ac851e4a7d87214d118afdae000ddeaab">More...</a><br /></td></tr>
<tr class="separator:ac851e4a7d87214d118afdae000ddeaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0f2b104557ac0a55611165aa26a2f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#acc0f2b104557ac0a55611165aa26a2f3">used_size</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;it) const noexcept</td></tr>
<tr class="separator:acc0f2b104557ac0a55611165aa26a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c6cf398f09955478c9d74ce2c87f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad253e51211833b5c2b4867e2cbd4305d">range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#aa9c6cf398f09955478c9d74ce2c87f4d">range</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;it) const noexcept</td></tr>
<tr class="memdesc:aa9c6cf398f09955478c9d74ce2c87f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the buffer occupied by an element.  <a href="#aa9c6cf398f09955478c9d74ce2c87f4d">More...</a><br /></td></tr>
<tr class="separator:aa9c6cf398f09955478c9d74ce2c87f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302dd31350a6433f01d4808adf04a9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad253e51211833b5c2b4867e2cbd4305d">range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a302dd31350a6433f01d4808adf04a9f1">closed_range</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a385708e4d9df77ba8330fc620ea24fc9">begin</a>, <a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a54212a504f381d4134e6f4d6979cacc2">last</a>) const noexcept</td></tr>
<tr class="memdesc:a302dd31350a6433f01d4808adf04a9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the buffer occupied by elements in the range [begin, last].  <a href="#a302dd31350a6433f01d4808adf04a9f1">More...</a><br /></td></tr>
<tr class="separator:a302dd31350a6433f01d4808adf04a9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e8aba8677b41d9ca76c7bfad7308ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad253e51211833b5c2b4867e2cbd4305d">range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a29e8aba8677b41d9ca76c7bfad7308ba">half_open_range</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a385708e4d9df77ba8330fc620ea24fc9">begin</a>, <a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;<a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad35cf3455e5daeffd0acdb55730c133c">end</a>) const noexcept</td></tr>
<tr class="memdesc:a29e8aba8677b41d9ca76c7bfad7308ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the buffer occupied by elements in the range [begin, end).  <a href="#a29e8aba8677b41d9ca76c7bfad7308ba">More...</a><br /></td></tr>
<tr class="separator:a29e8aba8677b41d9ca76c7bfad7308ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9158c6e341074fa72be46cac1dc84a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a9a9158c6e341074fa72be46cac1dc84a">contains</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;it, <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> position) const noexcept</td></tr>
<tr class="memdesc:a9a9158c6e341074fa72be46cac1dc84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if given offset in the buffer falls into a buffer used by the element.  <a href="#a9a9158c6e341074fa72be46cac1dc84a">More...</a><br /></td></tr>
<tr class="separator:a9a9158c6e341074fa72be46cac1dc84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638c1f688441fcd62106bc41d5b97eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a638c1f688441fcd62106bc41d5b97eee">find_element_before</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> position) const noexcept</td></tr>
<tr class="memdesc:a638c1f688441fcd62106bc41d5b97eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element before the element that containes given position.  <a href="#a638c1f688441fcd62106bc41d5b97eee">More...</a><br /></td></tr>
<tr class="separator:a638c1f688441fcd62106bc41d5b97eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b2a5bc864fa5828956b365d08564fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#af1b2a5bc864fa5828956b365d08564fa">find_element_at</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> position) const noexcept</td></tr>
<tr class="memdesc:af1b2a5bc864fa5828956b365d08564fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element that containes given position.  <a href="#af1b2a5bc864fa5828956b365d08564fa">More...</a><br /></td></tr>
<tr class="separator:af1b2a5bc864fa5828956b365d08564fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b660d2e668b5691f3d312080fbd128e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a5b660d2e668b5691f3d312080fbd128e">find_element_after</a> (<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> position) const noexcept</td></tr>
<tr class="memdesc:a5b660d2e668b5691f3d312080fbd128e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element after the element that containes given position.  <a href="#a5b660d2e668b5691f3d312080fbd128e">More...</a><br /></td></tr>
<tr class="separator:a5b660d2e668b5691f3d312080fbd128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d53d9f52a88db6c43c2f28a4c0f75d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a1d53d9f52a88db6c43c2f28a4c0f75d3">size</a> () const noexcept</td></tr>
<tr class="memdesc:a1d53d9f52a88db6c43c2f28a4c0f75d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in the container.  <a href="#a1d53d9f52a88db6c43c2f28a4c0f75d3">More...</a><br /></td></tr>
<tr class="separator:a1d53d9f52a88db6c43c2f28a4c0f75d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b9e5fce71d956aadfc293603a04ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a559b9e5fce71d956aadfc293603a04ce">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a559b9e5fce71d956aadfc293603a04ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if container contains no elements.  <a href="#a559b9e5fce71d956aadfc293603a04ce">More...</a><br /></td></tr>
<tr class="separator:a559b9e5fce71d956aadfc293603a04ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f771ccfdc8fbfa464d11d390c6e658d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a6f771ccfdc8fbfa464d11d390c6e658d">operator bool</a> () const</td></tr>
<tr class="separator:a6f771ccfdc8fbfa464d11d390c6e658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dc2ddceaffcb697e3c9718b7578c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a87dc2ddceaffcb697e3c9718b7578c9e">used_capacity</a> () const noexcept</td></tr>
<tr class="separator:a87dc2ddceaffcb697e3c9718b7578c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aba1766305f168d5f12d7652090e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a20aba1766305f168d5f12d7652090e4e">total_capacity</a> () const noexcept</td></tr>
<tr class="separator:a20aba1766305f168d5f12d7652090e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0034e4b0b24a3ca72f8428ee5c615664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a0034e4b0b24a3ca72f8428ee5c615664">remaining_capacity</a> () const noexcept</td></tr>
<tr class="separator:a0034e4b0b24a3ca72f8428ee5c615664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522578da80417f605fc414ad6e5b7458"><td class="memTemplParams" colspan="2">template&lt;typename V , typename VV , typename A , typename UNUSED &gt; </td></tr>
<tr class="memitem:a522578da80417f605fc414ad6e5b7458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a522578da80417f605fc414ad6e5b7458">operator=</a> (<a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; V, VV, A &gt; const &amp;c) noexcept</td></tr>
<tr class="memdesc:a522578da80417f605fc414ad6e5b7458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs ref or view from container.  <a href="#a522578da80417f605fc414ad6e5b7458">More...</a><br /></td></tr>
<tr class="separator:a522578da80417f605fc414ad6e5b7458"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0b7417346a70c40c231d1bb8575c2906"><td class="memItemLeft" align="right" valign="top"><a id="a0b7417346a70c40c231d1bb8575c2906"></a>
static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a0b7417346a70c40c231d1bb8575c2906">is_ref</a> { !std::is_const_v&lt;T&gt; }</td></tr>
<tr class="memdesc:a0b7417346a70c40c231d1bb8575c2906"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this is a ref and false if this is a view. <br /></td></tr>
<tr class="separator:a0b7417346a70c40c231d1bb8575c2906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6556cbd99b545f9e49ada07ff2893cdf"><td class="memItemLeft" align="right" valign="top"><a id="a6556cbd99b545f9e49ada07ff2893cdf"></a>
static <a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a6556cbd99b545f9e49ada07ff2893cdf">npos</a> = iffl::npos</td></tr>
<tr class="memdesc:a6556cbd99b545f9e49ada07ff2893cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that represents and invalid or non-existent position. <br /></td></tr>
<tr class="separator:a6556cbd99b545f9e49ada07ff2893cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt;<br />
class iffl::flat_forward_list_ref&lt; T, TT &gt;</h3>

<p>Non owning container for flat forward list. </p>
<p>Forward declaration of intrusive flat forward list reference.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits Provides helpers accessing elements of the buffer without taking ownership of the buffer. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1c98ea83eaa2473ef350ba01281119ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c98ea83eaa2473ef350ba01281119ee">&#9670;&nbsp;</a></span>buffer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a1c98ea83eaa2473ef350ba01281119ee">buffer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointers that describe buffer. </p>
<p>Depending if T is const buffer uses char * or char const * </p>

</div>
</div>
<a id="a75b10ba93a64b8889b86162b22a353db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b10ba93a64b8889b86162b22a353db">&#9670;&nbsp;</a></span>buffer_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::<a class="el" href="classiffl_1_1flat__forward__list__ref.html#a75b10ba93a64b8889b86162b22a353db">buffer_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Depending if T is const we will use const or non-const buffer pointer. </p>
<p>Since we have variable size elementa, and we cannot express it in the C++ type system we treat buffer with elements as a bag of chars and cast to the element type when nessesary. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae527ee21c8bea9b4cbf37d17e363f059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae527ee21c8bea9b4cbf37d17e363f059">&#9670;&nbsp;</a></span>flat_forward_list_ref() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename V , typename VV , typename  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; V, VV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator to view from a ref. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>- For SFINAE we need to make this method a template Type const iterator is pointing to. </td></tr>
    <tr><td class="paramname">VV</td><td>- Type traits.</td></tr>
  </table>
  </dd>
</dl>
<p>Use SFINAE to enable it only on const instantiation to support assignment from a non-const instantiation of template </p>

</div>
</div>
<a id="a620ef67dee90374d14ec3a554704366b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620ef67dee90374d14ec3a554704366b">&#9670;&nbsp;</a></span>flat_forward_list_ref() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a1c98ea83eaa2473ef350ba01281119ee">buffer_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>other_buff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that initializas view to point to the buffer buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_buff</td><td>- pointer to the start of the buffer that contains list.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. </p>

</div>
</div>
<a id="aa3d5bf31df76a855ffd85e157c54b14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d5bf31df76a855ffd85e157c54b14a">&#9670;&nbsp;</a></span>flat_forward_list_ref() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a>&#160;</td>
          <td class="paramname"><em>buffer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a>&#160;</td>
          <td class="paramname"><em>last_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a>&#160;</td>
          <td class="paramname"><em>buffer_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that copies list from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_begin</td><td>- pointer to the start of the buffer that contains list. </td></tr>
    <tr><td class="paramname">buffer_end</td><td>- pointer to the address right after last byte in the buffer. </td></tr>
    <tr><td class="paramname">last_element</td><td>- pointers to the last element of the list in the buffer. If buffer does not contain any elements then this parameter must be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. </p>

</div>
</div>
<a id="ab479f31e98d14ecd8e3c1df7bfc2cc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab479f31e98d14ecd8e3c1df7bfc2cc34">&#9670;&nbsp;</a></span>flat_forward_list_ref() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename V , typename VV , typename  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; V, VV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; V, VV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that creaates a view over a buffer described by a pair of iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>- For SFINAE we need to make this method a template Type const iterator is pointing to. </td></tr>
    <tr><td class="paramname">VV</td><td>- Type traits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- iterator for the buffer begin. </td></tr>
    <tr><td class="paramname">last</td><td>- last element that should be included in the view</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. </p>

</div>
</div>
<a id="a06513d73a76bf9c7fd21d3682eb4664a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06513d73a76bf9c7fd21d3682eb4664a">&#9670;&nbsp;</a></span>flat_forward_list_ref() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that checks if buffer contains a valid list and if it does then copies that list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to the start of the buffer that might contains list. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>- bufer size.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor searches for the last valid element in the buffer, and is buffer is valid then it copies elements to the new buffer. </p>

</div>
</div>
<a id="abb3f85b8c59c28b250f97213faf15fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3f85b8c59c28b250f97213faf15fc5">&#9670;&nbsp;</a></span>flat_forward_list_ref() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TT &gt; </div>
<div class="memtemplate">
template&lt;typename V , typename VV , typename A , typename UNUSED &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; V, VV, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs view from container. </p>
<p>Constructs ref or view from container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>- For SFINAE we need to make this method a template Type const iterator is pointing to. </td></tr>
    <tr><td class="paramname">VV</td><td>- Type traits. </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container we are constructing view from</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ee045aa7a7bc09956161588a802bcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee045aa7a7bc09956161588a802bcd2">&#9670;&nbsp;</a></span>~flat_forward_list_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::~<a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Deallocates buffer owned by container. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d026c143a250cf5f8bbea6526c08981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d026c143a250cf5f8bbea6526c08981">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a1c98ea83eaa2473ef350ba01281119ee">buffer_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>other_buff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns view to point to the described buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_buff</td><td>- pointer to the start of the buffer that contains list.</td></tr>
  </table>
  </dd>
</dl>
<p>This method does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. </p>

</div>
</div>
<a id="a67ea5b39bf43c3d416504cf67424b02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ea5b39bf43c3d416504cf67424b02f">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a>&#160;</td>
          <td class="paramname"><em>buffer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a>&#160;</td>
          <td class="paramname"><em>last_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a>&#160;</td>
          <td class="paramname"><em>buffer_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns view to point to the described buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_begin</td><td>- pointer to the start of the buffer that contains list. </td></tr>
    <tr><td class="paramname">last_element</td><td>- pointer to the last element of the list. </td></tr>
    <tr><td class="paramname">buffer_end</td><td>- pointer to the end of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This method does not validate if this is a valid flat forward list. It assumes that caller validated buffer before using this constructor. </p>

</div>
</div>
<a id="acf6be0501313f23c60f176450efdd139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6be0501313f23c60f176450efdd139">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename V , typename VV , typename  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; V, VV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a0cc99c7f27e6b377339364aef8b45b0c">flat_forward_list_iterator</a>&lt; V, VV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns view to point to the described buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>- For SFINAE we need to make this method a template Type const iterator is pointing to. </td></tr>
    <tr><td class="paramname">VV</td><td>- Type traits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- iterator for the buffer begin. </td></tr>
    <tr><td class="paramname">last</td><td>- last element that should be included in the view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78d51a6a4d21c45b952f53ae7e5f32bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d51a6a4d21c45b952f53ae7e5f32bf">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a95af31f36448292844e31fb1468dc1e0">buffer_pointer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns view to point to the described buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to the begin of a buffer. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>- size of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af10dafbf8ce6f9dd39229525c3ace92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10dafbf8ce6f9dd39229525c3ace92f">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the last element in the container.</dd></dl>
<p>Calling this method on a empty container will trigger fail-fast </p>

</div>
</div>
<a id="aae541152cac3f33ac97497ba459c0af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae541152cac3f33ac97497ba459c0af4">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference to the last element in the container.</dd></dl>
<p>Calling this method on a empty container will trigger fail-fast </p>

</div>
</div>
<a id="a385708e4d9df77ba8330fc620ea24fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385708e4d9df77ba8330fc620ea24fc9">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a67aa09c32ee4a1db2529f0c4e9864ddb">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator pointing to the first element of container.</dd></dl>
<p>Calling on an empty container returns end iterator </p>

</div>
</div>
<a id="a48961715d438f7d74d54d34d362672e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48961715d438f7d74d54d34d362672e6">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const iterator pointing to the first element of container.</dd></dl>
<p>Calling on an empty container returns const end iterator </p>

</div>
</div>
<a id="a418c7f871ad89c957355707b3c07792d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418c7f871ad89c957355707b3c07792d">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const iterator pointing to the first element of container.</dd></dl>
<p>Calling on an empty container returns const end iterator </p>

</div>
</div>
<a id="a0af86b197f93b4f6c4743eb33e212159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af86b197f93b4f6c4743eb33e212159">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an end const_iterator.</dd></dl>
<p>For types that support get_next_offset offset or when container is empty, the end iterator is const_iterator{}. For types that do not support get_next_offset an end iterator is pointing pass the last element of container </p>

</div>
</div>
<a id="aa8638f22191adee9aac5b4468f643ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8638f22191adee9aac5b4468f643ae0">&#9670;&nbsp;</a></span>clast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::clast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const iterator pointing to the last element of container.</dd></dl>
<p>Calling on an empty container returns end iterator </p>

</div>
</div>
<a id="a302dd31350a6433f01d4808adf04a9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302dd31350a6433f01d4808adf04a9f1">&#9670;&nbsp;</a></span>closed_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad253e51211833b5c2b4867e2cbd4305d">range_t</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::closed_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Information about the buffer occupied by elements in the range [begin, last]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- iterator pointing to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>- iterator pointing to the last element in the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For any case, except when last element of range is last element of the collection, it returns:<ul>
<li>start of the first element.</li>
<li>offset of the last element data end.</li>
<li>offset of the last element buffer end. If range last is last element of collection then data end and buffer end point to the same position.</li>
</ul>
</dd></dl>
<p>All offsets values are relative to the buffer owned by the container. </p>

</div>
</div>
<a id="a9a9158c6e341074fa72be46cac1dc84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9158c6e341074fa72be46cac1dc84a">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if given offset in the buffer falls into a buffer used by the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to an element </td></tr>
    <tr><td class="paramname">position</td><td>- offset in the container's buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if position is in the element's buffer. and false otherwise. Element's buffer is retrieved using range(it). When iterator referes to container end or when position is npos the result will be false. </dd></dl>

</div>
</div>
<a id="ad8ae49c650483197ce08e074738443c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ae49c650483197ce08e074738443c8">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to the begging of the buffer or nullptr container has if no allocated buffer. </dd></dl>

</div>
</div>
<a id="a54516df7db6b828c9194c84d0e31f460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54516df7db6b828c9194c84d0e31f460">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const* <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Const pointer to the begging of the buffer or nullptr container has if no allocated buffer. </dd></dl>

</div>
</div>
<a id="a559b9e5fce71d956aadfc293603a04ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559b9e5fce71d956aadfc293603a04ce">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if container contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>False when container contains at least one element and true otherwise.</dd></dl>
<p>Both container with no buffer as well as container that has buffer that does not contain any valid elements will return true. </p>

</div>
</div>
<a id="ad35cf3455e5daeffd0acdb55730c133c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35cf3455e5daeffd0acdb55730c133c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a67aa09c32ee4a1db2529f0c4e9864ddb">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an end iterator.</dd></dl>
<p>An end iterator is pointing pass the last element of container. View might be pointing in a middle of a flat forward list so our last element might be not a last element of list. It is arbitrary what we are using as a pointer to the last element, as long as we are using it consistently. This implementation uses</p><ul>
<li>If next_offset is not 0 then location of next element in the list pass the view. This iterator is also a valid non-end iterator of container.</li>
<li>In all other cases pointer to the buffer pass the end of last element </li>
</ul>

</div>
</div>
<a id="ae6e181346b232fffbb2fa28decbaa35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e181346b232fffbb2fa28decbaa35b">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an end const_iterator.</dd></dl>
<p>An end iterator is pointing pass the last element of container View might be pointing in a middle of a flat forward list so our last element might be not a last element of list. It is arbitrary what we are using as a pointer to the last element, as long as we are using it consistently. This implementation uses</p><ul>
<li>If next_offset is not 0 then location of next element in the list pass the view. This iterator is also a valid non-end iterator of container.</li>
<li>In all other cases pointer to the buffer pass the end of last element </li>
</ul>

</div>
</div>
<a id="a5b660d2e668b5691f3d312080fbd128e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b660d2e668b5691f3d312080fbd128e">&#9670;&nbsp;</a></span>find_element_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::find_element_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element after the element that containes given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- offset in the conteiner's buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the found element, if it was found, and container's end const iterator otherwise.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container) because we have to performa linear search for an element from the start of container's buffer. </p>

</div>
</div>
<a id="af1b2a5bc864fa5828956b365d08564fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b2a5bc864fa5828956b365d08564fa">&#9670;&nbsp;</a></span>find_element_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::find_element_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element that containes given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- offset in the conteiner's buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the found element, if it was found, and container's end const iterator otherwise.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container) because we have to performa linear search for an element from the start of container's buffer. </p>

</div>
</div>
<a id="a638c1f688441fcd62106bc41d5b97eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638c1f688441fcd62106bc41d5b97eee">&#9670;&nbsp;</a></span>find_element_before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::find_element_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element before the element that containes given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- offset in the conteiner's buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the found element, if it was found, and container's end const iterator otherwise.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container) because we have to performa linear search for an element from the start of container's buffer. </p>

</div>
</div>
<a id="a713dba7d038e505408401d385cb85edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713dba7d038e505408401d385cb85edb">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the first element in the container.</dd></dl>
<p>Calling this method on a empty container will trigger fail-fast </p>

</div>
</div>
<a id="af433768411eca7c4d66cc3981675dab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af433768411eca7c4d66cc3981675dab2">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference to the first element in the container.</dd></dl>
<p>Calling this method on a empty container will trigger fail-fast </p>

</div>
</div>
<a id="a29e8aba8677b41d9ca76c7bfad7308ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e8aba8677b41d9ca76c7bfad7308ba">&#9670;&nbsp;</a></span>half_open_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad253e51211833b5c2b4867e2cbd4305d">range_t</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::half_open_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Information about the buffer occupied by elements in the range [begin, end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- iterator pointing to the first element. </td></tr>
    <tr><td class="paramname">end</td><td>- iterator pointing to the past last element in the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For any case, except when end element of range is the end element of the collection,<ul>
<li>start of the first element.</li>
<li>offset of the element before end data end.</li>
<li>offset of the element before end buffer end. If range end is colelction end then data end and buffer end point to the same position.</li>
</ul>
</dd></dl>
<p>All offsets values are relative to the buffer owned by the container. Algorithm has complexity O(number of elements in collection) because to find element before end we have to scan buffer from beginning. </p>

</div>
</div>
<a id="a54212a504f381d4134e6f4d6979cacc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54212a504f381d4134e6f4d6979cacc2">&#9670;&nbsp;</a></span>last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a67aa09c32ee4a1db2529f0c4e9864ddb">iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator pointing to the last element of container.</dd></dl>
<p>Calling on an empty container returns end iterator </p>

</div>
</div>
<a id="aaf156cfae7e23fed52b2d5d2e593fe9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf156cfae7e23fed52b2d5d2e593fe9c">&#9670;&nbsp;</a></span>last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns a const iterator pointing to the last element of container.</dd></dl>
<p>Calling on an empty container returns end iterator </p>

</div>
</div>
<a id="a6f771ccfdc8fbfa464d11d390c6e658d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f771ccfdc8fbfa464d11d390c6e658d">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True when containe contains at least one element and false otherwise. </dd></dl>

</div>
</div>
<a id="af3effc52dddb4b989b8b814882658ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3effc52dddb4b989b8b814882658ff8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename V , typename VV , typename  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&amp; <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; V, VV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- linked list we are moving from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe42d0f15035f58da13f952dfbc99d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe42d0f15035f58da13f952dfbc99d87">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&amp; <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiffl.html#a285870e8a61063c542965ad589fee6df">buffer_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>other_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_buffer</td><td>- linked list we are copying from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a267d2ca7575654e448aabcbdcb9f6518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267d2ca7575654e448aabcbdcb9f6518">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename V , typename VV , typename A , typename UNUSED  = std::enable_if&lt;std::is_assignable_v&lt;T*, V*&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&amp; <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; V, VV, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs view from container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>- For SFINAE we need to make this method a template Type const iterator is pointing to. </td></tr>
    <tr><td class="paramname">VV</td><td>- Type traits. </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- container we are constructing view from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>referencce to self </dd></dl>

</div>
</div>
<a id="a522578da80417f605fc414ad6e5b7458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522578da80417f605fc414ad6e5b7458">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename V , typename VV , typename A , typename UNUSED &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt;T, TT&gt;&amp; <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list.html">flat_forward_list</a>&lt; V, VV, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs ref or view from container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- element type </td></tr>
    <tr><td class="paramname">TT</td><td>- element type traits </td></tr>
    <tr><td class="paramname">A</td><td>- allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>referencce to self </dd></dl>

</div>
</div>
<a id="aa9c6cf398f09955478c9d74ce2c87f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c6cf398f09955478c9d74ce2c87f4d">&#9670;&nbsp;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#ad253e51211833b5c2b4867e2cbd4305d">range_t</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::<a class="el" href="structiffl_1_1range.html">range</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Information about the buffer occupied by an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For any element except the last, it returns:<ul>
<li>start element offset.</li>
<li>offset of element data end.</li>
<li>offset of element buffer end. For the last element data end and buffer end point to the same position.</li>
</ul>
</dd></dl>
<p>All offsets values are relative to the buffer owned by the container. </p>

</div>
</div>
<a id="a0034e4b0b24a3ca72f8428ee5c615664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0034e4b0b24a3ca72f8428ee5c615664">&#9670;&nbsp;</a></span>remaining_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::remaining_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in the buffer not used by the existing elements. </dd></dl>

</div>
</div>
<a id="ac851e4a7d87214d118afdae000ddeaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac851e4a7d87214d118afdae000ddeaab">&#9670;&nbsp;</a></span>required_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::required_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns capacity used by the element's data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to the element we are returning size for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns size of the element without paddint </dd></dl>

</div>
</div>
<a id="a36e92edb9357a20ed6df97200b42f304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e92edb9357a20ed6df97200b42f304">&#9670;&nbsp;</a></span>revalidate_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::revalidate_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates that buffer contains a valid list. </p>
<dl class="section return"><dt>Returns</dt><dd>true if valid list was found and false otherwise.</dd></dl>
<p>You must call this method after passing pointer to container's buffer to a function that might change buffer content. If valid list of found then buff().last will be pointing to the element element that was found. If no valid list was found then buff().last will be nullptr. </p>

</div>
</div>
<a id="a1d53d9f52a88db6c43c2f28a4c0f75d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d53d9f52a88db6c43c2f28a4c0f75d3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in the container.</dd></dl>
<p>Cost of this algorithm is O(nuber of elements in container). Container does not actively cache/updates element count so we need to scan list to find number of elements. </p>

</div>
</div>
<a id="ad959382b0fd29650b75b88f666b9b8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad959382b0fd29650b75b88f666b9b8d5">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html">flat_forward_list_ref</a>&lt; T, TT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps content of this container and the other container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- reference to the other container </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">might</td><td>throw std::bad_alloc if allocator swap throws or if allocators do not suport swap, and we need to make a copy of elements, which involves allocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20aba1766305f168d5f12d7652090e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20aba1766305f168d5f12d7652090e4e">&#9670;&nbsp;</a></span>total_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::total_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Buffer size. </dd></dl>

</div>
</div>
<a id="a87dc2ddceaffcb697e3c9718b7578c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dc2ddceaffcb697e3c9718b7578c9e">&#9670;&nbsp;</a></span>used_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::used_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in the bufer used by existing elements. </dd></dl>

</div>
</div>
<a id="acc0f2b104557ac0a55611165aa26a2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0f2b104557ac0a55611165aa26a2f3">&#9670;&nbsp;</a></span>used_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TT = flat_forward_list_traits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#a48c6c8d170c7b21d2fe2f2f3c4abdc91">size_type</a> <a class="el" href="classiffl_1_1flat__forward__list__ref.html">iffl::flat_forward_list_ref</a>&lt; T, TT &gt;::used_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiffl_1_1flat__forward__list__ref.html#adf130ebea5d4ecbbaf17692a22142ef7">const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- iterator pointing to the element we are returning size for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For any element except last returns distance from element start to the start of the next element. For the last element it returns used_capacity </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="iffl__list_8h_source.html">iffl_list.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: Intrusive Flat Forward List for Plain Old Definition (POD) types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.3.4</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Intrusive Flat Forward List for Plain Old Definition (POD) types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This header only library that implements intrusive flat forward list (iffl).</p>
<ul>
<li><b>Intrusive</b> - Pointer to the next element must be a part of the container's elements data type;</li>
<li><b>Flat</b> - All elements of container are laid out in a continues block of memory, rather than each element being allocated separately.</li>
<li><b>Forward</b> <b>List</b> - Elements have information on how to locate start of the next element. There is no way to get to the previous element other than linear scan from the beginning of the list. Because this is a <b>Flat</b> container instead of pointers to the next element, it uses offset to the next element from the beginning of the current element.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/PODType">Plain Old Definition (POD)</a></li>
</ul>
<p><a href="https://github.com/vladp72/iffl/tree/master/include">Implementation</a></p>
<p><a href="https://vladp72.github.io/iffl/html/annotated.html">Doxygen documentation</a></p>
<p><a href="https://github.com/vladp72/iffl/tree/master/test">Tests and samples</a></p>
<p><a href="https://github.com/vladp72/iffl/blob/master/CMakeLists.txt">This project is compiled and published using CMake</a></p>
<p>Tests and samples are build and verified on</p><ul>
<li>Windows 10 using Visual Studio C++ compiler</li>
<li>Ubuntu Linux using both clang and gcc.</li>
</ul>
<h2>Motivation</h2>
<p>Often times when dealing with OS or just C interface we need to pass in or parse a a buffer that contains a linked list of variable size structures.</p>
<p>These POD typess have following general structure: </p><div class="fragment"><div class="line">                     ------------------------------------------------------------</div><div class="line">                     |                                                          |</div><div class="line">                     |                                                          V</div><div class="line">| &lt;fields&gt; | offset to next element | &lt;offsets of data&gt; | [data] | [padding] || [next element] ...</div><div class="line">|                        header                         | [data] | [padding] || [next element] ...</div></div><!-- fragment --> <div class="fragment"><div class="line">typedef struct _FILE_FULL_EA_INFORMATION {</div><div class="line">  ULONG  NextEntryOffset; // intrusive hook with offset of the next element</div><div class="line">  UCHAR  Flags;</div><div class="line">  UCHAR  EaNameLength;</div><div class="line">  USHORT EaValueLength;</div><div class="line">  CHAR   EaName[1];</div><div class="line">} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;</div></div><!-- fragment --><p> <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_file_full_ea_information">FILE_FULL_EA_INFORMATION documentation</a> </p><div class="fragment"><div class="line">typedef struct _FILE_NOTIFY_EXTENDED_INFORMATION {</div><div class="line">  DWORD         NextEntryOffset; // intrusive hook with offset of the next element</div><div class="line">  DWORD         Action;</div><div class="line">  LARGE_INTEGER CreationTime;</div><div class="line">  LARGE_INTEGER LastModificationTime;</div><div class="line">  LARGE_INTEGER LastChangeTime;</div><div class="line">  LARGE_INTEGER LastAccessTime;</div><div class="line">  LARGE_INTEGER AllocatedLength;</div><div class="line">  LARGE_INTEGER FileSize;</div><div class="line">  DWORD         FileAttributes;</div><div class="line">  DWORD         ReparsePointTag;</div><div class="line">  LARGE_INTEGER FileId;</div><div class="line">  LARGE_INTEGER ParentFileId;</div><div class="line">  DWORD         FileNameLength;</div><div class="line">  WCHAR         FileName[1];</div><div class="line">} FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;</div></div><!-- fragment --><p> <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-_file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION documentation</a></p>
<p>Output for the following information classes from <a href="https://msdn.microsoft.com/en-us/8f02e824-ca41-48c1-a5e8-5b12d81886b5">FILE_INFO_BY_HANDLE_CLASS</a> </p><div class="fragment"><div class="line">FileIdBothDirectoryInfo</div><div class="line">FileIdBothDirectoryRestartInfo</div><div class="line">FileIoPriorityHintInfo</div><div class="line">FileRemoteProtocolInfo</div><div class="line">FileFullDirectoryInfo</div><div class="line">FileFullDirectoryRestartInfo</div><div class="line">FileStorageInfo</div><div class="line">FileAlignmentInfo</div><div class="line">FileIdInfo</div><div class="line">FileIdExtdDirectoryInfo</div><div class="line">FileIdExtdDirectoryRestartInfo</div><div class="line">For example output buffer for</div></div><!-- fragment --><p> For example on success following call </p><div class="fragment"><div class="line">GetFileInformationByHandleEx(file_handle, FileIdBothDirectoryInfo, buffer, buffer_size);</div></div><!-- fragment --><p> will fill output buffer with structures </p><div class="fragment"><div class="line">typedef struct _FILE_ID_BOTH_DIR_INFO {</div><div class="line">  DWORD         NextEntryOffset; // intrusive hook with offset of the next element</div><div class="line">  DWORD         FileIndex;</div><div class="line">  LARGE_INTEGER CreationTime;</div><div class="line">  LARGE_INTEGER LastAccessTime;</div><div class="line">  LARGE_INTEGER LastWriteTime;</div><div class="line">  LARGE_INTEGER ChangeTime;</div><div class="line">  LARGE_INTEGER EndOfFile;</div><div class="line">  LARGE_INTEGER AllocationSize;</div><div class="line">  DWORD         FileAttributes;</div><div class="line">  DWORD         FileNameLength;</div><div class="line">  DWORD         EaSize;</div><div class="line">  CCHAR         ShortNameLength;</div><div class="line">  WCHAR         ShortName[12];</div><div class="line">  LARGE_INTEGER FileId;</div><div class="line">  WCHAR         FileName[1];</div><div class="line">} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;</div></div><!-- fragment --><p> You would get the same output when you call NtQueryDirectoryFile with <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/ns-ntifs-_file_both_dir_information">FileIdBothDirectoryInfo</a>.</p>
<p>Other class of types that fall into similar category are types that do not have next element offset, but it can be calculated from the element size. Offset of the next element is size of this element data, plus optional padding to keep ext element properly aligned </p><div class="fragment"><div class="line">                     -----------------------------------</div><div class="line">                     |                                 |</div><div class="line">    (next element offset = sizeof(this element)        |</div><div class="line">                     |   + padding)                    |</div><div class="line">                     |                                 V</div><div class="line">| &lt;fields&gt; | &lt;offsets of data&gt; | [data] | [padding] || [next element] ...</div><div class="line">|       header                 | [data] | [padding] || [next element] ...</div></div><!-- fragment --><p>Exanmples:</p>
<p>CLUSPROP_SYNTAX</p><ul>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/property-lists">property list</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/data-structures">data structures</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/clusapi/ns-clusapi-clusprop_syntax">cluster property syntax</a></li>
</ul>
<div class="fragment"><div class="line">typedef union CLUSPROP_SYNTAX {</div><div class="line">  DWORD  dw;</div><div class="line">  struct {</div><div class="line">      WORD wFormat;</div><div class="line">      WORD wType;</div><div class="line">  } DUMMYSTRUCTNAME;</div><div class="line">} CLUSPROP_SYNTAX;</div></div><!-- fragment --><p> <a href="https://docs.microsoft.com/en-us/windows/desktop/api/clusapi/ns-clusapi-clusprop_value">CLUSPROP_VALUE</a> </p><div class="fragment"><div class="line">typedef struct CLUSPROP_VALUE {</div><div class="line">    CLUSPROP_SYNTAX Syntax;</div><div class="line">    DWORD           cbLength;</div><div class="line">} CLUSPROP_VALUE;</div></div><!-- fragment --><h2>Overview</h2>
<p>This header only library provides an algorithms and containers for safe creation and parsing such a collection. It includes:</p><ul>
<li><a href="https://vladp72.github.io/iffl/html/classiffl_1_1flat__forward__list__ref.html"><b>flat_forward_list_ref</b></a> and <a href="https://vladp72.github.io/iffl/html/namespaceiffl.html"><b>flat_forward_list_view</b></a> a non-owning containers that allows iterating over a flat forward list in a buffer.</li>
<li><a href="https://vladp72.github.io/iffl/html/namespaceiffl.html"><b>flat_forward_list_validate</b></a> a family of functions that help to validate untrusted buffer, and returns a ref/view to a subrange to the buffer that contains valid list.</li>
<li><a href="https://vladp72.github.io/iffl/html/classiffl_1_1flat__forward__list.html"><b>flat_forward_list</b></a> a container that owns and resizes buffer as you are adding/removing elements.</li>
<li><a href="https://vladp72.github.io/iffl/html/classiffl_1_1debug__memory__resource.html"><b>debug_memory_resource</b></a> a memory resource that help with debugging</li>
<li><a href="https://vladp72.github.io/iffl/html/classiffl_1_1input__buffer__memory__resource.html"><b>input_buffer_memory_resource</b></a> a memory resource that helps in scenarios where server have to fill a passed in buffer.</li>
</ul>
<h2>Boilerplate</h2>
<p>Types that are usually used with this container are POD types defined elsewhere. We cannot extent these types. We do need several methods to be able to traverse and modify elements in the container:</p>
<ul>
<li>Mandatory methods have to be implemented in all types and all scenarios<ul>
<li>Returns minimum required buffer size. For example minimum required buffer size for FILE_FULL_EA_INFORMATION is offset of field EaValueLength, plus size of EaValueLength. If buffer is smaller then we cannot even tell size used by the data of the element.<ul>
<li><code>static size_t minimum_size() noexcept;</code></li>
</ul>
</li>
<li>Returns element size calculated from size of data contained by the element. For example for FILE_FULL_EA_INFORMATION it would be size of minimum header plus value in EaNameLength and EaValueLength.<ul>
<li><code>static size_t get_size(&lt;type&gt; const &amp;e) noexcept;</code></li>
</ul>
</li>
</ul>
</li>
<li>Optional method that validates element contains correct data. For instance it can check that size of the fields fit in the element buffer. For example for FILE_FULL_EA_INFORMATION it can check that element size would not be larger than offset to the next element.<ul>
<li><code>static bool validate(size_t buffer_size, &lt;type&gt; const &amp;e) noexcept;</code></li>
</ul>
</li>
<li>Types that have offset to the next element must implement method that return that value. Container uses this method to traverse list, but if type does not have that field then you should not implement this method. Without this method container will use get_size as an offset to the next element.<ul>
<li><code>static size_t get_next_offset(&lt;type&gt; const &amp;e) noexcept;</code></li>
</ul>
</li>
<li>For scenario where we need to modify list, and the type supports next element offset field, you need to implement a method that allows setting updating this field. If type does not support next element offset then do not implement this method. If this method is not present then container assumes next offset field is not part of the type and will no-op updating it.<ul>
<li><code>static void set_next_element_offset(&lt;type&gt; &amp;buffer, size_t size) noexcept;</code></li>
</ul>
</li>
<li>Optionally you can add a static variable that tells alignment required for an element header. Container will add padding to the element to keep next element properly aligned. If this member is absent then container assumes that elements can be 1 byte aligned and would not add any padding. Reading unaligned data might cause an exception or sig-fault on some platforms, unless you explicitly annotate your pointers as unaligned.<ul>
<li><code>constexpr static size_t const alignment{ &lt;alignment&gt; }</code></li>
</ul>
</li>
</ul>
<p>User can pass a type that implements these method as an explicit template parameter or she can specialize <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">iffl::flat_forward_list_traits</a> for the type. By default all containers and algorithms will look for this specialization.</p>
<p>List of methods that can be implemented: </p><div class="fragment"><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;FLAT_FORWARD_LIST_TEST&gt; {</div><div class="line">        constexpr static size_t const alignment{ alignof(FLAT_FORWARD_LIST_TEST) };</div><div class="line">        constexpr static size_t minimum_size() noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static size_t get_next_offset(FLAT_FORWARD_LIST_TEST const &amp;e) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static void set_next_offset(FLAT_FORWARD_LIST_TEST &amp;e, size_t size) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static size_t get_size(FLAT_FORWARD_LIST_TEST const &amp;e) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static bool validate(size_t buffer_size, FLAT_FORWARD_LIST_TEST const &amp;e) noexcept {&lt;implementation&gt;}</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>By default you will not explicitly spell that for FILE_FULL_EA_INFORMATION we should use iffl::flat_forward_list_traits&lt;FILE_FULL_EA_INFORMATION&gt;. Compiler will do the right thing using partial template specialization magic.</p>
<div class="fragment"><div class="line">template &lt;typename T,</div><div class="line">          typename TT = flat_forward_list_traits&lt;T&gt;,</div><div class="line">          typename A = std::allocator&lt;T&gt;&gt;</div><div class="line">class flat_forward_list final;</div></div><!-- fragment --><p> You can simply declare container as <code><a class="el" href="classiffl_1_1flat__forward__list.html" title="Intrusive flat forward list container.">iffl::flat_forward_list</a> final&lt;FILE_FULL_EA_INFORMATION&gt;</code>. If you want to point container to a different set of traits then you can pass them in explicitly <code><a class="el" href="classiffl_1_1flat__forward__list.html" title="Intrusive flat forward list container.">iffl::flat_forward_list</a> final&lt;FILE_FULL_EA_INFORMATION, <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">iffl::flat_forward_list_traits</a>&lt;FLAT_FORWARD_LIST_TEST&gt;&gt;</code></p>
<p>Let's take a look at a complete <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_ea.h">implementation</a> for FILE_FULL_EA_INFORMATION:</p>
<div class="fragment"><div class="line">typedef struct _FILE_FULL_EA_INFORMATION {</div><div class="line">    ULONG  NextEntryOffset;</div><div class="line">    UCHAR  Flags;</div><div class="line">    UCHAR  EaNameLength;</div><div class="line">    USHORT EaValueLength;</div><div class="line">    CHAR   EaName[1];</div><div class="line">} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;</div><div class="line"></div><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;FILE_FULL_EA_INFORMATION&gt; {</div><div class="line">    </div><div class="line">        constexpr static size_t const alignment{ alignof(FILE_FULL_EA_INFORMATION) };</div><div class="line">        </div><div class="line">        static size_t get_next_offset(FILE_FULL_EA_INFORMATION const &amp;e) noexcept {</div><div class="line">            return e.NextEntryOffset;</div><div class="line">        }</div><div class="line">        </div><div class="line">        static size_t minimum_size() noexcept {</div><div class="line">            return FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength);</div><div class="line">        }</div><div class="line">        </div><div class="line">        static size_t get_size(FILE_FULL_EA_INFORMATION const &amp;e) {</div><div class="line">            return  FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) +</div><div class="line">                    e.EaNameLength +</div><div class="line">                    e.EaValueLength;</div><div class="line">        }</div><div class="line">        </div><div class="line">        static bool validate_size(FILE_FULL_EA_INFORMATION const &amp;e, size_t buffer_size) noexcept {</div><div class="line">        if (e.NextEntryOffset == 0) {</div><div class="line">                return  get_size(e) &lt;= buffer_size;</div><div class="line">            } else if (e.NextEntryOffset &lt;= buffer_size) {</div><div class="line">                return  get_size(e) &lt;= e.NextEntryOffset;</div><div class="line">            }</div><div class="line">            return false;</div><div class="line">        }</div><div class="line"></div><div class="line">        static bool validate_data(FILE_FULL_EA_INFORMATION const &amp;e) noexcept {</div><div class="line">            return true;</div><div class="line">        }</div><div class="line">        </div><div class="line">        static bool validate(size_t buffer_size, FILE_FULL_EA_INFORMATION const &amp;e) noexcept {</div><div class="line">            return validate_size(e, buffer_size) &amp;&amp; validate_data(e);</div><div class="line">        }</div><div class="line">        </div><div class="line">        static void set_next_offset(FILE_FULL_EA_INFORMATION &amp;e, size_t size) noexcept {</div><div class="line">            FFL_CODDING_ERROR_IF_NOT(size == 0 || size &gt;= get_size(e));</div><div class="line">            e.NextEntryOffset = static_cast&lt;ULONG&gt;(size);</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>Now FILE_FULL_EA_INFORMATION is ready to be used with iffl containers.</p>
<div class="fragment"><div class="line">using ea_iffl_ref = iffl::flat_forward_list_ref&lt;FILE_FULL_EA_INFORMATION&gt;;</div><div class="line">using ea_iffl_view = iffl::flat_forward_list_view&lt;FILE_FULL_EA_INFORMATION&gt;;</div><div class="line">using ea_iffl = iffl::flat_forward_list&lt;FILE_FULL_EA_INFORMATION&gt;;</div><div class="line">using pmr_ea_iffl = iffl::pmr_flat_forward_list&lt;FILE_FULL_EA_INFORMATION&gt;;</div></div><!-- fragment --><p>Class pod_array_list_entry is an example of type that does not have offset to the next element. For that type we do not implement get_next_offset and set_next offset. A complete implementation is in <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_list_array.h">test/iffl_list_array.h</a>.</p>
<div class="fragment"><div class="line">template &lt;typename T&gt;</div><div class="line">struct pod_array_list_entry {</div><div class="line">    unsigned short length;</div><div class="line">    T arr[1];</div><div class="line">    </div><div class="line">    using type = T;</div><div class="line">};</div><div class="line"></div><div class="line">template &lt;typename T&gt;</div><div class="line">struct pod_array_list_entry_traits {</div><div class="line"></div><div class="line">    using header_type = pod_array_list_entry&lt;T&gt;;</div><div class="line"></div><div class="line">    constexpr static size_t const alignment{ alignof(header_type) };</div><div class="line"></div><div class="line">    constexpr static size_t minimum_size() noexcept {</div><div class="line">        return FFL_SIZE_THROUGH_FIELD(header_type, length);</div><div class="line">    }</div><div class="line"></div><div class="line">    constexpr static size_t get_size(header_type const &amp;e) {</div><div class="line">        return FFL_FIELD_OFFSET(header_type, arr) + e.length * sizeof(T);</div><div class="line">    }</div><div class="line"></div><div class="line">    constexpr static bool validate(size_t buffer_size, header_type const &amp;e) noexcept {</div><div class="line">        return  get_size(e) &lt;= buffer_size;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> You can use tis type to declare variable array of long long</p>
<div class="fragment"><div class="line">using long_long_array_list_entry = pod_array_list_entry&lt;long long&gt;;</div><div class="line"></div><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;long_long_array_list_entry&gt;</div><div class="line">        : public pod_array_list_entry_traits&lt;long_long_array_list_entry::type&gt; {</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line">using long_long_array_list = iffl::pmr_flat_forward_list&lt;long_long_array_list_entry&gt;;</div></div><!-- fragment --><p> Type long_long_array_list is a list of variable length arrays of long long.</p>
<p>Or a variable array of char</p>
<div class="fragment"><div class="line">using char_array_list_entry = pod_array_list_entry&lt;char&gt;;</div><div class="line"></div><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;char_array_list_entry&gt;</div><div class="line">        : public pod_array_list_entry_traits&lt;char_array_list_entry::type&gt; {</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line">using char_array_list = iffl::pmr_flat_forward_list&lt;char_array_list_entry&gt;;</div></div><!-- fragment --><p> Type char_array_list is a list of variable length arrays of char.</p>
<h2>Scenarios</h2>
<h3>Adding elements to flat forward list</h3>
<p>Since FILE_FULL_EA_INFORMATION is a Plain Old Definition (POD) it does not have constructor, container methods that deal with creation of new elements allow passing a functor that will be called once container allocates requested space for the element to initialize element data. In this sample you can see prepare_ea_and_call_handler is calling emplace_front and emplace_back and is passing in a lambda that initializes element. If you want to zero initialize element then call container.push_back(element_size). If you want to initialize an element using a buffer that contains element blueprint then call .push_back(element_size, bluprint_buffer). It will initialize element by copy blueprint buffer. Note that for last element container always resets next element offset after element construction is done so you do not need to worry about that. A complete sample is located in <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_ea_usecase.cpp">test/iffl_ea_usecase.cpp</a>.</p>
<div class="fragment"><div class="line">ea_iffl eas;</div><div class="line"></div><div class="line">char const ea_name0[] = &quot;TEST_EA_0&quot;;</div><div class="line"></div><div class="line">// Add EA to the front of the list</div><div class="line"></div><div class="line">eas.emplace_front(FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) + sizeof(ea_name0)-sizeof(char), </div><div class="line">                 [](FILE_FULL_EA_INFORMATION &amp;e, size_t new_element_size) noexcept {</div><div class="line">                    e.Flags = 0;</div><div class="line">                    e.EaNameLength = sizeof(ea_name0)-sizeof(char);</div><div class="line">                    e.EaValueLength = 0;</div><div class="line">                    iffl::copy_data(e.EaName, ea_name0, sizeof(ea_name0)-sizeof(char));</div><div class="line">                  });</div><div class="line"></div><div class="line">char const ea_name1[] = &quot;TEST_EA_1&quot;;</div><div class="line">char const ea_data1[] = {1,2,3};</div><div class="line"></div><div class="line">// Add EA to the end of the list</div><div class="line"></div><div class="line">eas.emplace_back(FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) + sizeof(ea_name1)-sizeof(char) + sizeof(ea_data1),</div><div class="line">                 [](FILE_FULL_EA_INFORMATION &amp;e, size_t new_element_size) noexcept {</div><div class="line">                    e.Flags = 1;</div><div class="line">                    e.EaNameLength = sizeof(ea_name1)-sizeof(char);</div><div class="line">                    e.EaValueLength = sizeof(ea_data1);</div><div class="line">                    iffl::copy_data(e.EaName, ea_name1, sizeof(ea_name1)-sizeof(char));</div><div class="line">                    iffl::copy_data(e.EaName + sizeof(ea_name1)-sizeof(char), ea_data1, sizeof(ea_data1));</div><div class="line">                  });</div><div class="line"></div><div class="line">char const ea_name2[] = &quot;TEST_EA_2&quot;;</div><div class="line">char const ea_data2[] = { 1,2,3,4,5,6,7,8,9,0xa,0xb,0xc,0xd,0xf };</div><div class="line"></div><div class="line">// Add EA to the front of the list</div><div class="line"></div><div class="line">eas.emplace_front(FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) + sizeof(ea_name2)-sizeof(char) + sizeof(ea_data2),</div><div class="line">                 [](FILE_FULL_EA_INFORMATION &amp;e, size_t new_element_size) noexcept {</div><div class="line">                    e.Flags = 2;</div><div class="line">                    e.EaNameLength = sizeof(ea_name2)-sizeof(char);</div><div class="line">                    e.EaValueLength = sizeof(ea_data2);</div><div class="line">                    iffl::copy_data(e.EaName, ea_name2, sizeof(ea_name2)-sizeof(char));</div><div class="line">                    iffl::copy_data(e.EaName + sizeof(ea_name2)-sizeof(char), ea_data2, sizeof(ea_data2));</div><div class="line">                  });</div></div><!-- fragment --><p> will produce following list of extended attributes </p><div class="fragment"><div class="line">FILE_FULL_EA_INFORMATION[0] @ = 0x0x607000000100, buffer offset 0</div><div class="line">FILE_FULL_EA_INFORMATION[0].NextEntryOffset = 32</div><div class="line">FILE_FULL_EA_INFORMATION[0].Flags = 2</div><div class="line">FILE_FULL_EA_INFORMATION[0].EaNameLength = 9 &quot;TEST_EA_2&quot;</div><div class="line">FILE_FULL_EA_INFORMATION[0].EaValueLength = 14 123456789abcdf</div><div class="line"></div><div class="line">FILE_FULL_EA_INFORMATION[1] @ = 0x0x607000000120, buffer offset 32</div><div class="line">FILE_FULL_EA_INFORMATION[1].NextEntryOffset = 20</div><div class="line">FILE_FULL_EA_INFORMATION[1].Flags = 0</div><div class="line">FILE_FULL_EA_INFORMATION[1].EaNameLength = 9 &quot;TEST_EA_0&quot;</div><div class="line">FILE_FULL_EA_INFORMATION[1].EaValueLength = 0</div><div class="line"></div><div class="line">FILE_FULL_EA_INFORMATION[2] @ = 0x0x607000000134, buffer offset 52</div><div class="line">FILE_FULL_EA_INFORMATION[2].NextEntryOffset = 0</div><div class="line">FILE_FULL_EA_INFORMATION[2].Flags = 1</div><div class="line">FILE_FULL_EA_INFORMATION[2].EaNameLength = 9 &quot;TEST_EA_1&quot;</div><div class="line">FILE_FULL_EA_INFORMATION[2].EaValueLength = 3 123</div></div><!-- fragment --><h3>Adding elements to flat forward list over input buffer not owned by the calee.</h3>
<p>A complete sample is located in <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_c_api_usecase2.cpp">test/iffl_c_api_usecase2.cpp</a>.</p>
<div class="fragment"><div class="line">unsigned short idx{ 0 };</div><div class="line"></div><div class="line">bool server_api_call(char *buffer, size_t *buffer_size) noexcept {</div><div class="line">    bool result{ false };</div><div class="line">    //</div><div class="line">    // If user did not pass a valid buffer then bail out</div><div class="line">    //</div><div class="line">    if (!buffer || !buffer_size) {</div><div class="line">        return result;</div><div class="line">    }</div><div class="line">    //</div><div class="line">    // when container allocates memory this memory resource </div><div class="line">    // returns pointer to the input buffer</div><div class="line">    //</div><div class="line">    iffl::input_buffer_memory_resource input_buffer{reinterpret_cast&lt;void *&gt;(buffer), *buffer_size};</div><div class="line">    //</div><div class="line">    // Create container that will use above memory resource</div><div class="line">    //</div><div class="line">    char_array_list data{ &amp;input_buffer };</div><div class="line">    //</div><div class="line">    // Resizing container to the input buffer size.</div><div class="line">    // Container will ask memory resource for allocation</div><div class="line">    // and resource will return pointer to the input buffer.</div><div class="line">    // Rest of algorithm will avoid making any calls that can</div><div class="line">    // trigger memory reallocation. If we trigger that then </div><div class="line">    // resource will throw std::bad_alloc because it does not have</div><div class="line">    // any more memory it can allocate.</div><div class="line">    //</div><div class="line">    data.resize_buffer(*buffer_size);</div><div class="line">    //</div><div class="line">    // idx is a global variable that remembers where server stopped last time.</div><div class="line">    // Keep adding elements for as long as buffer has capacity</div><div class="line">    //</div><div class="line">    for (;; ++idx) {</div><div class="line">        //</div><div class="line">        // Estimate size of the element we are inserting</div><div class="line">        //</div><div class="line">        size_t element_size{ char_array_list::traits::minimum_size() + idx * sizeof(char_array_list::value_type::type) };</div><div class="line">        //</div><div class="line">        // try_emplace_back will succeed if we can add element</div><div class="line">        // without triggering reallocation, otherwise it will return </div><div class="line">        // false.</div><div class="line">        //</div><div class="line">        if (!data.try_emplace_back(element_size,</div><div class="line">                                    [] (char_array_list_entry &amp;e, size_t element_size) noexcept {</div><div class="line">                                        e.length = idx;</div><div class="line">                                        std::fill(e.arr, e.arr + e.length, static_cast&lt;char&gt;(idx)+1);</div><div class="line">                                    })) {</div><div class="line">            //</div><div class="line">            // Before we return back to the caller make sure we are not leaking any</div><div class="line">            // values that would help caller to attack server.</div><div class="line">            //</div><div class="line">            data.fill_padding();</div><div class="line">            //</div><div class="line">            // Tell client up to what point buffer contains valid data</div><div class="line">            //</div><div class="line">            *buffer_size = data.used_capacity();</div><div class="line">            break;</div><div class="line">        }</div><div class="line">        //</div><div class="line">        // If we inserted at least one element then return true</div><div class="line">        //</div><div class="line">        result = true;</div><div class="line">    }</div><div class="line">    return result;</div><div class="line">}</div></div><!-- fragment --><h3>Validate input buffer</h3>
<p>If you are receiving a untrusted buffer that is expected to contain a flat forward list you can validate it using <b>flat_forward_list_validate</b> family of function.</p>
<div class="fragment"><div class="line">template&lt;typename T,</div><div class="line">         typename TT = flat_forward_list_traits&lt;T&gt;,</div><div class="line">         typename F = default_validate_element_fn&lt;T, TT&gt;&gt;</div><div class="line">constexpr inline std::pair&lt;bool, flat_forward_list_ref&lt;T, TT&gt;&gt; </div><div class="line">  flat_forward_list_validate(char const *first,</div><div class="line">                             char const *end, </div><div class="line">                             F const &amp;validate_element_fn = default_validate_element_fn&lt;T, TT&gt;{}) noexcept;</div><div class="line"></div><div class="line">template&lt;typename T,</div><div class="line">         typename TT = flat_forward_list_traits&lt;T&gt;,</div><div class="line">         typename F = default_validate_element_fn&lt;T, TT&gt;&gt;</div><div class="line">constexpr inline std::pair&lt;bool, flat_forward_list_ref&lt;T, TT&gt;&gt; </div><div class="line">  flat_forward_list_validate(char *first,</div><div class="line">                             char *end,</div><div class="line">                             F const &amp;validate_element_fn = default_validate_element_fn&lt;T, TT&gt;{}) noexcept;</div></div><!-- fragment --><p>Function returns a pair of boolean and a reference or view. If passed parameter is a non-const buffer then result is a reference. If input buffer is const then result is a view (const reference). Boolean indicates if buffer contains a valid list. Even if list is broken, and function returns false, view will point to the subset of the buffer that contains a valid list. For instance if a pointer to the next element refers outside of the buffer range, then validate would abort, and return false, but returned reference/view will describe element from the beginning to the last valid element.</p>
<p>You can choose to be strict and reject invalid buffer. A complete sample is in <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_test_cases.cpp">test/iffl_test_cases.cpp</a>.</p>
<div class="fragment"><div class="line">auto [is_valid, view] = iffl::flat_forward_list_validate&lt;FILE_FULL_EA_INFORMATION&gt;(std::begin(buffer), std::end(buffer));</div><div class="line">if (is_valid) {</div><div class="line">  std::for_each(view.begin(), view.begin(), </div><div class="line">                [](FLAT_FORWARD_LIST_TEST &amp;e) noexcept {</div><div class="line">                    print_element(e);</div><div class="line">                });</div><div class="line">    return true;</div><div class="line">} else {</div><div class="line">    return false;</div><div class="line">}</div></div><!-- fragment --><p> Or to handle as much of the buffer as you can. </p><div class="fragment"><div class="line">auto [is_valid, view] = iffl::flat_forward_list_validate&lt;FILE_FULL_EA_INFORMATION&gt;(std::begin(buffer), std::end(buffer));</div><div class="line">std::for_each(view.begin(), view.begin(), </div><div class="line">              [](FLAT_FORWARD_LIST_TEST &amp;e) noexcept {</div><div class="line">                  print_element(e);</div><div class="line">              });</div><div class="line">return is_valid;</div></div><!-- fragment --><p> In the samples above we traverse buffer two times. It is possible to traverse and handle elements in a single loop by passing your own functor in place of the default functor that calls trait's validate method. A complete sample is in <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_ea_usecase.cpp">test/iffl_ea_usecase.cpp</a>.</p>
<div class="fragment"><div class="line">FILE_FULL_EA_INFORMATION const *failed_validation{nullptr};</div><div class="line">size_t invalid_element_length{0};</div><div class="line"></div><div class="line">auto[is_valid, buffer_view] =</div><div class="line">    iffl::flat_forward_list_validate&lt;FILE_FULL_EA_INFORMATION&gt;(</div><div class="line">        buffer,</div><div class="line">        buffer + buffer_lenght,</div><div class="line">        [&amp;failed_validation, &amp;invalid_element_length] (size_t buffer_size,</div><div class="line">                                                       FILE_FULL_EA_INFORMATION const &amp;e) -&gt; bool {</div><div class="line">            //</div><div class="line">            // validate element</div><div class="line">            //</div><div class="line">            bool const is_valid{ iffl::flat_forward_list_traits&lt;FILE_FULL_EA_INFORMATION&gt;::validate(buffer_size, e) };</div><div class="line">            //</div><div class="line">            // if element is valid then process element</div><div class="line">            //</div><div class="line">            if (is_valid) {</div><div class="line">                handle_validated_element(e);</div><div class="line">            } else {</div><div class="line">                //</div><div class="line">                // Save additional information about element that failed validation</div><div class="line">                //</div><div class="line">                invalid_element_length = buffer_size;</div><div class="line">                failed_validation = &amp;e;</div><div class="line">            }</div><div class="line">            //</div><div class="line">            // validation loop is aborted if element is not valid</div><div class="line">            //</div><div class="line">            return is_valid;</div><div class="line">        });</div></div><!-- fragment --><p> You can use flat_forward_list_validate as if it is a find-first algorithm and abort validation as soon as you've found an element you are looking for.</p>
<h3>Passing buffer ownership across C interface avoiding extra copy.</h3>
<p>If server and client can agree on how to allocate an deallocate buffer then you can create buffer using flat_forward_list, detach ownership of buffer from container, pass pointers to the buffer over a C interface, callee can take ownership of the buffer, and deallocate once processing is done.</p>
<p>A complete sample is located in <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_c_api_usecase1.cpp">test/iffl_c_api_usecase1.cpp</a>.</p>
<p>In this example we will use a global variable providing a common memory resource for client and server. </p><div class="fragment"><div class="line">iffl::debug_memory_resource global_memory_resource;</div></div><!-- fragment --><p> Server creates list, and returns pointers to the buffer containing list. </p><div class="fragment"><div class="line">bool server_api_call(char **buffer, size_t *buffer_size) noexcept {</div><div class="line">    if (!buffer || !buffer_size) {</div><div class="line">        return false;</div><div class="line">    }</div><div class="line"></div><div class="line">    try {</div><div class="line">    </div><div class="line">        char_array_list data{ &amp;global_memory_resource };</div><div class="line">    </div><div class="line">        unsigned short array_size{ 10 };</div><div class="line">        size_t element_buffer_size{ char_array_list_entry::byte_size_to_array_size(array_size) };</div><div class="line">        char pattern{ 1 };</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern] (char_array_list_entry &amp;e,</div><div class="line">                                                 size_t element_size) noexcept {</div><div class="line">                               e.length = array_size;</div><div class="line">                               std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line"></div><div class="line">        array_size = 5;</div><div class="line">        element_buffer_size = char_array_list_entry::byte_size_to_array_size(array_size);</div><div class="line">        pattern = 2;</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern](char_array_list_entry &amp;e,</div><div class="line">                                                size_t element_size) noexcept {</div><div class="line">                              e.length = array_size;</div><div class="line">                              std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line"></div><div class="line">        array_size = 20;</div><div class="line">        element_buffer_size = char_array_list_entry::byte_size_to_array_size(array_size);</div><div class="line">        pattern = 3;</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern](char_array_list_entry &amp;e,</div><div class="line">                                                size_t element_size) noexcept {</div><div class="line">                              e.length = array_size;</div><div class="line">                              std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line"></div><div class="line">        array_size = 0;</div><div class="line">        element_buffer_size = char_array_list_entry::byte_size_to_array_size(array_size);</div><div class="line">        pattern = 4;</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern](char_array_list_entry &amp;e,</div><div class="line">                                                size_t element_size) noexcept {</div><div class="line">                              e.length = array_size;</div><div class="line">                              std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line"></div><div class="line">        array_size = 11;</div><div class="line">        element_buffer_size = char_array_list_entry::byte_size_to_array_size(array_size);</div><div class="line">        pattern = 5;</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern](char_array_list_entry &amp;e,</div><div class="line">                                                size_t element_size) noexcept {</div><div class="line">                              e.length = array_size;</div><div class="line">                              std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line">        //</div><div class="line">        // Make sure we are not leaking in the padding any information that can</div><div class="line">        // be helpful to attack server.</div><div class="line">        //</div><div class="line">        // Without that call padding between entries is field with garbage. In this </div><div class="line">        // case 0xfe.</div><div class="line">        //</div><div class="line">        // cdb/windbg&gt;db 0x00000256`ebd78fa0 L47</div><div class="line">        //</div><div class="line">        // 00000256`ebd78fa0  0a 00 00 00 01 01 01 01 - 01 01 01 01 01 01 fe fe  ................</div><div class="line">        // 00000256`ebd78fb0  05 00 00 00 02 02 02 02 - 02 fe fe fe 14 00 00 00  ................</div><div class="line">        // 00000256`ebd78fc0  03 03 03 03 03 03 03 03 - 03 03 03 03 03 03 03 03  ................</div><div class="line">        // 00000256`ebd78fd0  03 03 03 03 00 00 00 00 - 0b 00 00 00 05 05 05 05  ................</div><div class="line">        // 00000256`ebd78fe0  05 05 05 05 05 05 05    -                          .......</div><div class="line">        //</div><div class="line">        // After the call padding is filled with zeros</div><div class="line">        //</div><div class="line">        // cdb/windbg&gt;db 0x00000256`ebd78fa0 L47</div><div class="line">        //</div><div class="line">        // 00000254`fd668fa0  0a 00 00 00 01 01 01 01 - 01 01 01 01 01 01 00 00  ................</div><div class="line">        // 00000254`fd668fb0  05 00 00 00 02 02 02 02 - 02 00 00 00 14 00 00 00  ................</div><div class="line">        // 00000254`fd668fc0  03 03 03 03 03 03 03 03 - 03 03 03 03 03 03 03 03  ................</div><div class="line">        // 00000254`fd668fd0  03 03 03 03 00 00 00 00 - 0b 00 00 00 05 05 05 05  ................</div><div class="line">        // 00000254`fd668fe0  05 05 05 05 05 05 05    -                          .......</div><div class="line">        //</div><div class="line">        data.fill_padding();</div><div class="line"></div><div class="line">        iffl::buffer_ref detached_buffer{ data.detach() };</div><div class="line">        *buffer = detached_buffer.begin;</div><div class="line">        *buffer_size = detached_buffer.size();</div><div class="line"></div><div class="line">    } catch (...) {</div><div class="line">        return false;</div><div class="line">    }</div><div class="line">    return true;</div><div class="line">}</div></div><!-- fragment --><p> Client would take ownership of the buffer, validate received buffer, and process elements </p><div class="fragment"><div class="line">void call_server() {</div><div class="line">    char *buffer{ nullptr };</div><div class="line">    size_t buffer_size{ 0 };</div><div class="line"></div><div class="line">    if (server_api_call(&amp;buffer, &amp;buffer_size)) {</div><div class="line">        //</div><div class="line">        // If server call succeeded the </div><div class="line">        // take ownership of the buffer</div><div class="line">        //</div><div class="line">        char_array_list data{ iffl::attach_buffer{},</div><div class="line">                              buffer, </div><div class="line">                              buffer_size,</div><div class="line">                              &amp;global_memory_resource };</div><div class="line">        process_data(data);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Handle buffer that containes not propertly alligned elements.</h3>
<p>In some cases you need to handle flat forward list that contains elements that are not properly aligned. Ideally you always should prefer fixing code that produces broken list, but if it is not an option and you have to workaround the issue then you have to access your elements using pointers annotated as unaligned. On Visual studio you can use <a href="https://docs.microsoft.com/en-us/cpp/cpp/unaligned?view=vs-2017"><em>unaligned</em></a>. On GCC and CLANG you can use <a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.2/gcc/Type-Attributes.html"><em>attribute ((packed))</em></a>. If you ignore problem then on some platforms CPU might raise a fault and you program will crash when trying to load a value using unaligned pointer. When pointer is marked unaligned, compiler will generate code to load data in smaller pieces. This will cause performance hit, but it would avoid faults. Some platforms allow annotating executable such that OS will handle CPU faults for unaligned access and will patch it up. That would have even higher performance cost. While this might be the only option if you do not have access to the source code, you always should prefer fixing code.</p>
<p>Complete Sample is <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_unaligned.cpp">intest/iffl_unaligned.cpp</a>.</p>
<p>This sample also demonstates how to explicitely pass type traits to the container, instead of relying on a default, which picks traits using template class specialization.</p>
<div class="fragment"><div class="line">template &lt;typename T&gt;</div><div class="line">struct flat_forward_list_traits_unaligned {</div><div class="line">    using  header_type = pod_array_list_entry&lt;T&gt;;</div><div class="line">    //</div><div class="line">    // All memory access will be done using pointer annotated</div><div class="line">    // that data might be unaligned. On platforms where CPU raises </div><div class="line">    // signal when accessing unaligned data, compiler is expected to </div><div class="line">    // generate code that reads data in multiple round trips using</div><div class="line">    // smaller types that will be properly aligned. For instance</div><div class="line">    // it can load it as a series of bytes.</div><div class="line">    //</div><div class="line">    using header_type_ptr = FFL_UNALIGNED header_type *;</div><div class="line">    using header_type_const_ptr = FFL_UNALIGNED header_type const *;</div><div class="line"></div><div class="line">    constexpr static size_t const alignment{ 1 };</div><div class="line">    //</div><div class="line">    // This method is required for validate algorithm</div><div class="line">    //</div><div class="line">    constexpr static size_t minimum_size() noexcept {</div><div class="line">        return FFL_SIZE_THROUGH_FIELD(header_type, length);</div><div class="line">    }</div><div class="line">    //</div><div class="line">    // Required by container validate algorithm when type</div><div class="line">    // does not support get_next_offset</div><div class="line">    //</div><div class="line">    constexpr static size_t get_size(header_type const &amp;e) {</div><div class="line">        //</div><div class="line">        // Element might be pointing to unaligned data</div><div class="line">        // make sure we access it using pointer marked as </div><div class="line">        // unaligned</div><div class="line">        //</div><div class="line">        header_type_const_ptr unaligned_e{ &amp;e };</div><div class="line">        size_t const size = FFL_FIELD_OFFSET(header_type, arr) + unaligned_e-&gt;length * sizeof(T);</div><div class="line">        return size;</div><div class="line">    }</div><div class="line">    //</div><div class="line">    // This method is required for validate algorithm</div><div class="line">    //</div><div class="line">    constexpr static bool validate(size_t buffer_size, header_type const &amp;e) noexcept {</div><div class="line">        return  get_size(e) &lt;= buffer_size;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"> using unaligned_char_array_list_entry_ptr = FFL_UNALIGNED char_array_list_entry *;</div><div class="line"> using unaligned_char_array_list_entry_const_ptr = FFL_UNALIGNED char_array_list_entry const *;</div><div class="line"></div><div class="line">using unaligned_char_array_list_ref = iffl::flat_forward_list_ref&lt;char_array_list_entry, </div><div class="line">                                                                  flat_forward_list_traits_unaligned&lt;char_array_list_entry::type&gt;&gt;;</div><div class="line">using unaligned_char_array_list_view = iffl::flat_forward_list_view&lt;char_array_list_entry, </div><div class="line">                                                                    flat_forward_list_traits_unaligned&lt;char_array_list_entry::type&gt;&gt;;</div><div class="line">using unaligned_char_array_list = iffl::pmr_flat_forward_list&lt;char_array_list_entry, </div><div class="line">                                                              flat_forward_list_traits_unaligned&lt;char_array_list_entry::type&gt;&gt;;</div><div class="line"></div><div class="line"></div><div class="line">void process_unaligned_view(unaligned_char_array_list_view const &amp;data) {</div><div class="line">    unaligned_char_array_list_view::const_iterator end{ data.cend() };</div><div class="line">    for (auto cur{ data.cbegin() }; cur != end; ++cur) {</div><div class="line">        //</div><div class="line">        // Element might be pointing to unaligned data</div><div class="line">        // make sure we access it using pointer marked as </div><div class="line">        // unaligned</div><div class="line">        //</div><div class="line">        unaligned_char_array_list_entry_const_ptr unaligned_e_ptr{ &amp;*cur };</div><div class="line">        if (iffl::roundup_ptr_to_alignment&lt;char_array_list_entry&gt;(unaligned_e_ptr) != unaligned_e_ptr) {</div><div class="line">            std::printf(&quot;Found char_array_list_entry length %03hu at unaligned address %p\n&quot;,</div><div class="line">                        unaligned_e_ptr-&gt;length,</div><div class="line">                        reinterpret_cast&lt;void const*&gt;(unaligned_e_ptr));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Other Use Cases.</h3>
<p>You can use a list of flat forward list as a queue where producer creates batches of buffers organized in flat forward lists, and once buffer is full it would move it to the list for processing by a consumer. </p><div class="fragment"><div class="line">std::list&lt;char_array_list&gt;</div></div><!-- fragment --><p> You can subdivide a large flat forward list to sublists tracked using views, and pass processing of each view to a separate thread. Sample application for this use case is in <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_views.cpp">test/iffl_views.cpp</a>.</p>
<p>You use an entry of char_array_list as a frame that contains a serialized message. Container char_array_list can accumulate certain number of frames, and once you are ready, you can send entire batch over a socket.</p>
<p>On receiving side you can read data into a buffer, use <em>flat_forward_list_validate</em> to process as many fully received frames as we can find in the buffer. Remove processed data, by shifting tail to the head, and receive more data to the tails of the buffer. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

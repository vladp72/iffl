<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: Intrusive Flat Forward List for plain old definition (POD) types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Intrusive Flat Forward List for plain old definition (POD) types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This header only library that implements intrusive flat forward list (iffl).</p>
<p><a href="https://github.com/vladp72/iffl/tree/master/include">https://github.com/vladp72/iffl/tree/master/include</a></p>
<h2>Motivation</h2>
<p>Often times when dealing with OS or just C interface we need to pass in or parse a a buffer that contains a linked list of variable size structs.</p>
<p>These pods have following general structure: </p><div class="fragment"><div class="line">                     ------------------------------------------------------------</div><div class="line">                     |                                                          |</div><div class="line">                     |                                                          V</div><div class="line">| &lt;fields&gt; | offset to next element | &lt;offsets of data&gt; | [data] | [padding] || [next element] ...</div><div class="line">|                        header                         | [data] | [padding] || [next element] ...</div></div><!-- fragment --><p>Examples are from Windows, but I am sure there is plenty of samples in Unix: </p><div class="fragment"><div class="line">typedef struct _FILE_FULL_EA_INFORMATION {</div><div class="line">  ULONG  NextEntryOffset; // intrusive hook with offset of the next element</div><div class="line">  UCHAR  Flags;</div><div class="line">  UCHAR  EaNameLength;</div><div class="line">  USHORT EaValueLength;</div><div class="line">  CHAR   EaName[1];</div><div class="line">} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;</div></div><!-- fragment --><p> <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_file_full_ea_information">FILE_FULL_EA_INFORMATION documentation</a> </p><div class="fragment"><div class="line">typedef struct _FILE_NOTIFY_EXTENDED_INFORMATION {</div><div class="line">  DWORD         NextEntryOffset; // intrusive hook with offset of the next element</div><div class="line">  DWORD         Action;</div><div class="line">  LARGE_INTEGER CreationTime;</div><div class="line">  LARGE_INTEGER LastModificationTime;</div><div class="line">  LARGE_INTEGER LastChangeTime;</div><div class="line">  LARGE_INTEGER LastAccessTime;</div><div class="line">  LARGE_INTEGER AllocatedLength;</div><div class="line">  LARGE_INTEGER FileSize;</div><div class="line">  DWORD         FileAttributes;</div><div class="line">  DWORD         ReparsePointTag;</div><div class="line">  LARGE_INTEGER FileId;</div><div class="line">  LARGE_INTEGER ParentFileId;</div><div class="line">  DWORD         FileNameLength;</div><div class="line">  WCHAR         FileName[1];</div><div class="line">} FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;</div></div><!-- fragment --><p> <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-_file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION documentation</a></p>
<p>Output for the following information classes from <a href="https://msdn.microsoft.com/en-us/8f02e824-ca41-48c1-a5e8-5b12d81886b5">FILE_INFO_BY_HANDLE_CLASS</a> </p><div class="fragment"><div class="line">FileIdBothDirectoryInfo</div><div class="line">FileIdBothDirectoryRestartInfo</div><div class="line">FileIoPriorityHintInfo</div><div class="line">FileRemoteProtocolInfo</div><div class="line">FileFullDirectoryInfo</div><div class="line">FileFullDirectoryRestartInfo</div><div class="line">FileStorageInfo</div><div class="line">FileAlignmentInfo</div><div class="line">FileIdInfo</div><div class="line">FileIdExtdDirectoryInfo</div><div class="line">FileIdExtdDirectoryRestartInfo</div><div class="line">For example output buffer for</div></div><!-- fragment --><p> For example </p><div class="fragment"><div class="line">GetFileInformationByHandleEx(file_handle, FileIdBothDirectoryInfo, buffer, buffer_size);</div></div><!-- fragment --><p> will be filled with structures </p><div class="fragment"><div class="line">typedef struct _FILE_ID_BOTH_DIR_INFO {</div><div class="line">  DWORD         NextEntryOffset; // intrusive hook with offset of the next element</div><div class="line">  DWORD         FileIndex;</div><div class="line">  LARGE_INTEGER CreationTime;</div><div class="line">  LARGE_INTEGER LastAccessTime;</div><div class="line">  LARGE_INTEGER LastWriteTime;</div><div class="line">  LARGE_INTEGER ChangeTime;</div><div class="line">  LARGE_INTEGER EndOfFile;</div><div class="line">  LARGE_INTEGER AllocationSize;</div><div class="line">  DWORD         FileAttributes;</div><div class="line">  DWORD         FileNameLength;</div><div class="line">  DWORD         EaSize;</div><div class="line">  CCHAR         ShortNameLength;</div><div class="line">  WCHAR         ShortName[12];</div><div class="line">  LARGE_INTEGER FileId;</div><div class="line">  WCHAR         FileName[1];</div><div class="line">} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;</div></div><!-- fragment --><p> Output of NtQueryDirectoryFile <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/ns-ntifs-_file_both_dir_information">FILE_ID_BOTH_DIR_INFO documentation</a></p>
<p>Or types that do not have next element offset, but it can be calculated. Offset of the next element is size of this element data, plus optional padding to keep ext element properly aligned </p><div class="fragment"><div class="line">                     -----------------------------------</div><div class="line">                     |                                 |</div><div class="line">    (next element offset = sizeof(this element)        |</div><div class="line">                     |   + padding)                    |</div><div class="line">                     |                                 V</div><div class="line">| &lt;fields&gt; | &lt;offsets of data&gt; | [data] | [padding] || [next element] ...</div><div class="line">|       header                 | [data] | [padding] || [next element] ...</div></div><!-- fragment --><p>Exanmples:</p>
<p>CLUSPROP_SYNTAX</p><ul>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/property-lists">property list</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/data-structures">data structures</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/clusapi/ns-clusapi-clusprop_syntax">cluster property syntax</a></li>
</ul>
<div class="fragment"><div class="line">typedef union CLUSPROP_SYNTAX {</div><div class="line">  DWORD  dw;</div><div class="line">  struct {</div><div class="line">      WORD wFormat;</div><div class="line">      WORD wType;</div><div class="line">  } DUMMYSTRUCTNAME;</div><div class="line">} CLUSPROP_SYNTAX;</div></div><!-- fragment --><p> <a href="https://docs.microsoft.com/en-us/windows/desktop/api/clusapi/ns-clusapi-clusprop_value">CLUSPROP_VALUE</a> </p><div class="fragment"><div class="line">typedef struct CLUSPROP_VALUE {</div><div class="line">    CLUSPROP_SYNTAX Syntax;</div><div class="line">    DWORD           cbLength;</div><div class="line">} CLUSPROP_VALUE;</div></div><!-- fragment --><h2>Overview</h2>
<p>This header only library provides an algorithms and containers for safe creation and parsing such a collection. It includes:</p><ul>
<li><b>flat_forward_list_ref</b> and <b>flat_forward_list_view</b> a non-owning containers that allows iterating over a flat forward list in a buffer.</li>
<li><b>flat_forward_list_validate</b> a family of functions that help to validate untrusted buffer, and returns a ref/view to a subrange to the buffer that contains valid list.</li>
<li><b>flat_forward_list</b> a container that owns and resizes buffer as you are adding/removing elements.</li>
<li><b>debug_memory_resource</b> a memory resource that help with debugging</li>
<li><b>input_buffer_memory_resource</b> a memory resource that helps in scenarios where server have to fill a passed in buffer.</li>
</ul>
<h2>Boilerplate</h2>
<p>Types that are usually used with this container are POD types defined elsewhere. We cannot extent these types. We do need several methods to be able to traverse and modify elements in the container:</p>
<ul>
<li>Mandatory methods have to be implemented in all types and all scenarios<ul>
<li>Returns minimum required buffer size. For example minimum required buffer size for FILE_FULL_EA_INFORMATION is offset of field EaValueLength, plus size of EaValueLength. If buffer is smaller then we cannot even tell size used by the data of the element.<ul>
<li><code>static size_t minimum_size() noexcept;</code></li>
</ul>
</li>
<li>Returns element size calculated from size of data contained by the element. For example for FILE_FULL_EA_INFORMATION it would be size of minimum header plus value in EaNameLength and EaValueLength.<ul>
<li><code>static size_t get_size(&lt;type&gt; const &amp;e) noexcept;</code></li>
</ul>
</li>
</ul>
</li>
<li>Optional method that validates element contains correct data. For instance it can check that size of the fields fit in the element buffer. For example for FILE_FULL_EA_INFORMATION it can check that element size would not be larger than offset to the next element.<ul>
<li><code>static bool validate(size_t buffer_size, &lt;type&gt; const &amp;e) noexcept;</code></li>
</ul>
</li>
<li>Types that have offset to the next element must implement method that return that value. Container uses this method to traverse list, but if type does not have that field then you should not implement this method. Without this method container will use get_size as an offset to the next element.<ul>
<li><code>static size_t get_next_offset(&lt;type&gt; const &amp;e) noexcept;</code></li>
</ul>
</li>
<li>For scenario where we need to modify list, and the type supports next element offset field, you need to implement a method that allows setting updating this field. If type does not support next element offset then do not implement this method. If this method is not present then container assumes next offset field is not part of the type and will no-op updating it.<ul>
<li><code>static void set_next_element_offset(&lt;type&gt; &amp;buffer, size_t size) noexcept;</code></li>
</ul>
</li>
<li>Optionally you can add a static variable that tells alignment required for an element header. Container will add padding to the element to keep next element properly aligned. If this member is absent then container assumes that elements can be 1 byte aligned and would not add any padding. Reading unaligned data might cause an exception or sig-fault on some platforms, unless you explicitly annotate your pointers as unaligned.<ul>
<li><code>constexpr static size_t const alignment{ &lt;alignment&gt; }</code></li>
</ul>
</li>
</ul>
<p>User can pass a type that implements these method as an explicit template parameter or she can specialize <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">iffl::flat_forward_list_traits</a> for the type. By default all containers and algorithms will look for this specialization.</p>
<p>List of methods that can be implemented: </p><div class="fragment"><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;FLAT_FORWARD_LIST_TEST&gt; {</div><div class="line">        constexpr static size_t const alignment{ alignof(FLAT_FORWARD_LIST_TEST) };</div><div class="line">        constexpr static size_t minimum_size() noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static size_t get_next_offset(FLAT_FORWARD_LIST_TEST const &amp;e) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static void set_next_offset(FLAT_FORWARD_LIST_TEST &amp;e, size_t size) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static size_t get_size(FLAT_FORWARD_LIST_TEST const &amp;e) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static bool validate(size_t buffer_size, FLAT_FORWARD_LIST_TEST const &amp;e) noexcept {&lt;implementation&gt;}</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>By default you will not explicitly spell that for FILE_FULL_EA_INFORMATION we should use iffl::flat_forward_list_traits&lt;FILE_FULL_EA_INFORMATION&gt;. Compiler will do the right thing using partial template specialization magic.</p>
<div class="fragment"><div class="line">template &lt;typename T,</div><div class="line">          typename TT = flat_forward_list_traits&lt;T&gt;,</div><div class="line">          typename A = std::allocator&lt;T&gt;&gt;</div><div class="line">class flat_forward_list final;</div></div><!-- fragment --><p> You can simply declare container as <code><a class="el" href="classiffl_1_1flat__forward__list.html" title="Intrusive flat forward list container.">iffl::flat_forward_list</a> final&lt;FILE_FULL_EA_INFORMATION&gt;</code>. If you want to point container to a different set of traits then you can pass them in explicitly <code><a class="el" href="classiffl_1_1flat__forward__list.html" title="Intrusive flat forward list container.">iffl::flat_forward_list</a> final&lt;FILE_FULL_EA_INFORMATION, <a class="el" href="structiffl_1_1flat__forward__list__traits.html" title="traits for an elements that are in the flat forward list">iffl::flat_forward_list_traits</a>&lt;FLAT_FORWARD_LIST_TEST&gt;&gt;</code></p>
<p>Let's take a look at a complete implementation for FILE_FULL_EA_INFORMATION:</p>
<div class="fragment"><div class="line">typedef struct _FILE_FULL_EA_INFORMATION {</div><div class="line">    ULONG  NextEntryOffset;</div><div class="line">    UCHAR  Flags;</div><div class="line">    UCHAR  EaNameLength;</div><div class="line">    USHORT EaValueLength;</div><div class="line">    CHAR   EaName[1];</div><div class="line">} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;</div><div class="line"></div><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;FILE_FULL_EA_INFORMATION&gt; {</div><div class="line">    </div><div class="line">        constexpr static size_t const alignment{ alignof(FILE_FULL_EA_INFORMATION) };</div><div class="line">        </div><div class="line">        static size_t get_next_offset(FILE_FULL_EA_INFORMATION const &amp;e) noexcept {</div><div class="line">            return e.NextEntryOffset;</div><div class="line">        }</div><div class="line">        </div><div class="line">        static size_t minimum_size() noexcept {</div><div class="line">            return FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength);</div><div class="line">        }</div><div class="line">        </div><div class="line">        static size_t get_size(FILE_FULL_EA_INFORMATION const &amp;e) {</div><div class="line">            return  FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) +</div><div class="line">                    e.EaNameLength +</div><div class="line">                    e.EaValueLength;</div><div class="line">        }</div><div class="line">        </div><div class="line">        static bool validate_size(FILE_FULL_EA_INFORMATION const &amp;e, size_t buffer_size) noexcept {</div><div class="line">        if (e.NextEntryOffset == 0) {</div><div class="line">                return  get_size(e) &lt;= buffer_size;</div><div class="line">            } else if (e.NextEntryOffset &lt;= buffer_size) {</div><div class="line">                return  get_size(e) &lt;= e.NextEntryOffset;</div><div class="line">            }</div><div class="line">            return false;</div><div class="line">        }</div><div class="line"></div><div class="line">        static bool validate_data(FILE_FULL_EA_INFORMATION const &amp;e) noexcept {</div><div class="line">            return true;</div><div class="line">        }</div><div class="line">        </div><div class="line">        static bool validate(size_t buffer_size, FILE_FULL_EA_INFORMATION const &amp;e) noexcept {</div><div class="line">            return validate_size(e, buffer_size) &amp;&amp; validate_data(e);</div><div class="line">        }</div><div class="line">        </div><div class="line">        static void set_next_offset(FILE_FULL_EA_INFORMATION &amp;e, size_t size) noexcept {</div><div class="line">            FFL_CODDING_ERROR_IF_NOT(size == 0 || size &gt;= get_size(e));</div><div class="line">            e.NextEntryOffset = static_cast&lt;ULONG&gt;(size);</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>Now FILE_FULL_EA_INFORMATION is ready to be used with iffl containers.</p>
<div class="fragment"><div class="line">using ea_iffl_ref = iffl::flat_forward_list_ref&lt;FILE_FULL_EA_INFORMATION&gt;;</div><div class="line">using ea_iffl_view = iffl::flat_forward_list_view&lt;FILE_FULL_EA_INFORMATION&gt;;</div><div class="line">using ea_iffl = iffl::flat_forward_list&lt;FILE_FULL_EA_INFORMATION&gt;;</div><div class="line">using pmr_ea_iffl = iffl::pmr_flat_forward_list&lt;FILE_FULL_EA_INFORMATION&gt;;</div></div><!-- fragment --><p>Class pod_array_list_entry is an example of type that does not have offset to the next element. For that type we do not implement get_next_offset and set_next offset.</p>
<div class="fragment"><div class="line">template &lt;typename T&gt;</div><div class="line">struct pod_array_list_entry {</div><div class="line">    unsigned short length;</div><div class="line">    T arr[1];</div><div class="line">    </div><div class="line">    using type = T;</div><div class="line">};</div><div class="line"></div><div class="line">template &lt;typename T&gt;</div><div class="line">struct pod_array_list_entry_traits {</div><div class="line"></div><div class="line">    using header_type = pod_array_list_entry&lt;T&gt;;</div><div class="line"></div><div class="line">    constexpr static size_t const alignment{ alignof(header_type) };</div><div class="line"></div><div class="line">    constexpr static size_t minimum_size() noexcept {</div><div class="line">        return FFL_SIZE_THROUGH_FIELD(header_type, length);</div><div class="line">    }</div><div class="line"></div><div class="line">    constexpr static size_t get_size(header_type const &amp;e) {</div><div class="line">        return FFL_FIELD_OFFSET(header_type, arr) + e.length * sizeof(T);</div><div class="line">    }</div><div class="line"></div><div class="line">    constexpr static bool validate(size_t buffer_size, header_type const &amp;e) noexcept {</div><div class="line">        return  get_size(e) &lt;= buffer_size;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> You can use tis type to declare variable array of long long</p>
<div class="fragment"><div class="line">using long_long_array_list_entry = pod_array_list_entry&lt;long long&gt;;</div><div class="line"></div><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;long_long_array_list_entry&gt;</div><div class="line">        : public pod_array_list_entry_traits&lt;long_long_array_list_entry::type&gt; {</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line">using long_long_array_list = iffl::pmr_flat_forward_list&lt;long_long_array_list_entry&gt;;</div></div><!-- fragment --><p> Type long_long_array_list is a list of variable length arrays of long long.</p>
<p>Or a variable array of char</p>
<div class="fragment"><div class="line">using char_array_list_entry = pod_array_list_entry&lt;char&gt;;</div><div class="line"></div><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;char_array_list_entry&gt;</div><div class="line">        : public pod_array_list_entry_traits&lt;char_array_list_entry::type&gt; {</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line">using char_array_list = iffl::pmr_flat_forward_list&lt;char_array_list_entry&gt;;</div></div><!-- fragment --><p> Type char_array_list is a list of variable length arrays of char.</p>
<h2>Scenarios</h2>
<h3>Adding elements to flat forward list</h3>
<p>Since FILE_FULL_EA_INFORMATION is a Plain Old Definition (POD) it does not have constructor, container methods that deal with creation of new elements allow passing a functor that will be called once container allocates requested space for the element to initialize element data. In this sample you can see prepare_ea_and_call_handler is calling emplace_front and emplace_back and is passing in a lambda that initializes element. If you want to zero initialize element then call container.push_back(element_size). If you want to initialize an element using a buffer that contains element blueprint then call .push_back(element_size, bluprint_buffer). It will initialize element by copy blueprint buffer. Note that for last element container always resets next element offset after element construction is done so you do not need to worry about that.</p>
<div class="fragment"><div class="line">ea_iffl eas;</div><div class="line"></div><div class="line">char const ea_name0[] = &quot;TEST_EA_0&quot;;</div><div class="line"></div><div class="line">// Add EA to the front of the list</div><div class="line"></div><div class="line">eas.emplace_front(FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) + sizeof(ea_name0)-sizeof(char), </div><div class="line">                 [](FILE_FULL_EA_INFORMATION &amp;e, size_t new_element_size) noexcept {</div><div class="line">                    e.Flags = 0;</div><div class="line">                    e.EaNameLength = sizeof(ea_name0)-sizeof(char);</div><div class="line">                    e.EaValueLength = 0;</div><div class="line">                    iffl::copy_data(e.EaName, ea_name0, sizeof(ea_name0)-sizeof(char));</div><div class="line">                  });</div><div class="line"></div><div class="line">char const ea_name1[] = &quot;TEST_EA_1&quot;;</div><div class="line">char const ea_data1[] = {1,2,3};</div><div class="line"></div><div class="line">// Add EA to the end of the list</div><div class="line"></div><div class="line">eas.emplace_back(FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) + sizeof(ea_name1)-sizeof(char) + sizeof(ea_data1),</div><div class="line">                 [](FILE_FULL_EA_INFORMATION &amp;e, size_t new_element_size) noexcept {</div><div class="line">                    e.Flags = 1;</div><div class="line">                    e.EaNameLength = sizeof(ea_name1)-sizeof(char);</div><div class="line">                    e.EaValueLength = sizeof(ea_data1);</div><div class="line">                    iffl::copy_data(e.EaName, ea_name1, sizeof(ea_name1)-sizeof(char));</div><div class="line">                    iffl::copy_data(e.EaName + sizeof(ea_name1)-sizeof(char), ea_data1, sizeof(ea_data1));</div><div class="line">                  });</div><div class="line"></div><div class="line">char const ea_name2[] = &quot;TEST_EA_2&quot;;</div><div class="line">char const ea_data2[] = { 1,2,3,4,5,6,7,8,9,0xa,0xb,0xc,0xd,0xf };</div><div class="line"></div><div class="line">// Add EA to the front of the list</div><div class="line"></div><div class="line">eas.emplace_front(FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) + sizeof(ea_name2)-sizeof(char) + sizeof(ea_data2),</div><div class="line">                 [](FILE_FULL_EA_INFORMATION &amp;e, size_t new_element_size) noexcept {</div><div class="line">                    e.Flags = 2;</div><div class="line">                    e.EaNameLength = sizeof(ea_name2)-sizeof(char);</div><div class="line">                    e.EaValueLength = sizeof(ea_data2);</div><div class="line">                    iffl::copy_data(e.EaName, ea_name2, sizeof(ea_name2)-sizeof(char));</div><div class="line">                    iffl::copy_data(e.EaName + sizeof(ea_name2)-sizeof(char), ea_data2, sizeof(ea_data2));</div><div class="line">                  });</div></div><!-- fragment --><p> will produce following list of extended attributes </p><div class="fragment"><div class="line">FILE_FULL_EA_INFORMATION[0] @ = 0x0x607000000100, buffer offset 0</div><div class="line">FILE_FULL_EA_INFORMATION[0].NextEntryOffset = 32</div><div class="line">FILE_FULL_EA_INFORMATION[0].Flags = 2</div><div class="line">FILE_FULL_EA_INFORMATION[0].EaNameLength = 9 &quot;TEST_EA_2&quot;</div><div class="line">FILE_FULL_EA_INFORMATION[0].EaValueLength = 14 123456789abcdf</div><div class="line"></div><div class="line">FILE_FULL_EA_INFORMATION[1] @ = 0x0x607000000120, buffer offset 32</div><div class="line">FILE_FULL_EA_INFORMATION[1].NextEntryOffset = 20</div><div class="line">FILE_FULL_EA_INFORMATION[1].Flags = 0</div><div class="line">FILE_FULL_EA_INFORMATION[1].EaNameLength = 9 &quot;TEST_EA_0&quot;</div><div class="line">FILE_FULL_EA_INFORMATION[1].EaValueLength = 0</div><div class="line"></div><div class="line">FILE_FULL_EA_INFORMATION[2] @ = 0x0x607000000134, buffer offset 52</div><div class="line">FILE_FULL_EA_INFORMATION[2].NextEntryOffset = 0</div><div class="line">FILE_FULL_EA_INFORMATION[2].Flags = 1</div><div class="line">FILE_FULL_EA_INFORMATION[2].EaNameLength = 9 &quot;TEST_EA_1&quot;</div><div class="line">FILE_FULL_EA_INFORMATION[2].EaValueLength = 3 123</div></div><!-- fragment --><h3>Adding elements to flat forward list over input buffer not owned by the calee</h3>
<div class="fragment"><div class="line">unsigned short idx{ 0 };</div><div class="line"></div><div class="line">bool server_api_call(char *buffer, size_t *buffer_size) noexcept {</div><div class="line">    bool result{ false };</div><div class="line">    //</div><div class="line">    // If user did not pass a valid buffer then bail out</div><div class="line">    //</div><div class="line">    if (!buffer || !buffer_size) {</div><div class="line">        return result;</div><div class="line">    }</div><div class="line">    //</div><div class="line">    // when container allocates memory this memory resource </div><div class="line">    // returns pointer to the input buffer</div><div class="line">    //</div><div class="line">    iffl::input_buffer_memory_resource input_buffer{reinterpret_cast&lt;void *&gt;(buffer), *buffer_size};</div><div class="line">    //</div><div class="line">    // Create container that will use above memory resource</div><div class="line">    //</div><div class="line">    char_array_list data{ &amp;input_buffer };</div><div class="line">    //</div><div class="line">    // Resizing container to the input buffer size.</div><div class="line">    // Container will ask memory resource for allocation</div><div class="line">    // and resource will return pointer to the input buffer.</div><div class="line">    // Rest of algorithm will avoid making any calls that can</div><div class="line">    // trigger memory reallocation. If we trigger that then </div><div class="line">    // resource will throw std::bad_alloc because it does not have</div><div class="line">    // any more memory it can allocate.</div><div class="line">    //</div><div class="line">    data.resize_buffer(*buffer_size);</div><div class="line">    //</div><div class="line">    // idx is a global variable that remembers where server stopped last time.</div><div class="line">    // Keep adding elements for as long as buffer has capacity</div><div class="line">    //</div><div class="line">    for (;; ++idx) {</div><div class="line">        //</div><div class="line">        // Estimate size of the element we are inserting</div><div class="line">        //</div><div class="line">        size_t element_size{ char_array_list::traits::minimum_size() + idx * sizeof(char_array_list::value_type::type) };</div><div class="line">        //</div><div class="line">        // try_emplace_back will succeed if we can add element</div><div class="line">        // without triggering reallocation, otherwise it will return </div><div class="line">        // false.</div><div class="line">        //</div><div class="line">        if (!data.try_emplace_back(element_size,</div><div class="line">                                    [] (char_array_list_entry &amp;e, size_t element_size) noexcept {</div><div class="line">                                        e.length = idx;</div><div class="line">                                        std::fill(e.arr, e.arr + e.length, static_cast&lt;char&gt;(idx)+1);</div><div class="line">                                    })) {</div><div class="line">            //</div><div class="line">            // Before we return back to the caller make sure we are not leaking any</div><div class="line">            // values that would help caller to attack server.</div><div class="line">            //</div><div class="line">            data.fill_padding();</div><div class="line">            //</div><div class="line">            // Tell client up to what point buffer contains valid data</div><div class="line">            //</div><div class="line">            *buffer_size = data.used_capacity();</div><div class="line">            break;</div><div class="line">        }</div><div class="line">        //</div><div class="line">        // If we inserted at least one element then return true</div><div class="line">        //</div><div class="line">        result = true;</div><div class="line">    }</div><div class="line">    return result;</div><div class="line">}</div></div><!-- fragment --><h3>Validate input buffer</h3>
<p>If you are receiving a untrusted buffer that is expected to contain a flat forward list you can validate it using <b>flat_forward_list_validate</b> family of function.</p>
<div class="fragment"><div class="line">template&lt;typename T,</div><div class="line">         typename TT = flat_forward_list_traits&lt;T&gt;,</div><div class="line">         typename F = default_validate_element_fn&lt;T, TT&gt;&gt;</div><div class="line">constexpr inline std::pair&lt;bool, flat_forward_list_ref&lt;T, TT&gt;&gt; </div><div class="line">  flat_forward_list_validate(char const *first,</div><div class="line">                             char const *end, </div><div class="line">                             F const &amp;validate_element_fn = default_validate_element_fn&lt;T, TT&gt;{}) noexcept;</div><div class="line"></div><div class="line">template&lt;typename T,</div><div class="line">         typename TT = flat_forward_list_traits&lt;T&gt;,</div><div class="line">         typename F = default_validate_element_fn&lt;T, TT&gt;&gt;</div><div class="line">constexpr inline std::pair&lt;bool, flat_forward_list_ref&lt;T, TT&gt;&gt; </div><div class="line">  flat_forward_list_validate(char *first,</div><div class="line">                             char *end,</div><div class="line">                             F const &amp;validate_element_fn = default_validate_element_fn&lt;T, TT&gt;{}) noexcept;</div></div><!-- fragment --><p>Function returns a pair of boolean and a reference or view. If passed parameter is a non-const buffer then result is a reference. If input buffer is const then result is a view (const reference). Boolean indicates if buffer contains a valid list. Even if list is broken, and function returns false, view will point to the subset of the buffer that contains a valid list. For instance if a pointer to the next element refers outside of the buffer range, then validate would abort, and return false, but returned reference/view will describe element from the beginning to the last valid element.</p>
<p>You can choose to be strict and reject invalid buffer.</p>
<div class="fragment"><div class="line">auto [is_valid, view] = iffl::flat_forward_list_validate&lt;FILE_FULL_EA_INFORMATION&gt;(std::begin(buffer), std::end(buffer));</div><div class="line">if (is_valid) {</div><div class="line">  std::for_each(view.begin(), view.begin(), </div><div class="line">                [](FLAT_FORWARD_LIST_TEST &amp;e) noexcept {</div><div class="line">                    print_element(e);</div><div class="line">                });</div><div class="line">    return true;</div><div class="line">} else {</div><div class="line">    return false;</div><div class="line">}</div></div><!-- fragment --><p> Or to handle as much of the buffer as you can. </p><div class="fragment"><div class="line">auto [is_valid, view] = iffl::flat_forward_list_validate&lt;FILE_FULL_EA_INFORMATION&gt;(std::begin(buffer), std::end(buffer));</div><div class="line">std::for_each(view.begin(), view.begin(), </div><div class="line">              [](FLAT_FORWARD_LIST_TEST &amp;e) noexcept {</div><div class="line">                  print_element(e);</div><div class="line">              });</div><div class="line">return is_valid;</div></div><!-- fragment --><p> In the samples above we traverse buffer two times. It is possible to traverse and handle elements in a single loop by passing your own functor in place of the default functor that calls trait's validate method.</p>
<div class="fragment"><div class="line">FILE_FULL_EA_INFORMATION const *failed_validation{nullptr};</div><div class="line">size_t invalid_element_length{0};</div><div class="line"></div><div class="line">auto[is_valid, buffer_view] =</div><div class="line">    iffl::flat_forward_list_validate&lt;FILE_FULL_EA_INFORMATION&gt;(</div><div class="line">        buffer,</div><div class="line">        buffer + buffer_lenght,</div><div class="line">        [&amp;failed_validation, &amp;invalid_element_length] (size_t buffer_size,</div><div class="line">                                                       FILE_FULL_EA_INFORMATION const &amp;e) -&gt; bool {</div><div class="line">            //</div><div class="line">            // validate element</div><div class="line">            //</div><div class="line">            bool const is_valid{ iffl::flat_forward_list_traits&lt;FILE_FULL_EA_INFORMATION&gt;::validate(buffer_size, e) };</div><div class="line">            //</div><div class="line">            // if element is valid then process element</div><div class="line">            //</div><div class="line">            if (is_valid) {</div><div class="line">                handle_validated_element(e);</div><div class="line">            } else {</div><div class="line">                //</div><div class="line">                // Save additional information about element that failed validation</div><div class="line">                //</div><div class="line">                invalid_element_length = buffer_size;</div><div class="line">                failed_validation = &amp;e;</div><div class="line">            }</div><div class="line">            //</div><div class="line">            // validation loop is aborted if element is not valid</div><div class="line">            //</div><div class="line">            return is_valid;</div><div class="line">        });</div></div><!-- fragment --><p> You can use flat_forward_list_validate as if it is a find-first algorithm and abort validation as soon as you've found an element you are looking for.</p>
<h3>Passing buffer ownership across C interface avoiding extra copy.</h3>
<p>If server and client can agree on how to allocate an deallocate buffer then you can create buffer using flat_forward_list, detach ownership of buffer from container, pass pointers to the buffer over a C interface, callee can take ownership of the buffer, and deallocate once processing is done.</p>
<p>In this example we will use a global variable providing a common memory resource for client and server </p><div class="fragment"><div class="line">iffl::debug_memory_resource global_memory_resource;</div></div><!-- fragment --><p> Server creates list, and returns pointers to the buffer containing list </p><div class="fragment"><div class="line">bool server_api_call(char **buffer, size_t *buffer_size) noexcept {</div><div class="line">    if (!buffer || !buffer_size) {</div><div class="line">        return false;</div><div class="line">    }</div><div class="line"></div><div class="line">    try {</div><div class="line">    </div><div class="line">        char_array_list data{ &amp;global_memory_resource };</div><div class="line">    </div><div class="line">        unsigned short array_size{ 10 };</div><div class="line">        size_t element_buffer_size{ char_array_list_entry::byte_size_to_array_size(array_size) };</div><div class="line">        char pattern{ 1 };</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern] (char_array_list_entry &amp;e,</div><div class="line">                                                 size_t element_size) noexcept {</div><div class="line">                               e.length = array_size;</div><div class="line">                               std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line"></div><div class="line">        array_size = 5;</div><div class="line">        element_buffer_size = char_array_list_entry::byte_size_to_array_size(array_size);</div><div class="line">        pattern = 2;</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern](char_array_list_entry &amp;e,</div><div class="line">                                                size_t element_size) noexcept {</div><div class="line">                              e.length = array_size;</div><div class="line">                              std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line"></div><div class="line">        array_size = 20;</div><div class="line">        element_buffer_size = char_array_list_entry::byte_size_to_array_size(array_size);</div><div class="line">        pattern = 3;</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern](char_array_list_entry &amp;e,</div><div class="line">                                                size_t element_size) noexcept {</div><div class="line">                              e.length = array_size;</div><div class="line">                              std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line"></div><div class="line">        array_size = 0;</div><div class="line">        element_buffer_size = char_array_list_entry::byte_size_to_array_size(array_size);</div><div class="line">        pattern = 4;</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern](char_array_list_entry &amp;e,</div><div class="line">                                                size_t element_size) noexcept {</div><div class="line">                              e.length = array_size;</div><div class="line">                              std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line"></div><div class="line">        array_size = 11;</div><div class="line">        element_buffer_size = char_array_list_entry::byte_size_to_array_size(array_size);</div><div class="line">        pattern = 5;</div><div class="line"></div><div class="line">        data.emplace_back(element_buffer_size,</div><div class="line">                          [array_size, pattern](char_array_list_entry &amp;e,</div><div class="line">                                                size_t element_size) noexcept {</div><div class="line">                              e.length = array_size;</div><div class="line">                              std::fill(e.arr, e.arr + e.length, pattern);</div><div class="line">                          });</div><div class="line">        //</div><div class="line">        // Make sure we are not leaking in the padding any information that can</div><div class="line">        // be helpful to attack server.</div><div class="line">        //</div><div class="line">        // Without that call padding between entries is field with garbage. In this </div><div class="line">        // case 0xfe.</div><div class="line">        //</div><div class="line">        // cdb/windbg&gt;db 0x00000256`ebd78fa0 L47</div><div class="line">        //</div><div class="line">        // 00000256`ebd78fa0  0a 00 00 00 01 01 01 01 - 01 01 01 01 01 01 fe fe  ................</div><div class="line">        // 00000256`ebd78fb0  05 00 00 00 02 02 02 02 - 02 fe fe fe 14 00 00 00  ................</div><div class="line">        // 00000256`ebd78fc0  03 03 03 03 03 03 03 03 - 03 03 03 03 03 03 03 03  ................</div><div class="line">        // 00000256`ebd78fd0  03 03 03 03 00 00 00 00 - 0b 00 00 00 05 05 05 05  ................</div><div class="line">        // 00000256`ebd78fe0  05 05 05 05 05 05 05    -                          .......</div><div class="line">        //</div><div class="line">        // After the call padding is filled with zeros</div><div class="line">        //</div><div class="line">        // cdb/windbg&gt;db 0x00000256`ebd78fa0 L47</div><div class="line">        //</div><div class="line">        // 00000254`fd668fa0  0a 00 00 00 01 01 01 01 - 01 01 01 01 01 01 00 00  ................</div><div class="line">        // 00000254`fd668fb0  05 00 00 00 02 02 02 02 - 02 00 00 00 14 00 00 00  ................</div><div class="line">        // 00000254`fd668fc0  03 03 03 03 03 03 03 03 - 03 03 03 03 03 03 03 03  ................</div><div class="line">        // 00000254`fd668fd0  03 03 03 03 00 00 00 00 - 0b 00 00 00 05 05 05 05  ................</div><div class="line">        // 00000254`fd668fe0  05 05 05 05 05 05 05    -                          .......</div><div class="line">        //</div><div class="line">        data.fill_padding();</div><div class="line"></div><div class="line">        iffl::buffer_ref detached_buffer{ data.detach() };</div><div class="line">        *buffer = detached_buffer.begin;</div><div class="line">        *buffer_size = detached_buffer.size();</div><div class="line"></div><div class="line">    } catch (...) {</div><div class="line">        return false;</div><div class="line">    }</div><div class="line">    return true;</div><div class="line">}</div></div><!-- fragment --><p> Client would take ownership of the buffer, validate received buffer, and process elements </p><div class="fragment"><div class="line">void call_server1() {</div><div class="line">    char *buffer{ nullptr };</div><div class="line">    size_t buffer_size{ 0 };</div><div class="line"></div><div class="line">    if (server_api_call(&amp;buffer, &amp;buffer_size)) {</div><div class="line">        //</div><div class="line">        // If server call succeeded the </div><div class="line">        // take ownership of the buffer</div><div class="line">        //</div><div class="line">        char_array_list data{ iffl::attach_buffer{},</div><div class="line">                              buffer, </div><div class="line">                              buffer_size,</div><div class="line">                              &amp;global_memory_resource };</div><div class="line">        process_data(data);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h3>Other ideas.</h3>
<p>You can use a list of flat forward list as a queue where producer creates batches of buffers organized in flat forward lists, and once buffer is full it would move it to the list for processing by a consumer. </p><div class="fragment"><div class="line">std::list&lt;char_array_list&gt;</div></div><!-- fragment --><p> You can subdivide a large flat forward list to sublists tracked using views, and pass processing of each view to a separate thread.</p>
<p>You use an entry of char_array_list as a frame that contains a serialized message. Container char_array_list can accumulate certain number of frames, and once you are ready, you can send entire batch over a socket.</p>
<p>On receiving side you can read data into a buffer, use <em>flat_forward_list_validate</em> to process as many fully received frames as we can find in the buffer. Remove processed data, by shifting tail to the head, and receive more data to the tails of the buffer. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iffl: Intrusive Flat Forward List for plain old definition (POD) types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iffl
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Implements Intrusive Flat Forward List container</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Intrusive Flat Forward List for plain old definition (POD) types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This header only library that implements intrusive flat forward list (iffl).</p>
<p><a href="https://github.com/vladp72/iffl/tree/master/include">https://github.com/vladp72/iffl/tree/master/include</a></p>
<p>Often times when dealing with OS or just C interface we need to pass in or parse a linked list of variable size structs organized into a linked list in a buffer. This header only library provides an algorithm for safe parsing such a collection, iterators for going over trusted collection, and a container for manipulating this list (push/pop/erase/insert/sort/merge/etc). To facilitate usage across C interface container also supports attach (a.k.a adopt ) buffer and detach buffer (you would need a custom allocator both sides would agree on).</p>
<p>This container is designed to contain element of following general structure: that can be used to enumerate over previously validated buffer </p><div class="fragment"><div class="line">                     ------------------------------------------------------------</div><div class="line">                     |                                                          |</div><div class="line">                     |                                                          V</div><div class="line">| &lt;fields&gt; | offset to next element | &lt;offsets of data&gt; | [data] | [padding] || [next element] ...</div><div class="line">|                        header                         | [data] | [padding] || [next element] ...</div></div><!-- fragment --><p>Examples are from Windows, but I am sure there is plenty of samples in Unix: </p><div class="fragment"><div class="line">typedef struct _FILE_FULL_EA_INFORMATION {</div><div class="line">  ULONG  NextEntryOffset; // intrusive hook with offset of the next element</div><div class="line">  UCHAR  Flags;</div><div class="line">  UCHAR  EaNameLength;</div><div class="line">  USHORT EaValueLength;</div><div class="line">  CHAR   EaName[1];</div><div class="line">} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;</div></div><!-- fragment --><p> <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_file_full_ea_information">FILE_FULL_EA_INFORMATION documentation</a> </p><div class="fragment"><div class="line">typedef struct _FILE_NOTIFY_EXTENDED_INFORMATION {</div><div class="line">  DWORD         NextEntryOffset; // intrusive hook with offset of the next element</div><div class="line">  DWORD         Action;</div><div class="line">  LARGE_INTEGER CreationTime;</div><div class="line">  LARGE_INTEGER LastModificationTime;</div><div class="line">  LARGE_INTEGER LastChangeTime;</div><div class="line">  LARGE_INTEGER LastAccessTime;</div><div class="line">  LARGE_INTEGER AllocatedLength;</div><div class="line">  LARGE_INTEGER FileSize;</div><div class="line">  DWORD         FileAttributes;</div><div class="line">  DWORD         ReparsePointTag;</div><div class="line">  LARGE_INTEGER FileId;</div><div class="line">  LARGE_INTEGER ParentFileId;</div><div class="line">  DWORD         FileNameLength;</div><div class="line">  WCHAR         FileName[1];</div><div class="line">} FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;</div><div class="line">[FILE_NOTIFY_EXTENDED_INFORMATION documentation](https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-_file_notify_extended_information)</div></div><!-- fragment --><p> output for the following information classes from <a href="https://msdn.microsoft.com/en-us/8f02e824-ca41-48c1-a5e8-5b12d81886b5">FILE_INFO_BY_HANDLE_CLASS</a> </p><div class="fragment"><div class="line">FileIdBothDirectoryInfo</div><div class="line">FileIdBothDirectoryRestartInfo</div><div class="line">FileIoPriorityHintInfo</div><div class="line">FileRemoteProtocolInfo</div><div class="line">FileFullDirectoryInfo</div><div class="line">FileFullDirectoryRestartInfo</div><div class="line">FileStorageInfo</div><div class="line">FileAlignmentInfo</div><div class="line">FileIdInfo</div><div class="line">FileIdExtdDirectoryInfo</div><div class="line">FileIdExtdDirectoryRestartInfo</div><div class="line">For example output buffer for</div></div><!-- fragment --><p> For eample </p><div class="fragment"><div class="line">GetFileInformationByHandleEx(file_handle, FileIdBothDirectoryInfo, buffer, buffer_size);</div></div><!-- fragment --><p> will be filled with structures </p><div class="fragment"><div class="line">typedef struct _FILE_ID_BOTH_DIR_INFO {</div><div class="line">  DWORD         NextEntryOffset; // intrusive hook with offset of the next element</div><div class="line">  DWORD         FileIndex;</div><div class="line">  LARGE_INTEGER CreationTime;</div><div class="line">  LARGE_INTEGER LastAccessTime;</div><div class="line">  LARGE_INTEGER LastWriteTime;</div><div class="line">  LARGE_INTEGER ChangeTime;</div><div class="line">  LARGE_INTEGER EndOfFile;</div><div class="line">  LARGE_INTEGER AllocationSize;</div><div class="line">  DWORD         FileAttributes;</div><div class="line">  DWORD         FileNameLength;</div><div class="line">  DWORD         EaSize;</div><div class="line">  CCHAR         ShortNameLength;</div><div class="line">  WCHAR         ShortName[12];</div><div class="line">  LARGE_INTEGER FileId;</div><div class="line">  WCHAR         FileName[1];</div><div class="line">} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;</div></div><!-- fragment --><p> Output of NtQueryDirectoryFile <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/ns-ntifs-_file_both_dir_information">FILE_ID_BOTH_DIR_INFO documentation</a></p>
<p>function <b>flat_forward_list_validate</b> that can be use to deal with untrusted buffers. You can use it to validate if untrusted buffer contains a valid list, and to find boundary at which list gets invalid. with polymorphic allocator for debugging contained elements.</p>
<div class="fragment"><div class="line">template&lt;typename T,</div><div class="line">         typename TT = flat_forward_list_traits&lt;T&gt;&gt;</div><div class="line">struct default_validate_element_fn {</div><div class="line">    bool operator() (size_t buffer_size, char const *buffer) const noexcept {</div><div class="line">        return TT::validate(buffer_size, buffer);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">template&lt;typename T,</div><div class="line">         typename TT = flat_forward_list_traits&lt;T&gt;,</div><div class="line">         typename F = default_validate_element_fn&lt;T, TT&gt;&gt;</div><div class="line">constexpr inline std::pair&lt;bool, char const *&gt; flat_forward_list_validate(</div><div class="line">        char const *first,</div><div class="line">        char const *end, </div><div class="line">        F const &amp;validate_element_fn = default_validate_element_fn&lt;T, TT&gt;{}</div><div class="line">    ) noexcept;</div></div><!-- fragment --><p><b>flat_forward_list_iterator</b> and flat_forward_list_const_iterator are forward iterators that can be used to enmirate over previously validated buffer.</p>
<div class="fragment"><div class="line">template&lt;typename T,</div><div class="line">         typename TT = flat_forward_list_traits&lt;T&gt;&gt;</div><div class="line">using flat_forward_list_iterator = flat_forward_list_iterator_t&lt;T, TT&gt;;</div><div class="line"></div><div class="line">template&lt;typename T,</div><div class="line">         typename TT = flat_forward_list_traits&lt;T&gt;&gt;</div><div class="line">using flat_forward_list_const_iterator = flat_forward_list_iterator_t&lt; std::add_const_t&lt;T&gt;, TT&gt;;</div></div><!-- fragment --><p><b>flat_forward_list</b> a container that provides a set of helper algorithms and manages y while list changes. Container tracks data in buffer using 3 pointers</p><ul>
<li><b>buffer_begin</b> is a pointer to the buffer that containes flat forward list</li>
<li><b>last_element</b> is a pointer to the start of the last element in the buffer</li>
<li><b>buffer_end</b> is a pointer pass the end of the buffer Just like with vector, user can resize buffer to a size larger than required by the current elements. This helps avoid buffer reallocations as you insert new elements or resize existing elements. Erasing elements does not shrink buffer. To shrink buffer user have to explicitely call shrink_to_fit.</li>
</ul>
<div class="fragment"><div class="line"> template &lt;typename T,</div><div class="line">          typename TT = flat_forward_list_traits&lt;T&gt;,</div><div class="line">          typename A = std::allocator&lt;char&gt;&gt;</div><div class="line">class flat_forward_list;</div></div><!-- fragment --><p><b>pmr_flat_forward_list</b> is a an aliase of flat_forward_list where allocatoe is polimorfic_allocator.</p>
<div class="fragment"><div class="line">template &lt;typename T,</div><div class="line">          typename TT = flat_forward_list_traits&lt;T&gt;&gt;</div><div class="line"> using pmr_flat_forward_list = flat_forward_list&lt;T, </div><div class="line">                                                 TT, </div><div class="line">                                                 std::pmr::polymorphic_allocator&lt;char&gt;&gt;;</div></div><!-- fragment --><p><b>debug_memory_resource</b> a memory resource that can be used along with polimorfic allocator for debugging contained. </p><div class="fragment"><div class="line">class debug_memory_resource;</div></div><!-- fragment --><p>User is responsible for implementing helper class that has following methods</p><ul>
<li>tell us minimum required size element must have to be able to query element size constexpr static size_t minimum_size() noexcept; and addition documentation in this mode right above where primary constexpr static size_t get_next_element_offset(char const *buffer) noexcept;</li>
<li>update offset to the next element constexpr static void set_next_element_offset(char *buffer, size_t size) noexcept;</li>
<li>calculate element size from data constexpr static size_t calculate_next_element_offset(char const *buffer) noexcept;</li>
<li>validate that data fit into the buffer constexpr static bool validate(size_t buffer_size, char const *buffer) noexcept;</li>
</ul>
<p>By default we are looking for a partial specialization for the element type.</p>
<p>User have to implement following interface: </p><div class="fragment"><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;FLAT_FORWARD_LIST_TEST&gt; {</div><div class="line">        constexpr static size_t minimum_size() noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static size_t get_next_element_offset(char const *buffer) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static void set_next_element_offset(char *buffer, size_t size) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static size_t calculate_next_element_offset(char const *buffer) noexcept { &lt;implementation&gt; }</div><div class="line">        constexpr static bool validate(size_t buffer_size, char const *buffer) noexcept {&lt;implementation&gt;}</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>Sample implementation for FILE_FULL_EA_INFORMATION:</p>
<div class="fragment"><div class="line">typedef struct _FILE_FULL_EA_INFORMATION {</div><div class="line">    ULONG  NextEntryOffset;</div><div class="line">    UCHAR  Flags;</div><div class="line">    UCHAR  EaNameLength;</div><div class="line">    USHORT EaValueLength;</div><div class="line">    CHAR   EaName[1];</div><div class="line">} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;</div><div class="line"></div><div class="line">namespace iffl {</div><div class="line">    template &lt;&gt;</div><div class="line">    struct flat_forward_list_traits&lt;FILE_FULL_EA_INFORMATION&gt; {</div><div class="line">        //</div><div class="line">        // This is the only method required by flat_forward_list_iterator.</div><div class="line">        //</div><div class="line">        constexpr static size_t get_next_element_offset(char const *buffer) noexcept {</div><div class="line">            FILE_FULL_EA_INFORMATION const &amp;e = *reinterpret_cast&lt;FILE_FULL_EA_INFORMATION const *&gt;(buffer);</div><div class="line">            return e.NextEntryOffset;</div><div class="line">        }</div><div class="line">        //</div><div class="line">        // This method is requiered for validate algorithm</div><div class="line">        //</div><div class="line">        constexpr static size_t minimum_size() noexcept {</div><div class="line">            return FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength);</div><div class="line">        }</div><div class="line">        //</div><div class="line">        // Helper method that calculates buffer size. Not required.</div><div class="line">        //</div><div class="line">        constexpr static size_t get_size(FILE_FULL_EA_INFORMATION const &amp;e) {</div><div class="line">            return  FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) +</div><div class="line">                    e.EaNameLength +</div><div class="line">                    e.EaValueLength;</div><div class="line">        }</div><div class="line">        constexpr static size_t get_size(char const *buffer) {</div><div class="line">            return get_size(*reinterpret_cast&lt;FILE_FULL_EA_INFORMATION const *&gt;(buffer));</div><div class="line">        }</div><div class="line">        //</div><div class="line">        // Helper method that check that element sizes are correct. Not required.</div><div class="line">        //</div><div class="line">        constexpr static bool validate_size(FILE_FULL_EA_INFORMATION const &amp;e, size_t buffer_size) noexcept {</div><div class="line">            if (e.NextEntryOffset == 0) {</div><div class="line">                return  get_size(e) &lt;= buffer_size;</div><div class="line">            } else if (e.NextEntryOffset &lt;= buffer_size) {</div><div class="line">                return  get_size(e) &lt;= e.NextEntryOffset;</div><div class="line">            }</div><div class="line">            return false;</div><div class="line">        }</div><div class="line">        //</div><div class="line">        // Helper method that checks that data are valid</div><div class="line">        //</div><div class="line">        static bool validate_data(FILE_FULL_EA_INFORMATION const &amp;e) noexcept {</div><div class="line">            //</div><div class="line">            // This is and example of a validation you might want to do.</div><div class="line">            // Extended attribute name does not have to be 0 terminated </div><div class="line">            // so it is not strictly speaking nessesary here.</div><div class="line">            //</div><div class="line">            // char const *end = e.EaName + e.EaNameLength;</div><div class="line">            // return end != std::find_if(e.EaName,</div><div class="line">            //                            end, </div><div class="line">            //                            [](char c) -&gt; bool {</div><div class="line">            //                                 return c == &#39;\0&#39;; </div><div class="line">            //                            });</div><div class="line">            return true;</div><div class="line">        }</div><div class="line">        //</div><div class="line">        // This method is required for validate algorithm and container</div><div class="line">        //</div><div class="line">        constexpr static bool validate(size_t buffer_size, char const *buffer) noexcept {</div><div class="line">            FILE_FULL_EA_INFORMATION const &amp;e = *reinterpret_cast&lt;FILE_FULL_EA_INFORMATION const *&gt;(buffer);</div><div class="line">            return validate_size(e, buffer_size) &amp;&amp; validate_data(e);</div><div class="line">        }</div><div class="line">        //</div><div class="line">        // This method is required by container only</div><div class="line">        //</div><div class="line">        constexpr static void set_next_element_offset(char *buffer, size_t size) noexcept {</div><div class="line">            FILE_FULL_EA_INFORMATION &amp;e = *reinterpret_cast&lt;FILE_FULL_EA_INFORMATION *&gt;(buffer);</div><div class="line">            FFL_CODDING_ERROR_IF_NOT(size == 0 || size &gt;= get_size(e));</div><div class="line">            e.NextEntryOffset = static_cast&lt;ULONG&gt;(size);</div><div class="line">        }</div><div class="line">        //</div><div class="line">        // This method is required by container only</div><div class="line">        //</div><div class="line">        constexpr static size_t calculate_next_element_offset(char const *buffer) noexcept {</div><div class="line">            return get_size(buffer);</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>Now FILE_FULL_EA_INFORMATION is ready to be used with iffl. By default you will not explicitely spell that for FILE_FULL_EA_INFORMATION we should use iffl::flat_forward_list_traits&lt;FILE_FULL_EA_INFORMATION&gt;. Compiler will do the right thing using partial template specialization magic. Here is an example where prepare_ea_and_call_handler uses container to prepare buffer with FILE_FULL_EA_INFORMATION, and calls handle_ea. Function handle_ea uses flat_forward_list_validate to safely process elements of untrusted buffer.</p>
<p>Since FILE_FULL_EA_INFORMATION is a Plain Old Definition (POD) it does not have constructor, container methods that deal with creation of new elements allow passing a functor that will be called once container allocates requested space for the element to initialize element data. In this sample you can see prepare_ea_and_call_handler is calling emplace_front and emplace_back and is passing in a lambda that initializes element. If you want to zero intialize element then call container.push_back(element_size). If you want to initialzie element using a buffer that contains element blueprint then call .push_back(element_size, bluprint_buffer). It will initialize element by copy bluprint buffer. Note that for last element container always resets next element offset after element contruction is done so you do not need to worry about that.</p>
<div class="fragment"><div class="line">using ea_iffl = iffl::flat_forward_list&lt;FILE_FULL_EA_INFORMATION&gt;;</div><div class="line"></div><div class="line">void handle_ea(char const *buffer, size_t buffer_lenght) {</div><div class="line">    size_t idx{ 0 };</div><div class="line">    char const *failed_validation{ nullptr };</div><div class="line">    size_t invalid_element_length{ 0 };</div><div class="line">    //</div><div class="line">    // Use flat_forward_list_validate algorithm to safely process elements of untrusted input buffer</div><div class="line">    //</div><div class="line">    auto[is_valid, last_valid] =</div><div class="line">        iffl::flat_forward_list_validate&lt;FILE_FULL_EA_INFORMATION&gt;(</div><div class="line">            buffer,</div><div class="line">            buffer + buffer_lenght,</div><div class="line">            [buffer, &amp;idx, &amp;failed_validation, &amp;invalid_element_length] (size_t buffer_size,</div><div class="line">                                                                         char const *element_buffer) -&gt; bool {</div><div class="line">                bool is_valid = iffl::flat_forward_list_traits&lt;FILE_FULL_EA_INFORMATION&gt;::validate(buffer_size, element_buffer);</div><div class="line">                if (is_valid) {</div><div class="line">                    //</div><div class="line">                    // Add here code that handles element</div><div class="line">                    //</div><div class="line">                    FILE_FULL_EA_INFORMATION const &amp;e = </div><div class="line">                        *reinterpret_cast&lt;FILE_FULL_EA_INFORMATION const *&gt;(element_buffer);</div><div class="line">                    printf(&quot;FILE_FULL_EA_INFORMATION[%zi] @ = 0x%p, buffer offset %zi\n&quot;,</div><div class="line">                           idx,</div><div class="line">                           &amp;e,</div><div class="line">                           element_buffer - buffer);</div><div class="line">                } else {</div><div class="line">                    invalid_element_length = buffer_size;</div><div class="line">                    failed_validation = buffer;</div><div class="line">                }</div><div class="line">                return is_valid;</div><div class="line">            });</div><div class="line">}</div><div class="line"></div><div class="line">void prepare_ea_and_call_handler() {</div><div class="line">    //</div><div class="line">    // Use container to fill buffer</div><div class="line">    //</div><div class="line">    ea_iffl eas;</div><div class="line"></div><div class="line">    char const ea_name0[] = &quot;TEST_EA_0&quot;;</div><div class="line"></div><div class="line">    eas.emplace_front(FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) </div><div class="line">                     + sizeof(ea_name0)-1, </div><div class="line">                     [](char *buffer,</div><div class="line">                        size_t new_element_size) {</div><div class="line">                        FILE_FULL_EA_INFORMATION &amp;e = *reinterpret_cast&lt;FILE_FULL_EA_INFORMATION *&gt;(buffer);</div><div class="line">                        e.Flags = 0;</div><div class="line">                        e.EaNameLength = sizeof(ea_name0)-1;</div><div class="line">                        e.EaValueLength = 0;</div><div class="line">                        iffl::copy_data(e.EaName,</div><div class="line">                                        ea_name0,</div><div class="line">                                        sizeof(ea_name0)-1);</div><div class="line">                      });</div><div class="line"></div><div class="line">    char const ea_name1[] = &quot;TEST_EA_1&quot;;</div><div class="line">    char const ea_data1[] = {1,2,3};</div><div class="line"></div><div class="line">    eas.emplace_back(FFL_SIZE_THROUGH_FIELD(FILE_FULL_EA_INFORMATION, EaValueLength) </div><div class="line">                     + sizeof(ea_name1)-1</div><div class="line">                     + sizeof(ea_data1),</div><div class="line">                     [](char *buffer,</div><div class="line">                        size_t new_element_size) {</div><div class="line">                        FILE_FULL_EA_INFORMATION &amp;e = *reinterpret_cast&lt;FILE_FULL_EA_INFORMATION *&gt;(buffer);</div><div class="line">                        e.Flags = 1;</div><div class="line">                        e.EaNameLength = sizeof(ea_name1)-1;</div><div class="line">                        e.EaValueLength = sizeof(ea_data1);</div><div class="line">                        iffl::copy_data(e.EaName,</div><div class="line">                                        ea_name1,</div><div class="line">                                        sizeof(ea_name1)-1);</div><div class="line">                        iffl::copy_data(e.EaName + sizeof(ea_name1)-1,</div><div class="line">                                        ea_data1,</div><div class="line">                                        sizeof(ea_data1));</div><div class="line">                      });</div><div class="line"></div><div class="line">    handle_ea(eas.data(), eas.used_capacity());</div><div class="line"> }</div></div><!-- fragment --><p> If user prefers separate buffer validation and element processing then she can use default <a class="el" href="namespaceiffl.html#acc441db8c5aefecefdb749acc8b5c50f" title="Validates that buffer contains valid flat forward list and returns a pointer to the last element.">iffl::flat_forward_list_validate</a> validation functor, and ince validation passes use iterators to walk the elements. Here is a samole implementation:</p>
<div class="fragment"><div class="line">using ea_iterator = iffl::flat_forward_list_iterator&lt;FILE_FULL_EA_INFORMATION&gt;;</div><div class="line">using ea_const_iterator = iffl::flat_forward_list_const_iterator&lt;FILE_FULL_EA_INFORMATION&gt;;</div><div class="line"></div><div class="line">void handle_ea(char const *buffer, size_t buffer_lenght) {</div><div class="line">    size_t idx{ 0 };</div><div class="line">    char const *failed_validation{ nullptr };</div><div class="line">    size_t invalid_element_length{ 0 };</div><div class="line">    //</div><div class="line">    // Use flat_forward_list_validate algorithm to safely process elements of untrusted input buffer</div><div class="line">    //</div><div class="line">    auto[is_valid, last_valid] = iffl::flat_forward_list_validate&lt;FILE_FULL_EA_INFORMATION&gt;( buffer, buffer + buffer_lenght);</div><div class="line">    //</div><div class="line">    // If buffer contains a valid non-empty list then use iterators to walk elements</div><div class="line">    //</div><div class="line">    if (is_valid &amp;&amp; last_valid) {</div><div class="line">        std::for_each(</div><div class="line">            ea_const_iterator{buffer}, </div><div class="line">            ea_const_iterator{}, // this sentinel iterator plays a role of end</div><div class="line">             [](FILE_FULL_EA_INFORMATION const &amp;e) {</div><div class="line">                    printf(&quot;FILE_FULL_EA_INFORMATION @ = 0x%p\n&quot;, &amp;e);</div><div class="line">             }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>You can find sample implementation for another type FLAT_FORWARD_LIST_TEST at <a href="https://github.com/vladp72/iffl/blob/master/test/iffl_test_cases.cpp">test\iffl_test_cases.cpp</a> Addition documetation is in <a href="https://github.com/vladp72/iffl/blob/master/include/iffl.h">iffl.h</a> right above declaration of primary template for flat_forward_list_traits</p>
<p>If picking traits using partial specialization is not feasible then traits can be passed as</p>
<p>an explicit template parameter. For example: </p><div class="fragment"><div class="line">using ffl_iterator = iffl::flat_forward_list_iterator&lt;FILE_FULL_EA_INFORMATION, my_alternative_ea_traits&gt;;</div></div><!-- fragment --><p>Container interface </p><div class="fragment"><div class="line">struct attach_buffer {};</div><div class="line"></div><div class="line">struct as_pointers {};</div><div class="line"></div><div class="line">template &lt;typename T,</div><div class="line">          typename TT = flat_forward_list_traits&lt;T&gt;,</div><div class="line">          typename A = std::allocator&lt;char&gt;&gt;</div><div class="line">class flat_forward_list </div><div class="line"></div><div class="line">    //</div><div class="line">    // Technically we need T to be </div><div class="line">    // - trivialy destructable</div><div class="line">    // - trivialy constructable</div><div class="line">    // - trivialy movable</div><div class="line">    // - trivialy copyable</div><div class="line">    //</div><div class="line">    static_assert(std::is_pod_v&lt;T&gt;, &quot;T must be a Plain Old Definition&quot;);</div><div class="line"></div><div class="line">    using size_type = typename container_element_type_base&lt;T&gt;::size_type;</div><div class="line">    using difference_type = typename container_element_type_base&lt;T&gt;::difference_type;</div><div class="line">    using buffer_value_type = char;</div><div class="line">    using const_buffer_value_type = char const;</div><div class="line">    using element_traits_type = TT;</div><div class="line">    using allocator_type = A ;</div><div class="line">    using allocator_type_t = std::allocator_traits&lt;A&gt;;</div><div class="line">    using buffer_pointer = char *;</div><div class="line">    using const_buffer_pointer = char const *;</div><div class="line">    using buffer_reference = char &amp; ;</div><div class="line">    using const_buffer_reference = char const &amp;;</div><div class="line"></div><div class="line">    //</div><div class="line">    // pointer to the start of buffer</div><div class="line">    // used buffer size</div><div class="line">    // total buffer size</div><div class="line">    //</div><div class="line">    using detach_type_as_size = std::tuple&lt;char *, size_t, size_t&gt;;</div><div class="line">    using detach_type_as_pointers = std::tuple&lt;char *, char *, char *&gt;;</div><div class="line"></div><div class="line">    using iterator = flat_forward_list_iterator&lt;T, TT&gt;;</div><div class="line">    using const_iterator = flat_forward_list_const_iterator&lt;T, TT&gt;;</div><div class="line"></div><div class="line">    inline static size_type const npos = std::numeric_limits&lt;size_type&gt;::max();</div><div class="line"></div><div class="line">    flat_forward_list() noexcept;</div><div class="line"></div><div class="line">    explicit flat_forward_list(A a) noexcept;</div><div class="line"></div><div class="line">    flat_forward_list(flat_forward_list &amp;&amp; other) noexcept;</div><div class="line"></div><div class="line">    flat_forward_list(flat_forward_list const &amp;other);</div><div class="line"></div><div class="line">    template &lt;typename AA = A&gt;</div><div class="line">    flat_forward_list(attach_buffer,</div><div class="line">                      char *buffer_begin,</div><div class="line">                      char *last_element,</div><div class="line">                      char *buffer_end,</div><div class="line">                      AA &amp;&amp;a = AA{}) noexcept;</div><div class="line"></div><div class="line">    template &lt;typename AA = A&gt;</div><div class="line">    flat_forward_list(char const *buffer_begin,</div><div class="line">                      char const *last_element,</div><div class="line">                      char const *buffer_end,</div><div class="line">                      AA &amp;&amp;a = AA{});</div><div class="line"></div><div class="line">    template &lt;typename AA = A&gt;</div><div class="line">    flat_forward_list(attach_buffer,</div><div class="line">                      char *buffer,</div><div class="line">                      size_t buffer_size,</div><div class="line">                      AA &amp;&amp;a = AA{}) noexcept;</div><div class="line"></div><div class="line">    template &lt;typename AA = A&gt;</div><div class="line">    flat_forward_list(char const *buffer,</div><div class="line">                      size_t buffer_size,</div><div class="line">                      AA &amp;&amp;a = AA{}) noexcept;</div><div class="line"></div><div class="line">    flat_forward_list &amp;operator= (flat_forward_list &amp;&amp; other) noexcept (allocator_type_t::propagate_on_container_move_assignment::value);</div><div class="line"></div><div class="line">    flat_forward_list &amp;operator= (flat_forward_list const &amp;other);</div><div class="line"></div><div class="line">    ~flat_forward_list() noexcept;</div><div class="line"></div><div class="line">    detach_type_as_size detach() noexcept;</div><div class="line"></div><div class="line">    detach_type_as_pointers detach(as_pointers) noexcept;</div><div class="line"></div><div class="line">    void attach(char *buffer_begin,</div><div class="line">                char *last_element,</div><div class="line">                char *buffer_end);</div><div class="line"></div><div class="line">    bool try_attach(char *buffer,</div><div class="line">                    size_t buffer_size) noexcept;</div><div class="line"></div><div class="line">    void copy_from_buffer(char const *buffer_begin,</div><div class="line">                          char const *last_element,</div><div class="line">                          char const *buffer_end);</div><div class="line"></div><div class="line">    bool copy_from_buffer(char const *buffer_begin,</div><div class="line">                          char const *buffer_end);</div><div class="line"></div><div class="line">    bool copy_from_buffer(char const *buffer,</div><div class="line">                          size_type buffer_size);</div><div class="line"></div><div class="line">    template&lt;typename AA&gt;</div><div class="line">    bool is_compatible_allocator(AA const &amp;other_allocator) const noexcept;</div><div class="line"></div><div class="line">    A &amp;get_allocator() &amp; noexcept;</div><div class="line"></div><div class="line">    A const &amp;get_allocator() const &amp; noexcept;</div><div class="line"></div><div class="line">    A &amp;&amp; get_allocator() &amp;&amp; noexcept;</div><div class="line"></div><div class="line">    size_type max_size() const noexcept;</div><div class="line"></div><div class="line">    void clear() noexcept;</div><div class="line"></div><div class="line">    void shrink_to_fit();</div><div class="line"></div><div class="line">    void resize_buffer(size_type size);</div><div class="line"></div><div class="line">    void push_back(size_type init_buffer_size,</div><div class="line">                   char const *init_buffer = nullptr);</div><div class="line"></div><div class="line">    template &lt;typename F, typename ... P&gt;</div><div class="line">    void emplace_back(size_type element_size,</div><div class="line">                      F const &amp;fn,</div><div class="line">                      P&amp;&amp; ... p);</div><div class="line"></div><div class="line">    iterator insert(iterator const &amp;it, </div><div class="line">                    size_type init_buffer_size, </div><div class="line">                    char const *init_buffer = nullptr);</div><div class="line"></div><div class="line">    template &lt;typename F, </div><div class="line">              typename ... P&gt;</div><div class="line">    iterator emplace(iterator const &amp;it,</div><div class="line">                     size_type new_element_size,</div><div class="line">                     F const &amp;fn,</div><div class="line">                     P&amp;&amp; ... p);</div><div class="line"></div><div class="line">    void push_front(size_type init_buffer_size, char const *init_buffer = nullptr);</div><div class="line"></div><div class="line">    template &lt;typename F,</div><div class="line">              typename ... P &gt;</div><div class="line">    void emplace_front(size_type element_size, </div><div class="line">                       F const &amp;fn,</div><div class="line">                       P&amp;&amp; ... p );</div><div class="line"></div><div class="line">    void pop_front();</div><div class="line"></div><div class="line">    void erase_after(iterator const &amp;it) noexcept;</div><div class="line"></div><div class="line">    //</div><div class="line">    // Usualy pair of iterators define aa half opened range [start, end)</div><div class="line">    // Note that in this case our range is (start, last]. In other words</div><div class="line">    // we will erase all elements after start, including last.</div><div class="line">    // We give this method unusual name so people would stop and read</div><div class="line">    // this comment about range</div><div class="line">    //</div><div class="line">    void erase_after_half_closed(iterator const &amp;before_start, iterator const &amp;last) noexcept;</div><div class="line"></div><div class="line">    void erase_all_after(iterator const &amp;it) noexcept;</div><div class="line"></div><div class="line">    iterator erase_all_from(iterator const &amp;it) noexcept;</div><div class="line"></div><div class="line">    void erase_all() noexcept;</div><div class="line"></div><div class="line">    iterator erase(iterator const &amp;it);</div><div class="line"></div><div class="line">    iterator erase(iterator const &amp;start, iterator const &amp;end) noexcept;</div><div class="line"></div><div class="line">    void swap(flat_forward_list &amp;other) noexcept (allocator_type_t::propagate_on_container_swap::value ||</div><div class="line">                                                  allocator_type_t::propagate_on_container_move_assignment::value);</div><div class="line"></div><div class="line">    template &lt;typename LESS_F&gt;</div><div class="line">    void sort(LESS_F const &amp;fn);</div><div class="line"></div><div class="line">    void reverse();</div><div class="line"></div><div class="line">    template&lt;class F&gt;</div><div class="line">    void merge(flat_forward_list &amp;other,</div><div class="line">               F const &amp;fn);</div><div class="line"></div><div class="line">    template&lt;typename F&gt;</div><div class="line">    void unique(F const &amp;fn);</div><div class="line"></div><div class="line">    template&lt;typename F&gt;</div><div class="line">    void remove_if(F const &amp;fn);</div><div class="line">     </div><div class="line">    T &amp;front();</div><div class="line"></div><div class="line">    T const &amp;front() const;</div><div class="line"></div><div class="line">    T &amp;back();</div><div class="line"></div><div class="line">    T const &amp;back() const;</div><div class="line"></div><div class="line">    iterator begin() noexcept;</div><div class="line"></div><div class="line">    const_iterator begin() const noexcept;</div><div class="line"></div><div class="line">    iterator last() noexcept;</div><div class="line"></div><div class="line">    const_iterator last() const noexcept;</div><div class="line"></div><div class="line">    iterator end() noexcept;</div><div class="line"></div><div class="line">    const_iterator end() const noexcept;</div><div class="line"></div><div class="line">    const_iterator cbegin() const noexcept;</div><div class="line"></div><div class="line">    const_iterator clast() const noexcept;</div><div class="line"></div><div class="line">    const_iterator cend() const noexcept;</div><div class="line"></div><div class="line">    char *data() noexcept;</div><div class="line"></div><div class="line">    char const *data() const noexcept;</div><div class="line"></div><div class="line">    bool revalidate_data();</div><div class="line"></div><div class="line">    void all_elements_shrink_to_fit();</div><div class="line"></div><div class="line">    void shrink_to_fit(iterator const &amp;it);</div><div class="line"></div><div class="line">    iterator element_add_size(iterator const &amp;it,</div><div class="line">                              size_type size_to_add);</div><div class="line"></div><div class="line">    template &lt;typename F,</div><div class="line">              typename ... P &gt;</div><div class="line">    iterator element_resize(iterator const &amp;it,</div><div class="line">                            size_type element_new_size,</div><div class="line">                            F const &amp;fn,</div><div class="line">                            P&amp;&amp; ... p ) noexcept;</div><div class="line"></div><div class="line">    size_type element_required_size(const_iterator const &amp;it) const noexcept;</div><div class="line"></div><div class="line">    size_type element_used_size(const_iterator const &amp;it) const noexcept;</div><div class="line"></div><div class="line">    std::pair&lt;size_type, size_type&gt; element_range(const_iterator const &amp;it) const noexcept;</div><div class="line"></div><div class="line">    bool element_contains(const_iterator const &amp;it, size_type position) const noexcept;</div><div class="line"></div><div class="line">    iterator find_element_before(size_type position) noexcept;</div><div class="line"></div><div class="line">    const_iterator find_element_before(size_type position) const noexcept;</div><div class="line"></div><div class="line">    iterator find_element_at(size_type position) noexcept;</div><div class="line"></div><div class="line">    const_iterator find_element_at(size_type position) const noexcept;</div><div class="line"></div><div class="line">    iterator find_element_after(size_type position) noexcept;</div><div class="line"></div><div class="line">    const_iterator find_element_after(size_type position) const noexcept;</div><div class="line"></div><div class="line">    size_type size() const noexcept;</div><div class="line"></div><div class="line">    bool empty() const noexcept;</div><div class="line"></div><div class="line">    size_type used_capacity() const noexcept;</div><div class="line"></div><div class="line">    size_type total_capacity() const noexcept;</div><div class="line"></div><div class="line">    size_type remaining_capacity() const noexcept;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
